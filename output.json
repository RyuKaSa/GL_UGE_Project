{
    "APP3/main.cpp": "#include \"utils/global.hpp\"\n#include \"utils/cube.hpp\"\n#include \"utils/sphere.hpp\"\n#include \"utils/scene_object.hpp\"\n#include \"utils/texture.hpp\"\n#include \"utils/collision.hpp\"\n#include \"utils/utilities.hpp\"\n#include \"utils/resource_loader.hpp\"\n#include \"utils/models.hpp\"\n#include \"utils/initialization.hpp\"\n#include \"utils/shader.hpp\"\n#include \"utils/rendering.hpp\"\n#include \"utils/lights.hpp\"\n#include \"utils/material.hpp\"\n#include \"utils/material_manager.hpp\"\n\n#include <src/stb_image.h>\n\n#include <src/tiny_obj_loader.h>\n\n#include <glad/glad.h>\n#include <iostream>\n#include <filesystem>\n#include <glimac/Program.hpp>\n#include <glimac/Image.hpp>\n#include <glimac/SDLWindowManager.hpp>\n// #include <SDL2/SDL.h>\n#include <cstddef> // For offsetof\n#include <vector>\n#include <map>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <glm/glm.hpp> // For vector calculations\n#include <algorithm>\n\nint main(int argc, char *argv[])\n{\n    (void)argc;\n\n    auto windowManager = utils_init::initOpenGL(window_width, window_height);\n\n    if (!gladLoadGL()) {\n        std::cerr << \"Failed to initialize OpenGL context!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n\n    /*********************************\n     * Initialization code\n     *********************************/\n\n    // Sphere setup\n    glimac::Sphere sphere(1, 32, 16);\n    std::vector<SphereVertex> sphereVertices;\n\n    size_t sphereVertexCount = utils_object::createSphereVertices(sphereVertices, sphere);\n    utils_object::computeSphereTangents(sphereVertices);\n\n    GLuint sphereVBO, sphereVAO;\n    utils_object::setupSphereBuffers(sphereVertices, sphereVBO, sphereVAO);\n\n    GLsizei sphereVertexCountGL = static_cast<GLsizei>(sphereVertexCount);\n\n    // Cube setup\n    // Create cube vertices and indices\n    std::vector<Vertex3D> cubeVertices;\n    std::vector<GLuint> cubeIndices;\n    utils_object::createCube(cubeVertices, cubeIndices);\n    utils_object::computeCubeTangents(cubeVertices, cubeIndices);\n\n    // Set up VBO, EBO, and VAO for the cube\n    GLuint cubeVBO, cubeEBO, cubeVAO;\n    utils_object::setupCubeBuffers(cubeVertices, cubeIndices, cubeVBO, cubeEBO, cubeVAO);\n    std::cout << \"Cube VBO, EBO, and VAO set up\" << std::endl;\n\n    glimac::FilePath applicationPath(argv[0]);\n\n    // Load shaders\n    utils_loader::Shader room1(\n        applicationPath.dirPath() + \"APP3/shaders/room1.vs.glsl\",\n        applicationPath.dirPath() + \"APP3/shaders/room1.fs.glsl\");\n\n    // room 2 is to be acticaved when camera position is in the second room, i.e., x > 20.5, no condition on z or y\n    utils_loader::Shader room2(\n        applicationPath.dirPath() + \"APP3/shaders/room2.vs.glsl\",\n        applicationPath.dirPath() + \"APP3/shaders/room2.fs.glsl\");\n\n    utils_loader::Shader depthShader(\n        applicationPath.dirPath() + \"APP3/shaders/point_shadow_depth.vs.glsl\",\n        applicationPath.dirPath() + \"APP3/shaders/point_shadow_depth.fs.glsl\");\n\n    // skybox shader\n    utils_loader::Shader skyboxShader(\n        applicationPath.dirPath() + \"APP3/shaders/skybox.vs.glsl\",\n        applicationPath.dirPath() + \"APP3/shaders/skybox.fs.glsl\");\n\n    // light shader\n    utils_loader::Shader lightShader(\n        applicationPath.dirPath() + \"APP3/shaders/light.vs.glsl\",\n        applicationPath.dirPath() + \"APP3/shaders/light.fs.glsl\");\n\n    // Check shaders\n    if (room1.getID() == 0 || room2.getID() == 0 || depthShader.getID() == 0 || skyboxShader.getID() == 0)\n    {\n        std::cerr << \"Failed to compile/link one or more shaders. Exiting.\" << std::endl;\n        return -1;\n    }\n\n    room1.use();\n    std::cout << \"Unified shader program in use\" << std::endl;\n\n    // Load textures\n    GLuint textureID, stoneTextureID, brownTerracottaTextureID, soccerTextureID;\n    GLuint textureID_normalMap, stoneTextureID_normalMap, brownTerracottaTextureID_normalMap, soccerTextureID_normalMap;\n    GLuint chairBaseColorTextureID, chairNormalMapTextureID;\n\n    GLuint texture_ID_deepslate_emerald_ore, texture_ID_deepslate_emerald_ore_n, texture_ID_deepslate_emerald_ore_s;\n    GLuint texture_ID_glass, texture_ID_purple_stained_glass;\n    GLuint testure_ID_iron_block, texture_ID_iron_block_n, texture_ID_iron_block_s;\n    GLuint texture_ID_note_block, texture_ID_note_block_n, texture_ID_note_block_s;\n    GLuint texture_ID_oak_planks, texture_ID_oak_planks_n, texture_ID_oak_planks_s;\n    GLuint texture_ID_stone_bricks, texture_ID_stone_bricks_n, texture_ID_stone_bricks_s;\n    GLuint skyboxTextureID;\n    GLuint sunTextureID, mercuryTextureID, venusTextureID, venus_atmosphereTextureID;\n    GLuint marsTextureID, jupiterTextureID, saturnTextureID, saturn_ringTextureID;\n    GLuint uranusTextureID, neptuneTextureID;\n    GLuint earthTextureID, earth_nTextureID, earth_sTextureID, earth_atmosphereTextureID;\n\n    GLuint crying_obsidianTextureID, crying_obsidianTextureID_n, crying_obsidianTextureID_s;\n    GLuint deepslateTextureID, deepslateTextureID_n, deepslateTextureID_s;\n    GLuint mossy_stone_bricksTextureID, mossy_stone_bricksTextureID_n, mossy_stone_bricksTextureID_s;\n    GLuint obsidianTextureID, obsidianTextureID_n, obsidianTextureID_s;\n    GLuint portalTextureID, portalTextureID_s;\n\n    utils_loader::loadTextures(textureID, stoneTextureID, brownTerracottaTextureID, soccerTextureID,\n                               textureID_normalMap, stoneTextureID_normalMap, brownTerracottaTextureID_normalMap, soccerTextureID_normalMap,\n                               chairBaseColorTextureID, chairNormalMapTextureID,\n                               texture_ID_deepslate_emerald_ore, texture_ID_deepslate_emerald_ore_n, texture_ID_deepslate_emerald_ore_s,\n                               texture_ID_glass, texture_ID_purple_stained_glass,\n                               testure_ID_iron_block, texture_ID_iron_block_n, texture_ID_iron_block_s,\n                               texture_ID_note_block, texture_ID_note_block_n, texture_ID_note_block_s,\n                               texture_ID_oak_planks, texture_ID_oak_planks_n, texture_ID_oak_planks_s,\n                               texture_ID_stone_bricks, texture_ID_stone_bricks_n, texture_ID_stone_bricks_s,\n                               skyboxTextureID,\n                               sunTextureID, mercuryTextureID, venusTextureID, venus_atmosphereTextureID,\n                               marsTextureID, jupiterTextureID, saturnTextureID, saturn_ringTextureID,\n                               uranusTextureID, neptuneTextureID,\n                               earthTextureID, earth_nTextureID, earth_sTextureID, earth_atmosphereTextureID,\n                               crying_obsidianTextureID, crying_obsidianTextureID_n, crying_obsidianTextureID_s,\n                               deepslateTextureID, deepslateTextureID_n, deepslateTextureID_s,\n                               mossy_stone_bricksTextureID, mossy_stone_bricksTextureID_n, mossy_stone_bricksTextureID_s,\n                               obsidianTextureID, obsidianTextureID_n, obsidianTextureID_s,\n                               portalTextureID, portalTextureID_s,\n                               applicationPath);\n\n    GLuint depthCubeMap, shadowMapFBO;\n    utils_loader::setupDepthCubeMap(depthCubeMap, shadowMapFBO);\n\n    // Check depth shader uniforms\n    std::cout << \"Checking depth shader uniforms...\" << std::endl;\n\n    GLint uDepth_LightSpaceMatrixLocation = depthShader.getUniformLocation(\"uLightSpaceMatrix\");\n    if (uDepth_LightSpaceMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uLightSpaceMatrix' location in depth shader\" << std::endl;\n\n    GLint uDepth_ModelMatrixLocation = depthShader.getUniformLocation(\"model\");\n    if (uDepth_ModelMatrixLocation == -1)\n        std::cerr << \"Failed to get 'model' location in depth shader\" << std::endl;\n\n    // Get uniform location for model matrix in unified shader\n    GLint uModelMatrixLocation = room1.getUniformLocation(\"uModelMatrix\");\n    if (uModelMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uModelMatrix' location in unified shader\" << std::endl;\n\n    // Get uniform locations\n    room1.use();\n    std::cout << \"Shader program in use\" << std::endl;\n\n    // Get uniform locations\n    GLint uMVPMatrixLocation = glGetUniformLocation(room1.getGLId(), \"uMVPMatrix\");\n    GLint uMVMatrixLocation = glGetUniformLocation(room1.getGLId(), \"uMVMatrix\");\n    GLint uNormalMatrixLocation = glGetUniformLocation(room1.getGLId(), \"uNormalMatrix\");\n    GLint uTextureLocation = glGetUniformLocation(room1.getGLId(), \"uTexture\");\n    GLint uUseTextureLocation = glGetUniformLocation(room1.getGLId(), \"uUseTexture\");\n\n    GLint uKdLocation = glGetUniformLocation(room1.getGLId(), \"uKd\");\n    GLint uKsLocation = glGetUniformLocation(room1.getGLId(), \"uKs\");\n    GLint uShininessLocation = glGetUniformLocation(room1.getGLId(), \"uShininess\");\n    GLint uLightPos_vsLocation = glGetUniformLocation(room1.getGLId(), \"uLightPos_vs\");\n    GLint uLightIntensityLocation = glGetUniformLocation(room1.getGLId(), \"uLightIntensity\");\n\n    // Sanity check\n    if (uMVPMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uMVPMatrix' location\" << std::endl;\n    if (uMVMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uMVMatrix' location\" << std::endl;\n    if (uNormalMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uNormalMatrix' location\" << std::endl;\n    if (uTextureLocation == -1)\n        std::cerr << \"Failed to get 'uTexture' location\" << std::endl;\n    if (uUseTextureLocation == -1)\n        std::cerr << \"Failed to get 'uUseTexture' location\" << std::endl;\n    if (uKdLocation == -1)\n        std::cerr << \"Failed to get 'uKd' location\" << std::endl;\n    if (uKsLocation == -1)\n        std::cerr << \"Failed to get 'uKs' location\" << std::endl;\n    if (uShininessLocation == -1)\n        std::cerr << \"Failed to get 'uShininess' location\" << std::endl;\n    // if (uLightDir_vsLocation == -1)\n    //     std::cerr << \"Failed to get 'uLightDir_vs' location\" << std::endl;\n    if (uLightIntensityLocation == -1)\n        std::cerr << \"Failed to get 'uLightIntensity' location\" << std::endl;\n\n    // Retrieve uniform locations for room2\n    room2.use();\n    std::cout << \"Room2 shader program in use\" << std::endl;\n\n    // Get uniform locations for room2\n    GLint room2_uMVPMatrixLocation = glGetUniformLocation(room2.getGLId(), \"uMVPMatrix\");\n    GLint room2_uMVMatrixLocation = glGetUniformLocation(room2.getGLId(), \"uMVMatrix\");\n    GLint room2_uNormalMatrixLocation = glGetUniformLocation(room2.getGLId(), \"uNormalMatrix\");\n    GLint room2_uTextureLocation = glGetUniformLocation(room2.getGLId(), \"uTexture\");\n    GLint room2_uUseTextureLocation = glGetUniformLocation(room2.getGLId(), \"uUseTexture\");\n\n    GLint room2_uKdLocation = glGetUniformLocation(room2.getGLId(), \"uKd\");\n    GLint room2_uKsLocation = glGetUniformLocation(room2.getGLId(), \"uKs\");\n    GLint room2_uShininessLocation = glGetUniformLocation(room2.getGLId(), \"uShininess\");\n    GLint room2_uLightPos_vsLocation = glGetUniformLocation(room2.getGLId(), \"uLightPos_vs\");\n    GLint room2_uLightIntensityLocation = glGetUniformLocation(room2.getGLId(), \"uLightIntensity\");\n    GLint room2_uColorMaskLocation = glGetUniformLocation(room2.getGLId(), \"uColorMask\");\n\n    // Sanity check for room2 uniforms\n    if (room2_uMVPMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uMVPMatrix' location in room2 shader\" << std::endl;\n    if (room2_uMVMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uMVMatrix' location in room2 shader\" << std::endl;\n    if (room2_uNormalMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uNormalMatrix' location in room2 shader\" << std::endl;\n    if (room2_uTextureLocation == -1)\n        std::cerr << \"Failed to get 'uTexture' location in room2 shader\" << std::endl;\n    if (room2_uUseTextureLocation == -1)\n        std::cerr << \"Failed to get 'uUseTexture' location in room2 shader\" << std::endl;\n    if (room2_uKdLocation == -1)\n        std::cerr << \"Failed to get 'uKd' location in room2 shader\" << std::endl;\n    if (room2_uKsLocation == -1)\n        std::cerr << \"Failed to get 'uKs' location in room2 shader\" << std::endl;\n    if (room2_uShininessLocation == -1)\n        std::cerr << \"Failed to get 'uShininess' location in room2 shader\" << std::endl;\n    if (room2_uLightIntensityLocation == -1)\n        std::cerr << \"Failed to get 'uLightIntensity' location in room2 shader\" << std::endl;\n    if (room2_uColorMaskLocation == -1)\n        std::cerr << \"Failed to get 'uColorMask' location in room2 shader\" << std::endl;\n\n    room1.use(); // Activate room1 shader program\n\n    // Assign sampler uniforms to texture units\n    glUniform1i(glGetUniformLocation(room1.getID(), \"uTexture\"), 0);\n    glUniform1i(glGetUniformLocation(room1.getID(), \"uSpecularMap\"), 3);\n    glUniform1i(glGetUniformLocation(room1.getID(), \"uNormalMap\"), 2);\n    glUniform1i(glGetUniformLocation(room1.getID(), \"depthMap\"), 1);\n\n    room1.use(); // Unbind the shader program\n\n    // Repeat for room2 shader if necessary\n    room2.use();\n    glUniform1i(glGetUniformLocation(room2.getID(), \"uTexture\"), 0);\n    glUniform1i(glGetUniformLocation(room2.getID(), \"uSpecularMap\"), 3);\n    glUniform1i(glGetUniformLocation(room2.getID(), \"uNormalMap\"), 2);\n    glUniform1i(glGetUniformLocation(room2.getID(), \"depthMap\"), 1);\n    room2.use(); // Unbind the shader program\n\n    // Set up skybox shader\n    skyboxShader.use();\n    std::cout << \"Sky Shader program in use\" << std::endl;\n\n    // Get uniform locations\n    GLint sky_uMVPMatrixLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uMVPMatrix\");\n    GLint sky_uMVMatrixLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uMVMatrix\");\n    GLint sky_uNormalMatrixLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uNormalMatrix\");\n    GLint sky_uTextureLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uTexture\");\n    GLint sky_uUseTextureLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uUseTexture\");\n\n    GLint sky_uKdLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uKd\");\n    GLint sky_uKsLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uKs\");\n    GLint sky_uShininessLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uShininess\");\n    GLint sky_uLightPos_vsLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uLightPos_vs\");\n    GLint sky_uLightIntensityLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uLightIntensity\");\n\n    // sample skybox texture\n    glUniform1i(glGetUniformLocation(skyboxShader.getID(), \"uTexture\"), 0);\n    glUniform1i(glGetUniformLocation(skyboxShader.getID(), \"uSpecularMap\"), 3);\n    glUniform1i(glGetUniformLocation(skyboxShader.getID(), \"uNormalMap\"), 2);\n    glUniform1i(glGetUniformLocation(skyboxShader.getID(), \"depthMap\"), 1);\n\n    // unbind the shader program\n    skyboxShader.use();\n\n    // Set up light shader\n    lightShader.use();\n    std::cout << \"Light Shader program in use\" << std::endl;\n\n    // Get uniform locations\n    GLint light_uMVPMatrixLocation = glGetUniformLocation(lightShader.getGLId(), \"uMVPMatrix\");\n    GLint light_uMVMatrixLocation = glGetUniformLocation(lightShader.getGLId(), \"uMVMatrix\");\n    GLint light_uNormalMatrixLocation = glGetUniformLocation(lightShader.getGLId(), \"uNormalMatrix\");\n    GLint light_uTextureLocation = glGetUniformLocation(lightShader.getGLId(), \"uTexture\");\n    GLint light_uUseTextureLocation = glGetUniformLocation(lightShader.getGLId(), \"uUseTexture\");\n\n    GLint light_uKdLocation = glGetUniformLocation(lightShader.getGLId(), \"uKd\");\n    GLint light_uKsLocation = glGetUniformLocation(lightShader.getGLId(), \"uKs\");\n    GLint light_uShininessLocation = glGetUniformLocation(lightShader.getGLId(), \"uShininess\");\n    GLint light_uLightPos_vsLocation = glGetUniformLocation(lightShader.getGLId(), \"uLightPos_vs\");\n    GLint light_uLightIntensityLocation = glGetUniformLocation(lightShader.getGLId(), \"uLightIntensity\");\n\n    // sample light texture\n    glUniform1i(glGetUniformLocation(lightShader.getID(), \"uTexture\"), 0);\n    glUniform1i(glGetUniformLocation(lightShader.getID(), \"uSpecularMap\"), 3);\n    glUniform1i(glGetUniformLocation(lightShader.getID(), \"uNormalMap\"), 2);\n    glUniform1i(glGetUniformLocation(lightShader.getID(), \"depthMap\"), 1);\n\n    // unbind the shader program\n    lightShader.use();\n\n    // Enable depth test\n    glEnable(GL_DEPTH_TEST);\n    std::cout << \"Depth test enabled\" << std::endl;\n\n    // Set the clear color to a dark gray\n    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n\n    // Light space matrix for shadows\n    glm::mat4 lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, 1.0f, 50.0f);\n    glm::mat4 lightView = glm::lookAt(glm::vec3(5.0f, 10.0f, 5.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));\n    glm::mat4 lightSpaceMatrix = lightProjection * lightView;\n\n    // Setup projection matrix for cube map\n    float nearPlane = 1.0f;\n    float farPlane = 50.0f;\n    glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), 1.0f, nearPlane, farPlane);\n\n    // Camera parameters\n    glm::vec3 cameraPos(1.0f, 2.0f, 1.0f);    // Initial position of the camera\n    glm::vec3 cameraFront(0.0f, 0.0f, -1.0f); // Direction the camera is looking at\n    glm::vec3 cameraUp(0.0f, 1.0f, 0.0f);     // Up vector\n\n    float cameraPosY = cameraPos.y; // Store the initial y position\n\n    float yaw = -90.0f; // Yaw angle initialized to -90 degrees to look towards negative Z\n    float pitch = 0.0f; // Pitch angle\n\n    float cameraSpeed = 7.0f; // Adjust accordingly (10.0f is kinda fast but good for debugging)\n    float deltaTime = 0.0f;    // Time between current frame and last frame\n    float lastFrame = 0.0f;    // Time of last frame\n\n    // Enable relative mouse mode to capture mouse movement\n    SDL_ShowCursor(SDL_DISABLE); // Hide the cursor\n    SDL_WarpMouse(320, 240);     // Warp mouse to center\n\n\n    int frameCount = 0;\n    float fpsTimer = 0.0f;\n    int fps = 0;\n\n    // ====================\n    // create materials for the scene\n\n    // Define the alpha value for transparency\n    float alphaOpaque = 1.0f; // Fully opaque\n    float alphaTransparent1 = 0.1f;\n    float alphaTransparent2 = 0.2f;\n    float alphaTransparent3 = 0.3f;\n    float alphaTransparent4 = 0.4f;\n    float alphaTransparent5 = 0.5f;\n    float alphaTransparent6 = 0.6f;\n    float alphaTransparent7 = 0.7f;\n    float alphaTransparent8 = 0.8f;\n    float alphaTransparent9 = 0.9f;\n\n    // Material for the floor and walls using stone texture\n    Material stoneMaterial;\n    stoneMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color (will be tinted by texture)\n    stoneMaterial.hasDiffuseMap = true;\n    stoneMaterial.diffuseMapID = stoneTextureID;\n    stoneMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    stoneMaterial.shininess = 32.0f;                // Shininess exponent\n    stoneMaterial.hasSpecularMap = false;\n    stoneMaterial.specularMapID = 0;\n    stoneMaterial.hasNormalMap = true;\n    stoneMaterial.normalMapID = stoneTextureID_normalMap;\n    stoneMaterial.alpha = alphaOpaque; // Opaque\n\n    // Material for walls without stone texture but with general texture\n    Material wallMaterial;\n    wallMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    wallMaterial.hasDiffuseMap = true;\n    wallMaterial.diffuseMapID = textureID;\n    wallMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    wallMaterial.shininess = 32.0f;                // Shininess exponent\n    wallMaterial.hasSpecularMap = false;\n    wallMaterial.specularMapID = 0;\n    wallMaterial.hasNormalMap = true;\n    wallMaterial.normalMapID = textureID_normalMap;\n    wallMaterial.alpha = alphaOpaque; // Opaque\n\n    // Material for separation walls with brown terracotta texture\n    Material terracottaMaterial;\n    terracottaMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    terracottaMaterial.hasDiffuseMap = true;\n    terracottaMaterial.diffuseMapID = brownTerracottaTextureID;\n    terracottaMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    terracottaMaterial.shininess = 32.0f;                // Shininess exponent\n    terracottaMaterial.hasSpecularMap = false;\n    terracottaMaterial.specularMapID = 0;\n    terracottaMaterial.hasNormalMap = true;\n    terracottaMaterial.normalMapID = brownTerracottaTextureID_normalMap;\n    terracottaMaterial.alpha = alphaOpaque; // Opaque\n\n    // Material for transparent cubes without textures\n    Material transparentMaterialNoTexture;\n    transparentMaterialNoTexture.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    transparentMaterialNoTexture.hasDiffuseMap = false;\n    transparentMaterialNoTexture.diffuseMapID = 0;\n    transparentMaterialNoTexture.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    transparentMaterialNoTexture.shininess = 32.0f;                // Shininess exponent\n    transparentMaterialNoTexture.hasSpecularMap = false;\n    transparentMaterialNoTexture.specularMapID = 0;\n    transparentMaterialNoTexture.hasNormalMap = false;\n    transparentMaterialNoTexture.normalMapID = 0;\n    transparentMaterialNoTexture.alpha = alphaTransparent1; // 30% opaque\n\n    // Material for transparent cubes with textures\n    Material transparentMaterialWithTexture;\n    transparentMaterialWithTexture.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    transparentMaterialWithTexture.hasDiffuseMap = true;\n    transparentMaterialWithTexture.diffuseMapID = textureID;         // Ensure textureID is loaded\n    transparentMaterialWithTexture.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    transparentMaterialWithTexture.shininess = 32.0f;                // Shininess exponent\n    transparentMaterialWithTexture.hasSpecularMap = false;           // Assuming no specular map\n    transparentMaterialWithTexture.specularMapID = 0;\n    transparentMaterialWithTexture.hasNormalMap = true;\n    transparentMaterialWithTexture.normalMapID = textureID_normalMap; // Ensure textureID_normalMap is loaded\n    transparentMaterialWithTexture.alpha = alphaTransparent2;         // 50% opaque\n\n    // // Material for the heater model (no textures)\n    // Material heaterMaterial;\n    // heaterMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    // heaterMaterial.hasDiffuseMap = false;\n    // heaterMaterial.diffuseMapID = 0;\n    // heaterMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    // heaterMaterial.shininess = 32.0f;                // Shininess exponent\n    // heaterMaterial.hasSpecularMap = false;\n    // heaterMaterial.specularMapID = 0;\n    // heaterMaterial.hasNormalMap = false;\n    // heaterMaterial.normalMapID = 0;\n    // heaterMaterial.alpha = alphaOpaque; // Opaque\n\n    // Material for the rocking chair model with textures\n    Material rockingChairMaterial;\n    rockingChairMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    rockingChairMaterial.hasDiffuseMap = true;\n    rockingChairMaterial.diffuseMapID = chairBaseColorTextureID;\n    rockingChairMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    rockingChairMaterial.shininess = 32.0f;                // Shininess exponent\n    rockingChairMaterial.hasSpecularMap = false;           // Assuming no specular map\n    rockingChairMaterial.specularMapID = 0;\n    rockingChairMaterial.hasNormalMap = true;\n    rockingChairMaterial.normalMapID = chairNormalMapTextureID;\n    rockingChairMaterial.alpha = alphaOpaque; // Opaque\n\n    // Material for the torus model (no textures)\n    Material torusMaterial;\n    torusMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    torusMaterial.hasDiffuseMap = false;\n    torusMaterial.diffuseMapID = 0;\n    torusMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    torusMaterial.shininess = 32.0f;                // Shininess exponent\n    torusMaterial.hasSpecularMap = false;\n    torusMaterial.specularMapID = 0;\n    torusMaterial.hasNormalMap = false;\n    torusMaterial.normalMapID = 0;\n    torusMaterial.alpha = alphaTransparent5; // 50% opaque\n\n    // Define the soccer ball material\n    Material soccerMaterial;\n    soccerMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    soccerMaterial.hasDiffuseMap = true;\n    soccerMaterial.diffuseMapID = soccerTextureID;   // Ensure soccerTextureID is loaded\n    soccerMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    soccerMaterial.shininess = 32.0f;                // Shininess exponent\n    soccerMaterial.hasSpecularMap = false;           // Assuming no specular map\n    soccerMaterial.specularMapID = 0;\n    soccerMaterial.hasNormalMap = true;\n    soccerMaterial.normalMapID = soccerTextureID_normalMap; // Ensure soccerTextureID_normalMap is loaded\n    soccerMaterial.alpha = alphaOpaque;\n\n    // Define a reference to the MaterialManager singleton\n    MaterialManager &materialManager = MaterialManager::getInstance();\n\n    // Add materials to the MaterialManager function is addOrGetMaterial\n    materialManager.addOrGetMaterial(stoneMaterial);\n    materialManager.addOrGetMaterial(wallMaterial);\n    materialManager.addOrGetMaterial(terracottaMaterial);\n    materialManager.addOrGetMaterial(transparentMaterialNoTexture);\n    materialManager.addOrGetMaterial(transparentMaterialWithTexture);\n    // materialManager.addOrGetMaterial(heaterMaterial);\n    materialManager.addOrGetMaterial(rockingChairMaterial);\n    materialManager.addOrGetMaterial(torusMaterial);\n    materialManager.addOrGetMaterial(soccerMaterial);\n\n    // second set of materials, with specular maps\n    // Material for stone_bricks\n    Material stone_bricks_material;\n    stone_bricks_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    stone_bricks_material.hasDiffuseMap = true;\n    stone_bricks_material.diffuseMapID = texture_ID_stone_bricks;\n    stone_bricks_material.Ks = glm::vec3(0.4f, 0.4f, 0.4f);\n    stone_bricks_material.shininess = 16.0f;\n    stone_bricks_material.hasSpecularMap = true;\n    stone_bricks_material.specularMapID = texture_ID_stone_bricks_s;\n    stone_bricks_material.hasNormalMap = true;\n    stone_bricks_material.normalMapID = texture_ID_stone_bricks_n;\n    stone_bricks_material.alpha = alphaOpaque;\n\n    // // Material for transparent cubes with textures\n    // Material transparentMaterialWithTexture;\n    // transparentMaterialWithTexture.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    // transparentMaterialWithTexture.hasDiffuseMap = true;\n    // transparentMaterialWithTexture.diffuseMapID = textureID; // Ensure textureID is loaded\n    // transparentMaterialWithTexture.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    // transparentMaterialWithTexture.shininess = 32.0f; // Shininess exponent\n    // transparentMaterialWithTexture.hasSpecularMap = false; // Assuming no specular map\n    // transparentMaterialWithTexture.specularMapID = 0;\n    // transparentMaterialWithTexture.hasNormalMap = true;\n    // transparentMaterialWithTexture.normalMapID = textureID_normalMap; // Ensure textureID_normalMap is loaded\n    // transparentMaterialWithTexture.alpha = alphaTransparent2; // 50% opaque\n\n    // Material for glass and purple stained glass\n    Material glass_material;\n    glass_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    glass_material.hasDiffuseMap = true;\n    glass_material.diffuseMapID = texture_ID_glass;\n    glass_material.Ks = glm::vec3(0.9f, 0.9f, 0.9f);\n    glass_material.shininess = 130.0f;\n    glass_material.hasSpecularMap = false;\n    glass_material.specularMapID = 0;\n    glass_material.hasNormalMap = false;\n    glass_material.normalMapID = 0;\n    glass_material.alpha = alphaTransparent5;\n\n    Material purple_stained_glass_material;\n    purple_stained_glass_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    purple_stained_glass_material.hasDiffuseMap = true;\n    purple_stained_glass_material.diffuseMapID = texture_ID_purple_stained_glass;\n    purple_stained_glass_material.Ks = glm::vec3(0.9f, 0.7f, 0.9f);\n    purple_stained_glass_material.shininess = 130.0f;\n    purple_stained_glass_material.hasSpecularMap = false;\n    purple_stained_glass_material.specularMapID = 0;\n    purple_stained_glass_material.hasNormalMap = false;\n    purple_stained_glass_material.normalMapID = 0;\n    purple_stained_glass_material.alpha = alphaTransparent5;\n\n    // Material for iron block\n    Material iron_block_material;\n    iron_block_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    iron_block_material.hasDiffuseMap = true;\n    iron_block_material.diffuseMapID = testure_ID_iron_block;\n    iron_block_material.Ks = glm::vec3(0.8f, 0.8f, 0.8f);\n    iron_block_material.shininess = 64.0f;\n    iron_block_material.hasSpecularMap = true;\n    iron_block_material.specularMapID = texture_ID_iron_block_s;\n    iron_block_material.hasNormalMap = true;\n    iron_block_material.normalMapID = texture_ID_iron_block_n;\n    iron_block_material.alpha = alphaOpaque;\n\n    // Material for note block\n    Material note_block_material;\n    note_block_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    note_block_material.hasDiffuseMap = true;\n    note_block_material.diffuseMapID = texture_ID_note_block;\n    note_block_material.Ks = glm::vec3(0.2f, 0.2f, 0.2f);\n    note_block_material.shininess = 8.0f;\n    note_block_material.hasSpecularMap = true;\n    note_block_material.specularMapID = texture_ID_note_block_s;\n    note_block_material.hasNormalMap = true;\n    note_block_material.normalMapID = texture_ID_note_block_n;\n    note_block_material.alpha = alphaOpaque;\n\n    // Material for oak planks\n    Material oak_planks_material;\n    oak_planks_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    oak_planks_material.hasDiffuseMap = true;\n    oak_planks_material.diffuseMapID = texture_ID_oak_planks;\n    oak_planks_material.Ks = glm::vec3(0.3f, 0.3f, 0.3f);\n    oak_planks_material.shininess = 12.0f;\n    oak_planks_material.hasSpecularMap = true;\n    oak_planks_material.specularMapID = texture_ID_oak_planks_s;\n    oak_planks_material.hasNormalMap = true;\n    oak_planks_material.normalMapID = texture_ID_oak_planks_n;\n    oak_planks_material.alpha = alphaOpaque;\n\n    // material deepslate_emerald_ore\n    Material deepslate_emerald_ore_material;\n    deepslate_emerald_ore_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    deepslate_emerald_ore_material.hasDiffuseMap = true;\n    deepslate_emerald_ore_material.diffuseMapID = texture_ID_deepslate_emerald_ore;\n    deepslate_emerald_ore_material.Ks = glm::vec3(0.6f, 0.8f, 0.6f);\n    deepslate_emerald_ore_material.shininess = 54.0f;\n    deepslate_emerald_ore_material.hasSpecularMap = true;\n    deepslate_emerald_ore_material.specularMapID = texture_ID_deepslate_emerald_ore_s;\n    deepslate_emerald_ore_material.hasNormalMap = true;\n    deepslate_emerald_ore_material.normalMapID = texture_ID_deepslate_emerald_ore_n;\n    deepslate_emerald_ore_material.alpha = alphaOpaque;\n\n    // add transparent iron block\n    Material transparent_iron_block_material;\n    transparent_iron_block_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f);\n    transparent_iron_block_material.hasDiffuseMap = true;\n    transparent_iron_block_material.diffuseMapID = testure_ID_iron_block;\n    transparent_iron_block_material.Ks = glm::vec3(0.8f, 0.8f, 0.8f);\n    transparent_iron_block_material.shininess = 64.0f;\n    transparent_iron_block_material.hasSpecularMap = true;\n    transparent_iron_block_material.specularMapID = texture_ID_iron_block_s;\n    transparent_iron_block_material.hasNormalMap = true;\n    transparent_iron_block_material.normalMapID = texture_ID_iron_block_n;\n    transparent_iron_block_material.alpha = alphaTransparent5;\n\n    // Add materials to the MaterialManager\n    materialManager.addOrGetMaterial(stone_bricks_material);\n    materialManager.addOrGetMaterial(glass_material);\n    materialManager.addOrGetMaterial(purple_stained_glass_material);\n    materialManager.addOrGetMaterial(iron_block_material);\n    materialManager.addOrGetMaterial(note_block_material);\n    materialManager.addOrGetMaterial(oak_planks_material);\n    materialManager.addOrGetMaterial(deepslate_emerald_ore_material);\n\n    // sky material (big sphere around the scene)\n    Material skyMaterial;\n    skyMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    skyMaterial.hasDiffuseMap = true;\n    skyMaterial.diffuseMapID = skyboxTextureID;\n    skyMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    skyMaterial.shininess = 0.0f;                 // Shininess exponent\n    skyMaterial.hasSpecularMap = false;           // Assuming no specular map\n    skyMaterial.specularMapID = 0;\n    skyMaterial.hasNormalMap = false;\n    skyMaterial.normalMapID = 0;\n    skyMaterial.alpha = alphaOpaque; // Opaque\n\n    // light material\n    Material lightMaterial;\n    lightMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    lightMaterial.hasDiffuseMap = false;\n    lightMaterial.diffuseMapID = 0;\n    lightMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    lightMaterial.shininess = 32.0f;                // Shininess exponent\n    lightMaterial.hasSpecularMap = false;\n    lightMaterial.specularMapID = 0;\n    lightMaterial.hasNormalMap = false;\n    lightMaterial.normalMapID = 0;\n    lightMaterial.alpha = alphaOpaque; // Opaque\n\n    Material simpleLightMaterial;\n    simpleLightMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // Default white color\n    simpleLightMaterial.Ks = glm::vec3(0.0f);            // No specular reflection\n    simpleLightMaterial.shininess = 1.0f;               // Low shininess\n    simpleLightMaterial.alpha = 1.0f;                   // Opaque\n\n    // Add sky material to the MaterialManager\n    materialManager.addOrGetMaterial(skyMaterial);\n    materialManager.addOrGetMaterial(lightMaterial);\n    materialManager.addOrGetMaterial(simpleLightMaterial);\n\n    // planet materials in order\n\n    // sun material\n    Material sunMaterial;\n    sunMaterial.Kd = glm::vec3(1.0f, 0.8f, 0.6f);\n    sunMaterial.hasDiffuseMap = true;\n    sunMaterial.diffuseMapID = sunTextureID;\n    sunMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    sunMaterial.shininess = 0.0f;                // Shininess exponent\n    sunMaterial.hasSpecularMap = false;\n    sunMaterial.specularMapID = 0;\n    sunMaterial.hasNormalMap = false;\n    sunMaterial.normalMapID = 0;\n    sunMaterial.alpha = alphaTransparent9; // Transparent\n\n    // mercury material\n    Material mercuryMaterial;\n    mercuryMaterial.Kd = glm::vec3(0.5f, 0.5f, 0.5f);\n    mercuryMaterial.hasDiffuseMap = true;\n    mercuryMaterial.diffuseMapID = mercuryTextureID;\n    mercuryMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    mercuryMaterial.shininess = 20.0f;                // Shininess exponent\n    mercuryMaterial.hasSpecularMap = false;\n    mercuryMaterial.specularMapID = 0;\n    mercuryMaterial.hasNormalMap = false;\n    mercuryMaterial.normalMapID = 0;\n    mercuryMaterial.alpha = alphaOpaque; // Opaque\n\n    // venus material\n    Material venusMaterial;\n    venusMaterial.Kd = glm::vec3(0.8f, 0.7f, 0.6f);\n    venusMaterial.hasDiffuseMap = true;\n    venusMaterial.diffuseMapID = venusTextureID;\n    venusMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    venusMaterial.shininess = 25.0f;                // Shininess exponent\n    venusMaterial.hasSpecularMap = false;\n    venusMaterial.specularMapID = 0;\n    venusMaterial.hasNormalMap = false;\n    venusMaterial.normalMapID = 0;\n    venusMaterial.alpha = alphaOpaque; // Opaque\n\n    // venus atmosphere is transparent\n    Material venusAtmosphereMaterial;\n    venusAtmosphereMaterial.Kd = glm::vec3(0.7f, 0.7f, 0.9f);\n    venusAtmosphereMaterial.hasDiffuseMap = true;\n    venusAtmosphereMaterial.diffuseMapID = venus_atmosphereTextureID;\n    venusAtmosphereMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    venusAtmosphereMaterial.shininess = 5.0f;                // Shininess exponent\n    venusAtmosphereMaterial.hasSpecularMap = false;\n    venusAtmosphereMaterial.specularMapID = 0;\n    venusAtmosphereMaterial.hasNormalMap = false;\n    venusAtmosphereMaterial.normalMapID = 0;\n    venusAtmosphereMaterial.alpha = alphaTransparent3; // Transparent\n\n    // earth material, has diffuse, specular, and normal maps\n    Material earthMaterial;\n    earthMaterial.Kd = glm::vec3(0.4f, 0.6f, 0.8f);\n    earthMaterial.hasDiffuseMap = true;\n    earthMaterial.diffuseMapID = earthTextureID;\n    earthMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    earthMaterial.shininess = 30.0f;                // Shininess exponent\n    earthMaterial.hasSpecularMap = true;\n    earthMaterial.specularMapID = earth_sTextureID;\n    earthMaterial.hasNormalMap = true;\n    earthMaterial.normalMapID = earth_nTextureID;\n    earthMaterial.alpha = alphaOpaque; // Opaque\n\n    // earth atmosphere is transparent\n    Material earthAtmosphereMaterial;\n    earthAtmosphereMaterial.Kd = glm::vec3(0.6f, 0.7f, 0.9f); // White color\n    earthAtmosphereMaterial.hasDiffuseMap = true;\n    earthAtmosphereMaterial.diffuseMapID = earth_atmosphereTextureID;\n    earthAtmosphereMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    earthAtmosphereMaterial.shininess = 8.0f;                // Shininess exponent\n    earthAtmosphereMaterial.hasSpecularMap = false;\n    earthAtmosphereMaterial.specularMapID = 0;\n    earthAtmosphereMaterial.hasNormalMap = false;\n    earthAtmosphereMaterial.normalMapID = 0;\n    earthAtmosphereMaterial.alpha = alphaTransparent3;\n\n    // mars material\n    Material marsMaterial;\n    marsMaterial.Kd = glm::vec3(0.6f, 0.3f, 0.2f);\n    marsMaterial.hasDiffuseMap = true;\n    marsMaterial.diffuseMapID = marsTextureID;\n    marsMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    marsMaterial.shininess = 15.0f;                // Shininess exponent\n    marsMaterial.hasSpecularMap = false;\n    marsMaterial.specularMapID = 0;\n    marsMaterial.hasNormalMap = false;\n    marsMaterial.normalMapID = 0;\n    marsMaterial.alpha = alphaOpaque; // Opaque\n\n    // jupiter material\n    Material jupiterMaterial;\n    jupiterMaterial.Kd = glm::vec3(0.7f, 0.6f, 0.5f);\n    jupiterMaterial.hasDiffuseMap = true;\n    jupiterMaterial.diffuseMapID = jupiterTextureID;\n    jupiterMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    jupiterMaterial.shininess = 18.0f;                // Shininess exponent\n    jupiterMaterial.hasSpecularMap = false;\n    jupiterMaterial.specularMapID = 0;\n    jupiterMaterial.hasNormalMap = false;\n    jupiterMaterial.normalMapID = 0;\n    jupiterMaterial.alpha = alphaOpaque; // Opaque\n\n    // saturn material\n    Material saturnMaterial;\n    saturnMaterial.Kd = glm::vec3(0.8f, 0.7f, 0.6f);\n    saturnMaterial.hasDiffuseMap = true;\n    saturnMaterial.diffuseMapID = saturnTextureID;\n    saturnMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    saturnMaterial.shininess = 25.0f;                // Shininess exponent\n    saturnMaterial.hasSpecularMap = false;\n    saturnMaterial.specularMapID = 0;\n    saturnMaterial.hasNormalMap = false;\n    saturnMaterial.normalMapID = 0;\n    saturnMaterial.alpha = alphaOpaque; // Opaque\n\n    // saturn ring material\n    Material saturnRingMaterial;\n    saturnRingMaterial.Kd = glm::vec3(0.9f, 0.8f, 0.7f);\n    saturnRingMaterial.hasDiffuseMap = true;\n    saturnRingMaterial.diffuseMapID = saturn_ringTextureID;\n    saturnRingMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    saturnRingMaterial.shininess = 60.0f;                // Shininess exponent\n    saturnRingMaterial.hasSpecularMap = false;\n    saturnRingMaterial.specularMapID = 0;\n    saturnRingMaterial.hasNormalMap = false;\n    saturnRingMaterial.normalMapID = 0;\n    saturnRingMaterial.alpha = alphaTransparent4; // Transparent\n\n    // uranus material\n    Material uranusMaterial;\n    uranusMaterial.Kd = glm::vec3(0.5f, 0.7f, 0.8f);\n    uranusMaterial.hasDiffuseMap = true;\n    uranusMaterial.diffuseMapID = uranusTextureID;\n    uranusMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    uranusMaterial.shininess = 20.0f;                // Shininess exponent\n    uranusMaterial.hasSpecularMap = false;\n    uranusMaterial.specularMapID = 0;\n    uranusMaterial.hasNormalMap = false;\n    uranusMaterial.normalMapID = 0;\n    uranusMaterial.alpha = alphaOpaque; // Opaque\n\n    // neptune material\n    Material neptuneMaterial;\n    neptuneMaterial.Kd = glm::vec3(0.4f, 0.6f, 0.9f);\n    neptuneMaterial.hasDiffuseMap = true;\n    neptuneMaterial.diffuseMapID = neptuneTextureID;\n    neptuneMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    neptuneMaterial.shininess = 22.0f;                // Shininess exponent\n    neptuneMaterial.hasSpecularMap = false;\n    neptuneMaterial.specularMapID = 0;\n    neptuneMaterial.hasNormalMap = false;\n    neptuneMaterial.normalMapID = 0;\n    neptuneMaterial.alpha = alphaOpaque; // Opaque\n\n    // fuck pluto, not a real planet\n\n    // add to manager\n    materialManager.addOrGetMaterial(sunMaterial);\n    materialManager.addOrGetMaterial(mercuryMaterial);\n    materialManager.addOrGetMaterial(venusMaterial);\n    materialManager.addOrGetMaterial(venusAtmosphereMaterial);\n    materialManager.addOrGetMaterial(earthMaterial);\n    materialManager.addOrGetMaterial(earthAtmosphereMaterial);\n    materialManager.addOrGetMaterial(marsMaterial);\n    materialManager.addOrGetMaterial(jupiterMaterial);\n    materialManager.addOrGetMaterial(saturnMaterial);\n    materialManager.addOrGetMaterial(saturnRingMaterial);\n    materialManager.addOrGetMaterial(uranusMaterial);\n    materialManager.addOrGetMaterial(neptuneMaterial);\n\n    // more material\n    // crying obsidian\n    Material crying_obsidian_material;\n    crying_obsidian_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    crying_obsidian_material.hasDiffuseMap = true;\n    crying_obsidian_material.diffuseMapID = crying_obsidianTextureID;\n    crying_obsidian_material.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    crying_obsidian_material.shininess = 32.0f;                // Shininess exponent\n    crying_obsidian_material.hasSpecularMap = true;\n    crying_obsidian_material.specularMapID = crying_obsidianTextureID_s;\n    crying_obsidian_material.hasNormalMap = true;\n    crying_obsidian_material.normalMapID = crying_obsidianTextureID_n;\n    crying_obsidian_material.alpha = alphaOpaque; // Opaque\n\n    // deepslate\n    Material deepslate_material;\n    deepslate_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    deepslate_material.hasDiffuseMap = true;\n    deepslate_material.diffuseMapID = deepslateTextureID;\n    deepslate_material.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    deepslate_material.shininess = 32.0f;                // Shininess exponent\n    deepslate_material.hasSpecularMap = true;\n    deepslate_material.specularMapID = deepslateTextureID_s;\n    deepslate_material.hasNormalMap = true;\n    deepslate_material.normalMapID = deepslateTextureID_n;\n    deepslate_material.alpha = alphaOpaque; // Opaque\n\n    // mossy stone bricks\n    Material mossy_stone_bricks_material;\n    mossy_stone_bricks_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    mossy_stone_bricks_material.hasDiffuseMap = true;\n    mossy_stone_bricks_material.diffuseMapID = mossy_stone_bricksTextureID;\n    mossy_stone_bricks_material.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    mossy_stone_bricks_material.shininess = 32.0f;                // Shininess exponent\n    mossy_stone_bricks_material.hasSpecularMap = true;\n    mossy_stone_bricks_material.specularMapID = mossy_stone_bricksTextureID_s;\n    mossy_stone_bricks_material.hasNormalMap = true;\n    mossy_stone_bricks_material.normalMapID = mossy_stone_bricksTextureID_n;\n    mossy_stone_bricks_material.alpha = alphaOpaque; // Opaque\n\n    // obsidian\n    Material obsidian_material;\n    obsidian_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    obsidian_material.hasDiffuseMap = true;\n    obsidian_material.diffuseMapID = obsidianTextureID;\n    obsidian_material.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    obsidian_material.shininess = 32.0f;                // Shininess exponent\n    obsidian_material.hasSpecularMap = true;\n    obsidian_material.specularMapID = obsidianTextureID_s;\n    obsidian_material.hasNormalMap = true;\n    obsidian_material.normalMapID = obsidianTextureID_n;\n    obsidian_material.alpha = alphaOpaque; // Opaque\n\n    // portal\n    Material portal_material;\n    portal_material.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    portal_material.hasDiffuseMap = true;\n    portal_material.diffuseMapID = portalTextureID;\n    portal_material.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    portal_material.shininess = 32.0f;                // Shininess exponent\n    portal_material.hasSpecularMap = true;\n    portal_material.specularMapID = portalTextureID_s;\n    portal_material.hasNormalMap = false;\n    portal_material.normalMapID = 0;\n    portal_material.alpha = alphaTransparent5; // 50% opaque\n\n    // add to manager\n    materialManager.addOrGetMaterial(crying_obsidian_material);\n    materialManager.addOrGetMaterial(deepslate_material);\n    materialManager.addOrGetMaterial(mossy_stone_bricks_material);\n    materialManager.addOrGetMaterial(obsidian_material);\n    materialManager.addOrGetMaterial(portal_material);\n\n    // white material\n    Material whiteMaterial;\n    whiteMaterial.Kd = glm::vec3(1.0f, 1.0f, 1.0f); // White color\n    whiteMaterial.hasDiffuseMap = false;\n    whiteMaterial.diffuseMapID = 0;\n    whiteMaterial.Ks = glm::vec3(0.3f, 0.3f, 0.3f); // Specular color\n    whiteMaterial.shininess = 32.0f;                // Shininess exponent\n    whiteMaterial.hasSpecularMap = false;           // Assuming no specular map\n    whiteMaterial.specularMapID = 0;\n    whiteMaterial.hasNormalMap = false;\n    whiteMaterial.normalMapID = 0;\n    whiteMaterial.alpha = alphaTransparent5; // Transparent\n\n    materialManager.addOrGetMaterial(whiteMaterial);\n\n    std::cout << \"Materials created\" << std::endl;\n    // After loading textures\n    for (const auto &material : materialManager.materials)\n    {\n        std::cout << \"Material info \" << std::endl;\n        std::cout << \"  Material Index: \" << (&material - &materialManager.materials[0]) << std::endl;\n        std::cout << \"  Diffuse Map ID: \" << material.diffuseMapID << std::endl;\n        std::cout << \"  Normal Map ID: \" << material.normalMapID << std::endl;\n    }\n    // print size of materials\n    std::cout << \"Size of materials: \" << materialManager.materials.size() << std::endl;\n\n    // =======================\n    // Scene objects creation\n\n    // Prepare to add objects to the scene\n    GLsizei cubeIndexCount = static_cast<GLsizei>(cubeIndices.size());\n    // GLsizei sphereVertexCount = sphere.getVertexCount();\n\n    // void addCube(const std::string &name,\n    //             const glm::vec3 &position,\n    //             const glm::vec3 &scale,\n    //             const Material &material,\n    //             const glm::vec3 &rotationAxis,\n    //             float rotationAngle,\n    //             GLuint vaoID,\n    //             GLsizei indexCount,\n    //             bool isStatic);\n\n    // new materials, with specular maps, one of each\n    glm::vec3 initialPosition(25.0f, 2.0f, 3.0f);\n    glm::vec3 initialPosition2(25.0f, 2.0f, 4.0f);\n    glm::vec3 initialSize(1.0f, 1.0f, 1.0f);\n\n    // // dsiplay the new materials\n\n    // // Adding \"crying_obsidian\" cube\n    // utils_scene::addCube(\n    //     \"crying_obsidian\",              // Name\n    //     glm::vec3(28.0f, 2.0f, 2.0f),   // Position\n    //     initialSize,                    // Size\n    //     crying_obsidian_material,       // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),    // Rotation axis (Y-axis)\n    //     0.0f,                           // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                        // VAO ID\n    //     cubeIndexCount,                 // Index count\n    //     true                            // Is static\n    // );\n\n    // // Adding \"deepslate\" cube\n    // utils_scene::addCube(\n    //     \"deepslate\",              // Name\n    //     glm::vec3(28.0f, 2.0f, 3.0f), // Position\n    //     initialSize,              // Size\n    //     deepslate_material,       // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n    //     0.0f,                     // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                  // VAO ID\n    //     cubeIndexCount,           // Index count\n    //     true                      // Is static\n    // );\n\n    // // Adding \"mossy_stone_bricks\" cube\n    // utils_scene::addCube(\n    //     \"mossy_stone_bricks\",        // Name\n    //     glm::vec3(28.0f, 2.0f, 4.0f), // Position\n    //     initialSize,                 // Size\n    //     mossy_stone_bricks_material, // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n    //     0.0f,                        // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                     // VAO ID\n    //     cubeIndexCount,              // Index count\n    //     true                         // Is static\n    // );\n\n    // // Adding \"obsidian\" cube\n    // utils_scene::addCube(\n    //     \"obsidian\",                 // Name\n    //     glm::vec3(28.0f, 2.0f, 5.0f), // Position\n    //     initialSize,                // Size\n    //     obsidian_material,          // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n    //     0.0f,                       // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                    // VAO ID\n    //     cubeIndexCount,             // Index count\n    //     true                        // Is static\n    // );\n\n    // // Adding \"portal\" cube\n    // utils_scene::addTransparentCube(\n    //     \"portal\",                    // Name\n    //     glm::vec3(28.0f, 2.0f, 6.0f), // Position\n    //     glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n    //     portal_material,             // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n    //     0.0f,                        // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                     // VAO ID\n    //     cubeIndexCount,              // Index count\n    //     true                         // Is static\n    // );\n\n    // white sphere in room 2, transparentt\n    // pos 30, 2, 4\n    utils_scene::addTransparentSphere(\n        \"whiteSphere\",                // Name\n        glm::vec3(30.0f, 5.0f, 4.0f), // Position\n        1.0f,                         // Radius\n        whiteMaterial,                // Material\n        sphereVAO,                    // VAO ID\n        sphereVertexCount,             // Index count\n        true                          // Is static\n    );\n\n    // // Adding \"stone_bricks\" cube\n    // utils_scene::addCube(\n    //     \"stone_bricks\",              // Name\n    //     initialPosition,             // Position\n    //     initialSize,                 // Size\n    //     stone_bricks_material,       // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n    //     0.0f,                        // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                     // VAO ID\n    //     cubeIndexCount,              // Index count\n    //     true                         // Is static\n    // );\n\n    // // Adding \"glass\" cube\n    // utils_scene::addTransparentCube(\n    //     \"glass\",                     // Name\n    //     initialPosition2,            // Position\n    //     initialSize * 0.999f,        // Size (slightly smaller to avoid z-fighting)\n    //     glass_material,              // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n    //     0.0f,                        // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                     // VAO ID\n    //     cubeIndexCount,              // Index count\n    //     true                         // Is static\n    // );\n\n    // // Adding \"purple_stained_glass\" cube\n    // utils_scene::addTransparentCube(\n    //     \"purple_stained_glass\",        // Name\n    //     glm::vec3(25.0f, 2.0f, 5.0f),  // Position\n    //     initialSize * 0.999f,          // Size (slightly smaller to avoid z-fighting)\n    //     purple_stained_glass_material, // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n    //     0.0f,                          // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                       // VAO ID\n    //     cubeIndexCount,                // Index count\n    //     true                           // Is static\n    // );\n\n    // // Adding \"iron_block\" cube\n    // utils_scene::addCube(\n    //     \"iron_block\",                 // Name\n    //     glm::vec3(25.0f, 2.0f, 6.0f), // Position\n    //     initialSize,                  // Size\n    //     iron_block_material,          // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),  // Rotation axis (Y-axis)\n    //     0.0f,                         // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                      // VAO ID\n    //     cubeIndexCount,               // Index count\n    //     true                          // Is static\n    // );\n\n    // // Adding \"note_block\" cube\n    // utils_scene::addCube(\n    //     \"note_block\",                 // Name\n    //     glm::vec3(25.0f, 2.0f, 7.0f), // Position\n    //     initialSize,                  // Size\n    //     note_block_material,          // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),  // Rotation axis (Y-axis)\n    //     0.0f,                         // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                      // VAO ID\n    //     cubeIndexCount,               // Index count\n    //     true                          // Is static\n    // );\n\n    // // Adding \"oak_planks\" cube\n    // utils_scene::addCube(\n    //     \"oak_planks\",                 // Name\n    //     glm::vec3(25.0f, 2.0f, 8.0f), // Position\n    //     initialSize,                  // Size\n    //     oak_planks_material,          // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),  // Rotation axis (Y-axis)\n    //     0.0f,                         // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                      // VAO ID\n    //     cubeIndexCount,               // Index count\n    //     true                          // Is static\n    // );\n\n    // // Adding \"deepslate_emerald_ore\" cube\n    // utils_scene::addCube(\n    //     \"deepslate_emerald_ore\",        // Name\n    //     glm::vec3(25.0f, 2.0f, 9.0f),   // Position\n    //     initialSize,                    // Size\n    //     deepslate_emerald_ore_material, // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),    // Rotation axis (Y-axis)\n    //     0.0f,                           // Rotation angle (e.g., 0 degrees)\n    //     cubeVAO,                        // VAO ID\n    //     cubeIndexCount,                 // Index count\n    //     true                            // Is static\n    // );\n\n    // displaying materials over.\n\n    // floor\n    glm::vec3 origin(0.0f, 0.0f, 0.0f);\n    glm::vec3 floorSize(42.0f, 1.0f, 24.0f);\n    utils_scene::createCompositeCube(\n        \"floor\",             // Name\n        origin,              // Origin\n        floorSize,           // Size\n        oak_planks_material, // Material\n        cubeVAO,             // VAO ID\n        cubeIndexCount,      // Index count\n        true                 // Is static\n    );\n\n    // wall X1\n    glm::vec3 wallPosition1(0.0f, 1.0f, -1.0f);\n    glm::vec3 wallSizeX(42.0f, 3.0f, 1.0f);\n    utils_scene::createCompositeCube(\n        \"wall_X1\",      // Name\n        wallPosition1,  // Position\n        wallSizeX,      // Size\n        wallMaterial,   // Material\n        cubeVAO,        // VAO ID\n        cubeIndexCount, // Index count\n        true            // Is static\n    );\n\n    // wall X2\n    glm::vec3 wallPosition2(0.0f, 1.0f, 24.0f);\n    utils_scene::createCompositeCube(\n        \"wall_X2\",      // Name\n        wallPosition2,  // Position\n        wallSizeX,      // Size\n        wallMaterial,   // Material\n        cubeVAO,        // VAO ID\n        cubeIndexCount, // Index count\n        true            // Is static\n    );\n\n    // wall Z1\n    glm::vec3 wallPosition3(-1.0f, 1.0f, 0.0f);\n    glm::vec3 wallSizeZ1(1.0f, 3.0f, 24.0f);\n    utils_scene::createCompositeCube(\n        \"wall_Z1\",      // Name\n        wallPosition3,  // Position\n        wallSizeZ1,     // Size\n        wallMaterial,   // Material\n        cubeVAO,        // VAO ID\n        cubeIndexCount, // Index count\n        true            // Is static\n    );\n\n    // wall Z2\n    glm::vec3 wallPosition4(42.0f, 1.0f, 0.0f);\n    utils_scene::createCompositeCube(\n        \"wall_Z2\",      // Name\n        wallPosition4,  // Position\n        wallSizeZ1,     // Size\n        wallMaterial,   // Material\n        cubeVAO,        // VAO ID\n        cubeIndexCount, // Index count\n        true            // Is static\n    );\n\n    // separation wall, Z3\n    glm::vec3 wallPosition5(20.0f, 1.0f, 0.0f);\n    glm::vec3 wallSizeZ2(2.0f, 3.0f, 10.0f);\n    utils_scene::createCompositeCube(\n        \"wall_Z3\",          // Name\n        wallPosition5,      // Position\n        wallSizeZ2,         // Size\n        terracottaMaterial, // Material\n        cubeVAO,            // VAO ID\n        cubeIndexCount,     // Index count\n        true                // Is static\n    );\n\n    // separation wall, Z4\n    glm::vec3 wallPosition6(20.0f, 1.0f, 14.0f);\n    utils_scene::createCompositeCube(\n        \"wall_Z4\",          // Name\n        wallPosition6,      // Position\n        wallSizeZ2,         // Size\n        terracottaMaterial, // Material\n        cubeVAO,            // VAO ID\n        cubeIndexCount,     // Index count\n        true                // Is static\n    );\n\n    // room 2 nether portal build, we can use composite cube for this, and make 4 composite cubes\n    // first composite cube\n    glm::vec3 portalPosition1(38.0f, 1.0f, 10.0f);\n    glm::vec3 portalSize1(1.0f, 1.0f, 4.0f);\n\n    utils_scene::createCompositeCube(\n        \"portal1\",          // Name\n        portalPosition1,    // Position\n        portalSize1,        // Size\n        obsidian_material,  // Material\n        cubeVAO,            // VAO ID\n        cubeIndexCount,     // Index count\n        true                // Is static\n    );\n\n    glm::vec3 portalPosition2(38.0f, 2.0f, 10.0f);\n    glm::vec3 portalSize2(1.0f, 3.0f, 1.0f);\n\n    utils_scene::createCompositeCube(\n        \"portal2\",          // Name\n        portalPosition2,    // Position\n        portalSize2,        // Size\n        obsidian_material,  // Material\n        cubeVAO,            // VAO ID\n        cubeIndexCount,     // Index count\n        true                // Is static\n    );\n\n    glm::vec3 portalPosition3(38.0f, 2.0f, 13.0f);\n\n    utils_scene::createCompositeCube(\n        \"portal3\",          // Name\n        portalPosition3,    // Position\n        portalSize2,        // Size\n        obsidian_material,  // Material\n        cubeVAO,            // VAO ID\n        cubeIndexCount,     // Index count\n        true                // Is static\n    );\n\n    glm::vec3 portalPosition4(38.0f, 5.0f, 10.0f);\n    glm::vec3 portalSize3(1.0f, 1.0f, 4.0f);\n\n    utils_scene::createCompositeCube(\n        \"portal4\",          // Name\n        portalPosition4,    // Position\n        portalSize3,        // Size\n        obsidian_material,  // Material\n        cubeVAO,            // VAO ID\n        cubeIndexCount,     // Index count\n        true                // Is static\n    );\n\n    // now we an fill the portal with portal material\n    glm::vec3 portalPosition5(38.0f, 2.0f, 11.0f);\n    glm::vec3 portalSize4(1.0f, 3.0f, 2.0f);\n\n    // Adding \"portal\" cube\n    utils_scene::addTransparentCube(\n        \"portal\",                    // Name\n        glm::vec3(38.0f, 2.0f, 11.0f), // Position\n        glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n        portal_material,             // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addTransparentCube(\n        \"portal\",                    // Name\n        glm::vec3(38.0f, 2.0f, 12.0f), // Position\n        glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n        portal_material,             // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n    \n    utils_scene::addTransparentCube(\n        \"portal\",                    // Name\n        glm::vec3(38.0f, 3.0f, 11.0f), // Position\n        glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n        portal_material,             // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addTransparentCube(\n        \"portal\",                    // Name\n        glm::vec3(38.0f, 3.0f, 12.0f), // Position\n        glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n        portal_material,             // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addTransparentCube(\n        \"portal\",                    // Name\n        glm::vec3(38.0f, 4.0f, 11.0f), // Position\n        glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n        portal_material,             // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addTransparentCube(\n        \"portal\",                    // Name\n        glm::vec3(38.0f, 4.0f, 12.0f), // Position\n        glm::vec3(0.1f, 1.0f, 1.0f) * 0.999f, // Size\n        portal_material,             // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // actual decor objects\n    // decorcenterright (36, 2, 20)\n    glm::vec3 decorCenterRight(33.0f, 1.0f, 20.0f);\n    utils_scene::addCube(\n        \"30\",          // Name\n        decorCenterRight,  // Position\n        initialSize,                 // Size\n        crying_obsidian_material,    // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // decorecetnerriht + (1, 0, 0)\n    utils_scene::addCube(\n        \"31\",          // Name\n        decorCenterRight + glm::vec3(1.0f, 0.0f, 0.0f),  // Position\n        initialSize,                 // Size\n        deepslate_material,          // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // decorecetnerriht + (0, 1, 0) emerald ore\n    utils_scene::addCube(\n        \"32\",          // Name\n        decorCenterRight + glm::vec3(0.0f, 1.0f, 0.0f),  // Position\n        initialSize,                 // Size\n        deepslate_emerald_ore_material, // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // decorecetnerriht + (0, 0, 1) crying obsidian\n    utils_scene::addCube(\n        \"33\",          // Name\n        decorCenterRight + glm::vec3(0.0f, 0.0f, 1.0f),  // Position\n        initialSize,                 // Size\n        crying_obsidian_material,    // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // decorecetnerriht + (-1, 0, -1) obsidian\n    utils_scene::addCube(\n        \"34\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 0.0f, -1.0f),  // Position\n        initialSize,                 // Size\n        obsidian_material,           // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // decorecetnerriht + (-1, 0, 0) deepslate\n    // decorecetnerriht + (-2, 0, 0) emerald ore\n    // decorecetnerriht + (-3, 0, 1) crying obsidian\n    // decorecetnerriht + (0, 0, 1) obsidian\n    // decorecetnerriht + (-1, 0, 1) deepslate\n    // decorecetnerriht + (-1, 0, -2) emerald ore\n    // decorecetnerriht + (-1, 1, -2) crying obsidian\n    // decorecetnerriht + (-1, 0, 1) obsidian\n    // decorecetnerriht + (-1, 2, 2) deepslate\n    // decorecetnerriht + (-1, 1, 2) emerald ore\n\n    utils_scene::addCube(\n        \"35\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 0.0f, 0.0f),  // Position\n        initialSize,                 // Size\n        deepslate_material,          // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"36\",          // Name\n        decorCenterRight + glm::vec3(-2.0f, 0.0f, 0.0f),  // Position\n        initialSize,                 // Size\n        deepslate_emerald_ore_material, // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"37\",          // Name\n        decorCenterRight + glm::vec3(-3.0f, 0.0f, 1.0f),  // Position\n        initialSize,                 // Size\n        crying_obsidian_material,    // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"38\",          // Name\n        decorCenterRight + glm::vec3(0.0f, 0.0f, 1.0f),  // Position\n        initialSize,                 // Size\n        obsidian_material,           // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"39\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 0.0f, 1.0f),  // Position\n        initialSize,                 // Size\n        deepslate_material,          // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"40\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 0.0f, -2.0f),  // Position\n        initialSize,                 // Size\n        deepslate_emerald_ore_material, // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"41\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 1.0f, -2.0f),  // Position\n        initialSize,                 // Size\n        crying_obsidian_material,    // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"42\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 0.0f, 1.0f),  // Position\n        initialSize,                 // Size\n        obsidian_material,           // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"43\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 2.0f, 2.0f),  // Position\n        initialSize,                 // Size\n        deepslate_material,          // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    utils_scene::addCube(\n        \"44\",          // Name\n        decorCenterRight + glm::vec3(-1.0f, 1.0f, 2.0f),  // Position\n        initialSize,                 // Size\n        deepslate_material,          // Material\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation axis (Y-axis)\n        0.0f,                        // Rotation angle (e.g., 0 degrees)\n        cubeVAO,                     // VAO ID\n        cubeIndexCount,              // Index count\n        true                         // Is static\n    );\n\n    // Additional Blocks\n\n    utils_scene::addCube(\n        \"45\", decorCenterRight + glm::vec3(2.0f, 0.0f, 0.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"46\", decorCenterRight + glm::vec3(-2.0f, 1.0f, 0.0f), initialSize,\n        stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"47\", decorCenterRight + glm::vec3(0.0f, 1.0f, -1.0f), initialSize,\n        stoneMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"48\", decorCenterRight + glm::vec3(1.0f, 0.0f, -1.0f), initialSize,\n        wallMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"49\", decorCenterRight + glm::vec3(-2.0f, 0.0f, -1.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"50\", decorCenterRight + glm::vec3(1.0f, 1.0f, 1.0f), initialSize,\n        stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"51\", decorCenterRight + glm::vec3(-1.0f, 2.0f, -1.0f), initialSize,\n        stoneMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"52\", decorCenterRight + glm::vec3(0.0f, 2.0f, 0.0f), initialSize,\n        wallMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"53\", decorCenterRight + glm::vec3(-2.0f, 1.0f, 1.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"54\", decorCenterRight + glm::vec3(2.0f, 1.0f, -1.0f), initialSize,\n        stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"55\", decorCenterRight + glm::vec3(0.0f, 0.0f, -2.0f), initialSize,\n        stoneMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"56\", decorCenterRight + glm::vec3(-1.0f, 1.0f, -3.0f), initialSize,\n        wallMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"57\", decorCenterRight + glm::vec3(1.0f, 2.0f, -2.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"58\", decorCenterRight + glm::vec3(-2.0f, 2.0f, -1.0f), initialSize,\n        stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    utils_scene::addCube(\n        \"59\", decorCenterRight + glm::vec3(0.0f, 3.0f, 0.0f), initialSize,\n        wallMaterial, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // left decor, (planks, iron block, note block, glass, purple stained glass)\n    glm::vec3 decorCenterLeft(34.0f, 1.0f, 3.0f);\n\n    // Block 1: Glass\n    utils_scene::addTransparentCube(\n        \"60\", decorCenterLeft, initialSize * 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 2: Purple Stained Glass\n    utils_scene::addTransparentCube(\n        \"61\", decorCenterLeft + glm::vec3(1.0f, 0.0f, 0.0f), initialSize* 0.999f,\n        purple_stained_glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 3: Iron Block\n    utils_scene::addCube(\n        \"62\", decorCenterLeft + glm::vec3(0.0f, 1.0f, 0.0f), initialSize,\n        iron_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 4: Note Block\n    utils_scene::addCube(\n        \"63\", decorCenterLeft + glm::vec3(0.0f, 0.0f, 1.0f), initialSize,\n        note_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 5: Oak Planks\n    utils_scene::addCube(\n        \"64\", decorCenterLeft + glm::vec3(-1.0f, 0.0f, -1.0f), initialSize,\n        oak_planks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 6: Mossy Stone Bricks\n    utils_scene::addCube(\n        \"65\", decorCenterLeft + glm::vec3(-1.0f, 0.0f, 0.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 7: Glass\n    utils_scene::addTransparentCube(\n        \"66\", decorCenterLeft + glm::vec3(-2.0f, 0.0f, 0.0f), initialSize* 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 8: Purple Stained Glass\n    utils_scene::addTransparentCube(\n        \"67\", decorCenterLeft + glm::vec3(-3.0f, 0.0f, 1.0f), initialSize* 0.999f,\n        purple_stained_glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 9: Iron Block\n    utils_scene::addCube(\n        \"68\", decorCenterLeft + glm::vec3(0.0f, 0.0f, -1.0f), initialSize,\n        iron_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 10: Note Block\n    utils_scene::addCube(\n        \"69\", decorCenterLeft + glm::vec3(-1.0f, 0.0f, 1.0f), initialSize,\n        note_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 11: Oak Planks\n    utils_scene::addCube(\n        \"70\", decorCenterLeft + glm::vec3(-1.0f, 1.0f, -2.0f), initialSize,\n        oak_planks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 12: Mossy Stone Bricks\n    utils_scene::addCube(\n        \"71\", decorCenterLeft + glm::vec3(-1.0f, 2.0f, -2.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 13: Glass\n    utils_scene::addTransparentCube(\n        \"72\", decorCenterLeft + glm::vec3(-1.0f, 0.0f, 1.0f), initialSize* 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 14: Purple Stained Glass\n    utils_scene::addTransparentCube(\n        \"73\", decorCenterLeft + glm::vec3(-1.0f, 2.0f, 2.0f), initialSize* 0.999f,\n        purple_stained_glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 15: Iron Block\n    utils_scene::addCube(\n        \"74\", decorCenterLeft + glm::vec3(-1.0f, 1.0f, 2.0f), initialSize,\n        iron_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Additional Blocks around decorCenterLeft\n\n    // Block 16: Glass\n    utils_scene::addTransparentCube(\n        \"75\", decorCenterLeft + glm::vec3(1.0f, 1.0f, 0.0f), initialSize* 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 17: Purple Stained Glass\n    utils_scene::addTransparentCube(\n        \"76\", decorCenterLeft + glm::vec3(0.0f, 1.0f, 1.0f), initialSize* 0.999f,\n        purple_stained_glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 18: Iron Block\n    utils_scene::addCube(\n        \"77\", decorCenterLeft + glm::vec3(2.0f, 0.0f, 0.0f), initialSize,\n        iron_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 19: Note Block\n    utils_scene::addCube(\n        \"78\", decorCenterLeft + glm::vec3(0.0f, 2.0f, 0.0f), initialSize,\n        note_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 20: Oak Planks\n    utils_scene::addCube(\n        \"79\", decorCenterLeft + glm::vec3(-2.0f, 1.0f, 1.0f), initialSize,\n        oak_planks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 21: Mossy Stone Bricks\n    utils_scene::addCube(\n        \"80\", decorCenterLeft + glm::vec3(-1.0f, 1.0f, 1.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 22: Glass\n    utils_scene::addTransparentCube(\n        \"81\", decorCenterLeft + glm::vec3(0.0f, 1.0f, -1.0f), initialSize* 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 23: Purple Stained Glass\n    utils_scene::addTransparentCube(\n        \"82\", decorCenterLeft + glm::vec3(-1.0f, 2.0f, 0.0f), initialSize* 0.999f,\n        purple_stained_glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 24: Iron Block\n    utils_scene::addCube(\n        \"83\", decorCenterLeft + glm::vec3(1.0f, 0.0f, 1.0f), initialSize,\n        iron_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 25: Note Block\n    utils_scene::addCube(\n        \"84\", decorCenterLeft + glm::vec3(-2.0f, 0.0f, -1.0f), initialSize,\n        note_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 26: Oak Planks\n    utils_scene::addCube(\n        \"85\", decorCenterLeft + glm::vec3(0.0f, 0.0f, -2.0f), initialSize,\n        oak_planks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 27: Mossy Stone Bricks\n    utils_scene::addCube(\n        \"86\", decorCenterLeft + glm::vec3(-1.0f, 0.0f, 2.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 28: Glass\n    utils_scene::addTransparentCube(\n        \"87\", decorCenterLeft + glm::vec3(1.0f, 2.0f, -1.0f), initialSize* 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 29: Purple Stained Glass\n    utils_scene::addTransparentCube(\n        \"88\", decorCenterLeft + glm::vec3(2.0f, 1.0f, 1.0f), initialSize* 0.999f,\n        purple_stained_glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 30: Iron Block\n    utils_scene::addCube(\n        \"89\", decorCenterLeft + glm::vec3(0.0f, 2.0f, -2.0f), initialSize,\n        iron_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 31: Note Block\n    utils_scene::addCube(\n        \"90\", decorCenterLeft + glm::vec3(-2.0f, 2.0f, 0.0f), initialSize,\n        note_block_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 32: Oak Planks\n    utils_scene::addCube(\n        \"91\", decorCenterLeft + glm::vec3(1.0f, 1.0f, -2.0f), initialSize,\n        oak_planks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 33: Mossy Stone Bricks\n    utils_scene::addCube(\n        \"92\", decorCenterLeft + glm::vec3(0.0f, 2.0f, 1.0f), initialSize,\n        mossy_stone_bricks_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // Block 34: Glass\n    utils_scene::addTransparentCube(\n        \"93\", decorCenterLeft + glm::vec3(-2.0f, 1.0f, -2.0f), initialSize* 0.999f,\n        glass_material, glm::vec3(0.0f, 1.0f, 0.0f), 0.0f,\n        cubeVAO, cubeIndexCount, true);\n\n    // =======================\n\n    // decor objects room 2\n\n    // transparent cube in room 2\n    // utils_scene::addTransparentCube(\n    //     \"transparent_cube\",           // Name\n    //     transparentCubePosition,      // Position\n    //     transparentCubeSize,          // Size\n    //     transparent_iron_block_material,          // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),  // Rotation axis (Y-axis)\n    //     0.0f,                         // Rotation angle\n    //     cubeVAO,                      // VAO ID\n    //     cubeIndexCount,               // Index count\n    //     true                          // Is static\n    // );\n\n    // second transparent cube in room 2\n    // glm::vec3 transparentCubePosition2(32.0f, 2.0f, 12.0f);\n    // utils_scene::addTransparentCube(\n    //     \"transparent_cube2\",            // Name\n    //     transparentCubePosition2,       // Position\n    //     transparentCubeSize,            // Size\n    //     purple_stained_glass_material, // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),    // Rotation axis (Y-axis)\n    //     0.0f,                           // Rotation angle\n    //     cubeVAO,                        // VAO ID\n    //     cubeIndexCount,                 // Index count\n    //     true                            // Is static\n    // );\n\n    // third transparent cube in room 2\n    // glm::vec3 transparentCubePosition(32.0f, 2.0f, 10.0f);\n    // glm::vec3 transparentCubePosition3(33.0f, 1.501f, 11.5f);\n    // glm::vec3 transparentCubeSize(10.0f, 2.0f, 10.0f);\n    // utils_scene::addTransparentCube(\n    //     \"transparent_cube3\",            // Name\n    //     transparentCubePosition3,       // Position\n    //     transparentCubeSize,            // Size\n    //     glass_material, // Material\n    //     glm::vec3(0.0f, 1.0f, 0.0f),    // Rotation axis (Y-axis)\n    //     0.0f,                           // Rotation angle\n    //     cubeVAO,                        // VAO ID\n    //     cubeIndexCount,                 // Index count\n    //     true                            // Is static\n    // );\n\n    // glm::vec3 transparentCubePosition4(27.0f, 1.001f, 7.0f);\n    // glm::vec3 transparentCubeSize(10.0f, 2.0f, 10.0f);\n    // utils_scene::createTransparentCompositeCube(\n    //     \"glassthing\",          // Name\n    //     transparentCubePosition4,      // Position\n    //     transparentCubeSize,         // Size\n    //     glass_material, // Material\n    //     cubeVAO,            // VAO ID\n    //     cubeIndexCount,     // Index count\n    //     true                // Is static\n    // );\n\n    // \n\n    // load a soccer ball as sophisticated object\n    // utils_scene::addSphere(\n    //     \"soccer_ball\",                // Name\n    //     glm::vec3(27.0f, 3.0f, 10.0f), // Position\n    //     0.3f,                         // Radius\n    //     soccerMaterial,               // Material\n    //     sphereVAO,                    // VAO ID\n    //     sphereVertexCount,            // Vertex count\n    //     true                          // Is static\n    // );\n\n    // load skybox sphere\n    utils_scene::addSkySphere(\n        \"sky\",                       // Name\n        glm::vec3(0.0f, 0.0f, 0.0f), // Position\n        99.0f,                       // Radius\n        skyMaterial,                 // Material\n        sphereVAO,                   // VAO ID\n        sphereVertexCount,           // Vertex count\n        false                        // Is static\n    );\n\n    // planet balls\n    // positions:\n    // sun: 9.5f, 3.0f, 11.5f (size1 = 1.3f) size2 = 1.2f size3 = 1.1f\n    // emrcury: 8.5f, 3.0f, 11.5f\n    // venus: 7.5f, 3.0f, 11.5f\n    // earth: 5.0f, 3.0f, 12.0f (size1 = 0.3f) size2 = 0.34f\n    // mars: 3.5f, 3.0f, 11.5f\n    // jupiter: 3.0f, 3.0f, 11.5f\n    // saturn: -0.5f, 3.0f, 11.5f\n    // uranus: -2.5f, 3.0f, 11.5f\n    // neptune: -4.5f, 3.0f, 11.5f\n\n\n    // sun1\n    utils_scene::addTransparentSphere(\n        \"sun\",                      // Name\n        glm::vec3(9.5f, 34.0f, 11.5f), // Position\n        3.3f,                       // Radius\n        sunMaterial,                // Material\n        sphereVAO,                  // VAO ID\n        sphereVertexCount,          // Vertex count\n        true                        // Is static\n    );\n\n    // mercury\n    utils_scene::addSphere(\n        \"mercury\",                  // Name\n        glm::vec3(9.5f, 3.0f, 3.5f), // Position\n        0.3f,                      // Radius\n        mercuryMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // venus\n    utils_scene::addSphere(\n        \"venus\",                  // Name\n        glm::vec3(9.5f, 3.0f, 4.5f), // Position\n        0.34f,                      // Radius\n        venusMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // venus atmosphere\n    utils_scene::addTransparentSphere(\n        \"venus_atmosphere\",                  // Name\n        glm::vec3(10.5f, 3.0f, 4.5f), // Position\n        0.36f,                      // Radius\n        venusAtmosphereMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // earth\n    utils_scene::addSphere(\n        \"earth\",                  // Name\n        glm::vec3(9.5f, 3.0f, 5.5f), // Position\n        0.3f,                      // Radius\n        earthMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // earth atmosphere\n    utils_scene::addTransparentSphere(\n        \"earth_atmosphere\",                  // Name\n        glm::vec3(10.5f, 3.0f, 5.5f), // Position\n        0.34f,                      // Radius\n        earthAtmosphereMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // mars\n    utils_scene::addSphere(\n        \"mars\",                  // Name\n        glm::vec3(9.5f, 3.0f, 6.5f), // Position\n        0.3f,                      // Radius\n        marsMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // jupiter\n    utils_scene::addSphere(\n        \"jupiter\",                  // Name\n        glm::vec3(9.5f, 3.0f, 7.5f), // Position\n        0.8f,                      // Radius\n        jupiterMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // saturn\n    utils_scene::addSphere(\n        \"saturn\",                  // Name\n        glm::vec3(9.5f, 3.0f, 9.5f), // Position\n        0.7f,                      // Radius\n        saturnMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // saturn ring\n    utils_scene::addTransparentSphere(\n        \"saturn_ring\",                  // Name\n        glm::vec3(13.0f, 3.0f, 9.5f), // Position\n        1.4f,                      // Radius\n        saturnRingMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // uranus\n    utils_scene::addSphere(\n        \"uranus\",                  // Name\n        glm::vec3(9.5f, 3.0f, 11.5f), // Position\n        0.45f,                      // Radius\n        uranusMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // neptune\n    utils_scene::addSphere(\n        \"neptune\",                  // Name\n        glm::vec3(9.5f, 3.0f, 13.5f), // Position\n        0.42f,                      // Radius\n        neptuneMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // display cases we will add a glass cube with a planet inside, for each planet\n\n    // mercury\n    utils_scene::addTransparentCube(\n        \"mercury_case\",                 // Name\n        glm::vec3(4.0f, 1.501f, 3.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // venus\n    utils_scene::addTransparentCube(\n        \"venus_case\",                 // Name\n        glm::vec3(8.0f, 1.501f, 3.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // earth\n    utils_scene::addTransparentCube(\n        \"earth_case\",                 // Name\n        glm::vec3(12.0f, 1.501f, 3.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // mars\n    utils_scene::addTransparentCube(\n        \"mars_case\",                 // Name\n        glm::vec3(16.0f, 1.501f, 3.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // right side:\n    // jupiter\n    utils_scene::addTransparentCube(\n        \"jupiter_case\",                 // Name\n        glm::vec3(16.0f, 1.501f, 20.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // saturn\n    utils_scene::addTransparentCube(\n        \"saturn_case\",                 // Name\n        glm::vec3(12.0f, 1.501f, 20.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // uranus\n    utils_scene::addTransparentCube(\n        \"uranus_case\",                 // Name\n        glm::vec3(8.0f, 1.501f, 20.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // neptune\n    utils_scene::addTransparentCube(\n        \"neptune_case\",                 // Name\n        glm::vec3(4.0f, 1.501f, 20.0f),   // Position\n        glm::vec3(2.0f, 2.0f, 2.0f),   // Size\n        glass_material,                 // Material\n        glm::vec3(0.0f, 1.0f, 0.0f),   // Rotation axis (Y-axis)\n        0.0f,                          // Rotation angle\n        cubeVAO,                       // VAO ID\n        cubeIndexCount,                // Index count\n        true                           // Is static\n    );\n\n    // =======================\n    // now we can load the planets that go in each case\n\n    // mercury\n    utils_scene::addSphere(\n        \"mercury_display\",         // Name\n        glm::vec3(4.0f, 1.5f, 3.0f), // Position\n        0.6f,                      // Radius\n        mercuryMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // venus\n    utils_scene::addSphere(\n        \"venus_display\",         // Name\n        glm::vec3(8.0f, 1.5f, 3.0f), // Position\n        0.6f,                      // Radius\n        venusMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // venus atmosphere\n    utils_scene::addTransparentSphere(\n        \"venus_atmosphere_display\",         // Name\n        glm::vec3(8.0f, 1.5f, 3.0f), // Position\n        0.62f,                      // Radius\n        venusAtmosphereMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // earth\n    utils_scene::addSphere(\n        \"earth_display\",         // Name\n        glm::vec3(12.0f, 1.5f, 3.0f), // Position\n        0.6f,                      // Radius\n        earthMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // earth atmosphere\n    utils_scene::addTransparentSphere(\n        \"earth_atmosphere_display\",         // Name\n        glm::vec3(12.0f, 1.5f, 3.0f), // Position\n        0.62f,                      // Radius\n        earthAtmosphereMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // mars\n    utils_scene::addSphere(\n        \"mars_display\",         // Name\n        glm::vec3(16.0f, 1.5f, 3.0f), // Position\n        0.6f,                      // Radius\n        marsMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // otehr side\n    // jupiter\n    utils_scene::addSphere(\n        \"jupiter_display\",         // Name\n        glm::vec3(16.0f, 1.5f, 20.0f), // Position\n        0.6f,                      // Radius\n        jupiterMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // saturn\n    utils_scene::addSphere(\n        \"saturn_display\",         // Name\n        glm::vec3(12.0f, 1.5f, 20.0f), // Position\n        0.6f,                      // Radius\n        saturnMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // saturn ring\n    utils_scene::addTransparentSphere(\n        \"saturn_ring_display\",         // Name\n        glm::vec3(12.0f, 1.5f, 20.0f), // Position\n        1.1f,                      // Radius\n        saturnRingMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // uranus\n    utils_scene::addSphere(\n        \"uranus_display\",         // Name\n        glm::vec3(8.0f, 1.5f, 20.0f), // Position\n        0.6f,                      // Radius\n        uranusMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // neptune\n    utils_scene::addSphere(\n        \"neptune_display\",         // Name\n        glm::vec3(4.0f, 1.5f, 20.0f), // Position\n        0.6f,                      // Radius\n        neptuneMaterial,           // Material\n        sphereVAO,                 // VAO ID\n        sphereVertexCount,         // Vertex count\n        true                       // Is static\n    );\n\n    // // Load the Heater .obj model\n    // utils_object::ModelData heaterModelData;\n    // std::string modelPath = applicationPath.dirPath() + \"assets/models/HeaterOBJ/Heater.obj\";\n    // if (!utils_object::loadOBJ(modelPath, applicationPath.dirPath() + \"assets/models/HeaterOBJ/\", heaterModelData))\n    // {\n    //     std::cerr << \"Failed to load model heater\" << std::endl;\n    // }\n    // else\n    // {\n    //     std::cout << \"Heater Model Loaded: \"\n    //               << heaterModelData.vertices.size() / 3 << \" vertices, \"\n    //               << heaterModelData.indices.size() << \" indices.\" << std::endl;\n    // }\n\n    // // Set up OpenGL buffers for the model\n    // setupModelBuffers(heaterModelData);\n\n    // // Compute Bounding Box for the Model\n    // AABB heaterModelBoundingBox = computeAABB(heaterModelData.vertices);\n\n    // // Apply scale\n    // glm::vec3 heaterModelScale(0.6f, 0.6f, 0.6f);\n    // heaterModelBoundingBox.min *= heaterModelScale;\n    // heaterModelBoundingBox.max *= heaterModelScale;\n\n    // // Apply translation (position)\n    // glm::vec3 heaterModelPosition(0.6f, 1.1f, 6.0f);\n    // heaterModelBoundingBox.min += heaterModelPosition;\n    // heaterModelBoundingBox.max += heaterModelPosition;\n\n    // // Add the heater model with the material\n    // utils_scene::addModel(\n    //     \"heater\",                                             // Name\n    //     heaterModelPosition,                                  // Position\n    //     heaterModelScale,                                     // Scale\n    //     heaterMaterial,                                       // Material\n    //     heaterModelData.vao,                                  // VAO ID\n    //     static_cast<GLsizei>(heaterModelData.indices.size()), // Index Count\n    //     heaterModelBoundingBox,                               // Bounding Box\n    //     glm::vec3(0.0f, 1.0f, 0.0f),                          // Rotation Axis (Y-axis)\n    //     0.0f,                                                 // Rotation Angle\n    //     true                                                  // Is static\n    // );\n\n    // Load the Rocking Chair model\n    utils_object::ModelData rockingChairModelData;\n    std::string rockingChairPath = applicationPath.dirPath() + \"assets/models/Rocking_Chair/kid_rocking_chair.obj\";\n    std::string rockingChairBasePath = applicationPath.dirPath() + \"assets/models/Rocking_Chair/Textures/\";\n\n    if (!utils_object::loadOBJ(rockingChairPath, rockingChairBasePath, rockingChairModelData))\n    {\n        std::cerr << \"Failed to load Rocking Chair model.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Rocking Chair Model Loaded: \"\n                  << rockingChairModelData.vertices.size() / 3 << \" vertices, \"\n                  << rockingChairModelData.indices.size() << \" indices.\" << std::endl;\n    }\n\n    // Load Rocking Chair Base Color Texture\n    std::string baseColorPath = rockingChairBasePath + \"/BaseColor.png\";\n    GLuint baseColorTextureID = utils_object::LoadTextureFromFile(baseColorPath.c_str());\n    if (baseColorTextureID == 0)\n    {\n        std::cerr << \"Failed to load BaseColor.png for Rocking Chair.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"BaseColor.png for Rocking Chair loaded successfully: ID \" << baseColorTextureID << std::endl;\n    }\n\n    // Load Rocking Chair Normal Map\n    std::string normalMapPath = rockingChairBasePath + \"/Normal.png\";\n    GLuint normalMapTextureID = utils_object::LoadTextureFromFile(normalMapPath.c_str());\n    if (normalMapTextureID == 0)\n    {\n        std::cerr << \"Failed to load Normal.png for Rocking Chair.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Normal.png for Rocking Chair loaded successfully: ID \" << normalMapTextureID << std::endl;\n    }\n\n    // Set up OpenGL buffers for the Rocking Chair model\n    setupModelBuffers(rockingChairModelData);\n\n    // Compute Bounding Box for the Rocking Chair model\n    AABB rockingChairModelBoundingBox = computeAABB(rockingChairModelData.vertices);\n\n    // Apply scale\n    glm::vec3 rockingChairModelScale(0.8f, 0.8f, 0.8f);\n    rockingChairModelBoundingBox.min *= rockingChairModelScale;\n    rockingChairModelBoundingBox.max *= rockingChairModelScale;\n\n    // Apply translation (position)\n    glm::vec3 rockingChairModelPosition(10.0f, 0.55f, 22.5f);\n    rockingChairModelBoundingBox.min += rockingChairModelPosition;\n    rockingChairModelBoundingBox.max += rockingChairModelPosition;\n\n    // Add Rocking Chair Model to Scene Objects\n    utils_scene::addModel(\n        \"rocking_chair\",                                            // Name\n        rockingChairModelPosition,                                  // Position\n        rockingChairModelScale,                                     // Scale\n        rockingChairMaterial,                                       // Material\n        rockingChairModelData.vao,                                  // VAO ID\n        static_cast<GLsizei>(rockingChairModelData.indices.size()), // Index Count\n        rockingChairModelBoundingBox,                               // Bounding Box\n        glm::vec3(0.0f, 0.0f, 0.0f),                                // Rotation Axis (no rotation)\n        0.0f,                                                       // Rotation Angle\n        false                                                       // Is static\n    );\n\n    // add the torus model\n    utils_object::ModelData torusModelData;\n\n    std::string torusPath = applicationPath.dirPath() + \"assets/models/Torus/Torus.obj\";\n    std::string torusBasePath = applicationPath.dirPath() + \"assets/models/Torus/\";\n\n    if (!utils_object::loadOBJ(torusPath, torusBasePath, torusModelData))\n    {\n        std::cerr << \"Failed to load Torus model.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Torus Model Loaded: \"\n                  << torusModelData.vertices.size() / 3 << \" vertices, \"\n                  << torusModelData.indices.size() << \" indices.\" << std::endl;\n    }\n\n    setupModelBuffers(torusModelData);\n\n    AABB torusBoundingBox = computeAABB(torusModelData.vertices);\n    // replace bounding box with new scale\n\n    glm::vec3 torusPosition(29.0f, 5.0f, 21.0f);\n    glm::vec3 torusScale(0.05f, 0.05f, 0.05f);\n\n    torusBoundingBox.min *= torusScale;\n    torusBoundingBox.max *= torusScale;\n\n    torusBoundingBox.min += torusPosition;\n    torusBoundingBox.max += torusPosition;\n\n    utils_scene::addModel(\n        \"torus\",                                             // Name\n        torusPosition,                                       // Position\n        torusScale,                                          // Scale\n        torusMaterial,                                       // Material\n        torusModelData.vao,                                  // VAO ID\n        static_cast<GLsizei>(torusModelData.indices.size()), // Index Count\n        torusBoundingBox,                                    // Bounding Box\n        glm::vec3(0.0f, 1.0f, 0.0f),                         // Rotation Axis (Y-axis)\n        0.0f,                                                // Rotation Angle\n        true                                                 // Is static\n    );\n\n    // add a std::vector of simple point lights from namespace utils_light\n    std::vector<utils_light::SimplePointLight> simpleLights;\n\n    // Add a simple point light to the scene\n    // int newLightID = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(5.0f, 2.5f, 15.0f), // position\n    //     glm::vec3(1.0f, 1.0f, 1.0f),  // color\n    //     1.0f                          // intensity\n    // );\n\n    // // // Add a simple point light to the scene 2\n    // int newLightID2 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(5.0f, 1.0f, 19.0f), // position\n    //     glm::vec3(0.3f, 0.4f, 1.0f),  // color\n    //     1.0f                          // intensity\n    // );\n\n    // // light pos 32 2 11\n    // int newLightID3 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(32.0f, 2.0f, 19.0f), // position\n    //     glm::vec3(1.0f, 0.0f, 1.0f),   // color\n    //     1.0f                           // intensity\n    // );\n\n    // // light pos 32 2 13\n    // int newLightID4 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(37.0f, 2.0f, 13.0f), // position\n    //     glm::vec3(1.0f, 1.0f, 1.0f),   // color\n    //     1.0f                           // intensity\n    // );\n\n    // // pos 10 1 10\n    // int newLightID5 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(10.0f, 1.0f, 10.0f), // position\n    //     glm::vec3(1.0f, 0.0f, 1.0f),   // color\n    //     1.0f                           // intensity\n    // );\n\n    // one light for each planet case, a little bit above the planet\n    // mercury\n    int newLightID1 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(4.0f, 3.0f, 3.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),  // color\n        0.2f                          // intensity\n    );\n\n    // venus\n    int newLightID2 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(8.0f, 3.0f, 3.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),  // color\n        0.2f                        // intensity\n    );\n\n    // earth\n    int newLightID3 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(12.0f, 3.0f, 3.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),  // color\n        0.2f                          // intensity\n    );\n\n    // mars\n    int newLightID4 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(16.0f, 3.0f, 3.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),  // color\n        0.2f                          // intensity\n    );\n\n    // jupiter\n    int newLightID5 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(16.0f, 3.0f, 20.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        0.2f                           // intensity\n    );\n\n    // saturn\n    int newLightID6 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(12.0f, 3.0f, 20.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        0.2f                           // intensity\n    );\n\n    // uranus\n    int newLightID7 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(8.0f, 3.0f, 20.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        0.2f                           // intensity\n    );\n\n    // neptune\n    int newLightID8 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(4.0f, 3.0f, 20.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        0.2f                           // intensity\n    );\n\n    int newLightID9 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(37.0f, 3.0f, 11.5f), // position\n        glm::vec3(0.4f, 0.24f, 0.7f),   // color\n        1.3f                           // intensity\n    );\n\n    // add more lights to room 2\n    // light pos 30 4 4\n    // light pos 30 4 20\n    // light pos 23 4 11.5\n\n    // glm::vec3(30.0f, 2.0f, 4.0f), // Position\n\n    int newLightID10 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(30.0f, 4.0f, 4.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        1.0f                           // intensity\n    );\n\n    int newLightID11 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(30.0f, 4.0f, 20.0f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        0.9f                           // intensity\n    );\n\n    int newLightID12 = utils_light::addLight(\n        simpleLights,\n        glm::vec3(23.0f, 4.0f, 11.5f), // position\n        glm::vec3(1.0f, 1.0f, 1.0f),   // color\n        1.0f                           // intensity\n    );\n\n\n    // int newLightID10 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(39.0f, 3.0f, 11.5f), // position\n    //     glm::vec3(0.4f, 0.24f, 0.7f),   // color\n    //     1.0f                           // intensity\n    // );\n\n    // // light pos 32 2 13\n    // int newLightID10 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(28.0f, 2.0f, 13.0f), // position\n    //     glm::vec3(1.0f, 1.0f, 1.0f),   // color\n    //     1.0f                           // intensity\n    // );\n\n    // // pos 26 1 3\n    // int newLightID11 = utils_light::addLight(\n    //     simpleLights,\n    //     glm::vec3(28.0f, 4.0f, 3.0f), // position\n    //     glm::vec3(1.0f, 1.0f, 1.0f),   // color\n    //     1.0f                           // intensity\n    // );\n\n    // update a light position during the loop\n    // utils_light::updateLightPosition(simpleLights, newLightID, glm::vec3(5.0f, 2.0f, 1.0f));\n\n    // change colro and intensity of the light\n    // utils_light::updateLightColor(simpleLights, newLightID, glm::vec3(0.2f, 1.0f, 0.2f));\n    // utils_light::updateLightIntensity(simpleLights, newLightID, 3.5f);\n\n    // remove the light from the scene\n    // bool lightRemoved = utils_light::removeLight(simpleLights, newLightID);\n    // if (lightRemoved) {\n    //     std::cout << \"Light with ID \" << newLightID << \" removed from the scene.\" << std::endl;\n    // } else {\n    //     std::cerr << \"Failed to remove light with ID \" << newLightID << \" from the scene.\" << std::endl;\n    // }\n\n    // =======================\n    // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n\n    utils_scene::initializePlanetSpiralParameters();\n\n    // Main loop variables\n    bool done = false;\n    std::cout << \"Entering main loop\" << std::endl;\n\n    while (!done)\n    {\n        // Calculate delta time\n        float currentFrame = windowManager.getTime();\n        deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n        float adjustedSpeed = cameraSpeed * deltaTime;\n\n        // Update FPS counter\n        frameCount++;\n        fpsTimer += deltaTime;\n        if (fpsTimer >= 1.0f)\n        {\n            fps = frameCount;\n            frameCount = 0;\n            fpsTimer -= 1.0f;\n        }\n\n        if (!SDL_GetVideoSurface()) {\n            std::cerr << \"Error: SDL Video Surface not initialized!\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n\n        // Update window title with camera position every frame\n        std::string newTitle = \"Boules - FPS: \" + std::to_string(fps) + \" - Position: (\" + std::to_string(cameraPos.x) + \", \" + std::to_string(cameraPos.z) + \")\";\n        // std::string newTitle = std::to_string(cameraPos.x) + \", \" + std::to_string(cameraPos.z);\n        // std::string newTitle = \"FPS: \" + std::to_string(fps);\n        SDL_WM_SetCaption(newTitle.c_str(), NULL);\n\n        // Update light intensity dynamically within the loop\n        // glm::vec3 lightIntensity = glm::vec3(\n        //     (sin(currentFrame) + 1.0f) / 2.0f,       // Red oscillates between 0 and 1\n        //     (cos(currentFrame) + 1.0f) / 2.0f,       // Green oscillates between 0 and 1\n        //     (sin(currentFrame * 0.5f) + 1.0f) / 2.0f // Blue oscillates more slowly between 0 and 1\n        // );\n\n        // white light\n        // glm::vec3 lightIntensity = glm::vec3(1.0f);\n\n        // green light\n        // glm::vec3 lightIntensity = glm::vec3(0.0f, 1.0f, 0.0f);\n\n        // even handler\n        utils_game_loop::eventHandler(windowManager, done, isRockingChairPaused, rockingChairStartTime, rockingChairPausedTime, yaw, pitch, cameraFront, currentFrame);\n\n        // Movement direction vectors projected onto the XZ-plane\n        glm::vec3 frontDirection = glm::normalize(glm::vec3(cameraFront.x, 0.0f, cameraFront.z));\n        glm::vec3 rightDirection = glm::normalize(glm::cross(frontDirection, cameraUp));\n\n        // Keyboard input for movement\n        Uint8 *state = SDL_GetKeyState(NULL);\n\n        glm::vec3 proposedCameraPos = cameraPos; // Temporary camera position for collision testing\n\n        // Calculate proposed camera direction based on input\n        glm::vec3 movementDirection = glm::vec3(0.0f);\n\n        // Forward and Backward\n        if (state[SDLK_w])\n        {\n            movementDirection += frontDirection;\n        }\n        if (state[SDLK_s])\n        {\n            movementDirection -= frontDirection;\n        }\n\n        // Left and Right\n        if (state[SDLK_a])\n        {\n            movementDirection -= rightDirection;\n        }\n        if (state[SDLK_d])\n        {\n            movementDirection += rightDirection;\n        }\n\n        // Normalize to prevent diagonal speed boost\n        if (glm::length(movementDirection) > 0.0f)\n        {\n            movementDirection = glm::normalize(movementDirection);\n        }\n\n        // Apply movement speed\n        proposedCameraPos += movementDirection * adjustedSpeed;\n\n        // Check collision against all objects\n        bool collisionDetected = false;\n        for (const auto &object : utils_scene::sceneObjects)\n        {\n            if (checkCollision(proposedCameraPos, cameraRadius, cameraHeight, object.boundingBox))\n            {\n                collisionDetected = true;\n                break; // Stop further checking if a collision is found\n            }\n        }\n        // Check collision against all objects with transparency\n        for (const auto &object : utils_scene::sceneObjectsTransparent)\n        {\n            if (checkCollision(proposedCameraPos, cameraRadius, cameraHeight, object.boundingBox))\n            {\n                collisionDetected = true;\n                break; // Stop further checking if a collision is found\n            }\n        }\n\n        // Update camera position only if no collision is detected\n        if (!collisionDetected)\n        {\n            cameraPos = proposedCameraPos;\n        }\n\n        // Keep the camera at the initial y position\n        cameraPos.y = cameraPosY;\n\n        // Define MVP matrices\n        glm::mat4 ProjMatrix = glm::perspective(\n            glm::radians(70.0f),                 // Field of View\n            window_width / (float)window_height, // Aspect ratio\n            0.1f,                                // Near clipping plane\n            100.0f                               // Far clipping plane\n        );\n\n        glm::mat4 ViewMatrix = glm::lookAt(\n            cameraPos,               // Camera position\n            cameraPos + cameraFront, // Look at target\n            cameraUp                 // Up vector\n        );\n\n\n\n        // Spiral movement around spiralCenter\n\n        // Light properties\n        // float spiralRadius = 2.0f; // Radius of the spiral\n        // float spiralSpeed = 0.5f;  // Speed of the spiral movement\n        // float fixedHeight = 1.5f;  // Height variation of the light\n        // glm::vec3 lightPosWorld;\n        // lightPosWorld.x = spiralCenter.x + spiralRadius * cos(currentFrame * spiralSpeed);\n        // lightPosWorld.y = fixedHeight + spiralCenter.y;\n        // lightPosWorld.z = spiralCenter.z + spiralRadius * sin(currentFrame * spiralSpeed);\n\n        // fixed light position\n        glm::vec3 lightPosWorld;\n\n        // new method for light color, set to its material Kd\n        glm::vec3 lightIntensity = lightMaterial.Kd * 1.0f;\n\n        // simple light ID 5, dynamic light\n        // glm::vec3 lightPosWorld5;\n        // lightPosWorld5.x = 10.0f + 1.0f * cos(currentFrame);\n        // lightPosWorld5.y = 1.0f;\n        // lightPosWorld5.z = 10.0f + 1.0f * sin(currentFrame);\n\n        // simpleLights[4].position = lightPosWorld5;\n\n        // also change its color\n        // simpleLights[4].color = glm::vec3(\n        //     (sin(currentFrame) + 1.0f) / 2.0f,       // Red oscillates between 0 and 1\n        //     (cos(currentFrame) + 1.0f) / 2.0f,       // Green oscillates between 0 and 1\n        //     (sin(currentFrame * 0.5f) + 1.0f) / 2.0f // Blue oscillates more slowly between 0 and 1\n        // );\n\n        // is light paused\n        // default sun position glm::vec3(9.5f, 34.0f, 11.5f)\n        // if light is paused, move the sunposition down 100 units\n        // else, bakc to the default original position\n        if (isLightPaused)\n        {\n            // setobject position to 100 units below the scene\n            utils_scene::setObjectPosition(\"sun\", glm::vec3(9.5f, -100.0f, 11.5f));\n        }\n        else\n        {\n            // setobject position to the original position\n            utils_scene::setObjectPosition(\"sun\", glm::vec3(9.5f, 34.0f, 11.5f));\n        }\n\n        // set the main light position to the sun position\n        // get the position of the sun using the transparent lsit of objects, name is \"sun\"\n        // Fetch sun's position dynamically\n        glm::vec3 sunPosition = utils_scene::getTransparentObjectPosition(\"sun\");\n        lightPosWorld = sunPosition;\n\n        glm::vec3 spiralCenter = utils_scene::getTransparentObjectPosition(\"sun\");\n\n        utils_scene::updatePlanetPositions(currentFrame, spiralCenter);\n\n\n        // update the display lights\n        // but we cant just send simpleLights, we need to send the first 8 lights of it\n        // Create a vector for the first 8 shared_ptr lights\n        std::vector<std::shared_ptr<utils_light::SimplePointLight>> truncatedLights;\n        for (size_t i = 0; i < simpleLights.size(); ++i) {\n            truncatedLights.push_back(std::make_shared<utils_light::SimplePointLight>(simpleLights[i]));\n        }\n\n        // Call the function\n        utils_light::updateDynamicLights(truncatedLights, currentFrame);\n\n        // update the light inside the nether portal, light ID = 9\n        // we can here vary the light intensity, to change the shader vs effect\n        simpleLights[8].intensity = 1.0f + 0.9f * cos(currentFrame);\n        // simpleLights[9].intensity = 1.0f + 0.5f * cos(currentFrame);\n\n        // update the display planets (they should rotate)\n        utils_scene::updateDisplayPlanetPositions(currentFrame);\n\n\n        // move this light newLightID10 around the object with name \"whiteSphere\"\n\n        // get the position of the object\n        glm::vec3 whiteSpherePosition = utils_scene::getTransparentObjectPosition(\"whiteSphere\");\n\n        // move the light around the object\n        simpleLights[9].position.x = whiteSpherePosition.x + 1.6f * cos(currentFrame);\n        simpleLights[9].position.y = whiteSpherePosition.y + 1.6f * sin(currentFrame);\n        simpleLights[9].position.z = whiteSpherePosition.z + 1.6f * sin(currentFrame);\n\n        // also change the color\n        simpleLights[10].color = glm::vec3(\n            (sin(currentFrame) + 1.0f) / 2.0f,       // Red oscillates between 0 and 1\n            (cos(currentFrame) + 1.0f) / 2.0f,       // Green oscillates between 0 and 1\n            (sin(currentFrame * 2.5f) + 1.0f) / 2.0f // Blue oscillates faster\n        );\n\n        // mvoe the simpleLights[11] as well, on the object torus\n        glm::vec3 torusPosition = utils_scene::getObjectPosition(\"torus\");\n        simpleLights[10].position.x = torusPosition.x + 1.6f * cos(currentFrame);\n        simpleLights[10].position.y = torusPosition.y + 1.6f * sin(currentFrame);\n        simpleLights[10].position.z = torusPosition.z + 1.6f * sin(currentFrame);\n\n        // keep the light id 11 to 1.0f above the camera\n        simpleLights[11].position = cameraPos + glm::vec3(0.0f, 1.0f, 0.0f);\n\n        // light position on the camera\n        // glm::vec3 lightPosWorld = cameraPos + glm::vec3(0.0f, 1.0f, 0.0f); // Slightly elevate the light position above the camera\n\n        // Transform light position to view space\n        glm::vec3 lightPosViewSpace = glm::vec3(ViewMatrix * glm::vec4(lightPosWorld, 1.0f));\n\n        // Recalculate light space matrix\n        glm::mat4 lightProjection = glm::ortho(-20.0f, 20.0f, -20.0f, 20.0f, 1.0f, 50.0f);\n        glm::mat4 lightView = glm::lookAt(lightPosWorld, glm::vec3(0.0f), glm::vec3(0.0f, 1.0f, 0.0f));\n        glm::mat4 lightSpaceMatrix = lightProjection * lightView;\n\n        // Create six view matrices for the cube map faces\n        std::vector<glm::mat4> shadowTransforms;\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(1.0, 0.0, 0.0), glm::vec3(0.0, -1.0, 0.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(-1.0, 0.0, 0.0), glm::vec3(0.0, -1.0, 0.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, 1.0, 0.0), glm::vec3(0.0, 0.0, 1.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, -1.0, 0.0), glm::vec3(0.0, 0.0, -1.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, 0.0, 1.0), glm::vec3(0.0, -1.0, 0.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, 0.0, -1.0), glm::vec3(0.0, -1.0, 0.0)));\n\n        // First Pass: Render scene from light's perspective to generate shadow map\n        glViewport(0, 0, 4096, 4096); // Match shadow map resolution\n        glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);\n        glClear(GL_DEPTH_BUFFER_BIT);\n\n        // Use the depth shader program\n        depthShader.use();\n        glUniform1f(glGetUniformLocation(depthShader.getGLId(), \"farPlane\"), farPlane);\n        glUniform3fv(glGetUniformLocation(depthShader.getGLId(), \"lightPos\"), 1, glm::value_ptr(lightPosWorld));\n\n        // Rocking chair parameters\n        double frequency = 0.30; // Rocking frequency (cycles per second)\n        double length = 0.08;    // Maximum angle in degrees\n        double radius = 0.3;     // Radius of the rocking base\n\n        // dynamic loop\n        utils_game_loop::dynamic_loop(deltaTime, lastFrame, currentFrame, windowManager, cameraPos, cameraFront, cameraUp, cameraSpeed, done, isRockingChairPaused, rockingChairStartTime, rockingChairPausedTime, yaw, pitch, radius, frequency, radius, length, cameraHeight);\n\n        if (!isLightPaused)\n        {\n\n            // First Pass: Render scene to depth cube map\n            for (unsigned int i = 0; i < 6; ++i)\n            {\n                // Bind the framebuffer and attach the current cube map face\n                glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);\n                glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, depthCubeMap, 0);\n                glDrawBuffer(GL_NONE);\n                glReadBuffer(GL_NONE);\n\n                // Set viewport and clear depth buffer\n                glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);\n                glClear(GL_DEPTH_BUFFER_BIT);\n\n                // Use the depth shader program\n                depthShader.use();\n                glUniform1f(glGetUniformLocation(depthShader.getGLId(), \"farPlane\"), farPlane);\n                glUniform3fv(glGetUniformLocation(depthShader.getGLId(), \"lightPos\"), 1, glm::value_ptr(lightPosWorld));\n\n                // Set the shadow matrix for the current face\n                glUniformMatrix4fv(glGetUniformLocation(depthShader.getGLId(), \"shadowMatrix\"), 1, GL_FALSE, glm::value_ptr(shadowTransforms[i]));\n\n                // Render scene objects\n                for (const auto &object : utils_scene::sceneObjects)\n                {\n                    glm::mat4 modelMatrix = glm::mat4(1.0f);\n                    modelMatrix = glm::translate(modelMatrix, object.position);\n                    if (object.rotationAngle != 0.0f)\n                    {\n                        modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n                    }\n                    modelMatrix = glm::scale(modelMatrix, object.scale);\n\n                    // Set model matrix for depth shader\n                    glUniformMatrix4fv(glGetUniformLocation(depthShader.getGLId(), \"model\"), 1, GL_FALSE, glm::value_ptr(modelMatrix));\n\n                    glBindVertexArray(object.vaoID);\n                    if (object.type == utils_scene::ObjectType::Cube)\n                    {\n                        glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                    }\n                    else if (object.type == utils_scene::ObjectType::Sphere)\n                    {\n                        glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n                    }\n                    else if (object.type == utils_scene::ObjectType::Model)\n                    {\n                        glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                    }\n                    glBindVertexArray(0);\n                }\n\n                // Optional: Unbind the framebuffer after each face\n                glBindFramebuffer(GL_FRAMEBUFFER, 0);\n            }\n\n        } // end of if (!isLightPaused)\n        else\n        {\n            // set intensity to 0\n            lightIntensity = glm::vec3(0.0f);\n            // next loop will set back to Kd of the material, unless light is still paused\n        }\n\n        // Second Pass: Render the scene normally with point light\n        glViewport(0, 0, window_width, window_height);\n        glBindFramebuffer(GL_FRAMEBUFFER, 0); // back to default\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        // Set the shader program to use, room1 for x udner 20.5 and room2 for x over 20.5\n        utils_loader::Shader *currentRoom = &room1;\n        bool inRoom2 = cameraPos.x >= 20.5f;\n        if (inRoom2)\n        {\n            currentRoom = &room2;\n        }\n\n        currentRoom->use();\n\n        // Retrieve uniform locations specific to the active shader\n        GLint uModelMatrixLocation = currentRoom->getUniformLocation(\"uModelMatrix\");\n        GLint uMVPMatrixLocation = currentRoom->getUniformLocation(\"uMVPMatrix\");\n        GLint uMVMatrixLocation = currentRoom->getUniformLocation(\"uMVMatrix\");\n        GLint uNormalMatrixLocation = currentRoom->getUniformLocation(\"uNormalMatrix\");\n        GLint uTextureLocation = currentRoom->getUniformLocation(\"uTexture\");\n        GLint uUseTextureLocation = currentRoom->getUniformLocation(\"uUseTexture\");\n        GLint uKdLocation = currentRoom->getUniformLocation(\"uKd\");\n        GLint uKsLocation = currentRoom->getUniformLocation(\"uKs\");\n        GLint uShininessLocation = currentRoom->getUniformLocation(\"uShininess\");\n        GLint uLightPos_vsLocation = currentRoom->getUniformLocation(\"uLightPos_vs\");\n        GLint uLightIntensityLocation = currentRoom->getUniformLocation(\"uLightIntensity\");\n\n        // Retrieve 'uAlpha' only if in room2 (deprecated, we add transparency to room 1 as well)\n        // GLint uAlphaLocation = -1;\n        // if (inRoom2) {\n        //     uAlphaLocation = currentRoom->getUniformLocation(\"uAlpha\");\n        //     if (uAlphaLocation == -1) {\n        //         std::cerr << \"Failed to get 'uAlpha' location in room2 shader\" << std::endl;\n        //     }\n        // }\n\n        // Retrieve 'uAlpha' regardless of room\n        GLint uAlphaLocation = currentRoom->getUniformLocation(\"uAlpha\");\n\n        // Retrieve additional uniforms for Shader 2\n        GLint uNormalMapLocation = currentRoom->getUniformLocation(\"uNormalMap\");\n        GLint uUseNormalMapLocation = currentRoom->getUniformLocation(\"uUseNormalMap\");\n        GLint uSpecularMapLocation = currentRoom->getUniformLocation(\"uSpecularMap\");\n        GLint uUseSpecularMapLocation = currentRoom->getUniformLocation(\"uUseSpecularMap\");\n\n        // Determine the number of additional lights, capped by MAX_ADDITIONAL_LIGHTS\n        int numLights = static_cast<int>(simpleLights.size());\n        if (numLights > MAX_ADDITIONAL_LIGHTS)\n        {\n            numLights = MAX_ADDITIONAL_LIGHTS;\n        }\n\n        // Set the number of additional lights in the shader\n        GLint numLightsLoc = glGetUniformLocation(currentRoom->getGLId(), \"uNumAdditionalLights\");\n        glUniform1i(numLightsLoc, numLights);\n\n        // Convert additional light positions to view space\n        std::vector<glm::vec3> additionalLightPosViewSpace;\n        additionalLightPosViewSpace.reserve(numLights);\n        for (int i = 0; i < numLights; ++i)\n        {\n            glm::vec4 posView = ViewMatrix * glm::vec4(simpleLights[i].position, 1.0f);\n            additionalLightPosViewSpace.emplace_back(glm::vec3(posView));\n        }\n\n        // Set additional light positions and colors once per frame\n        for (int i = 0; i < numLights; ++i)\n        {\n            std::string idx = std::to_string(i);\n\n            // Position\n            GLint posLoc = glGetUniformLocation(\n                currentRoom->getGLId(),\n                (\"uAdditionalLightPos[\" + idx + \"]\").c_str());\n            glUniform3fv(posLoc, 1, glm::value_ptr(additionalLightPosViewSpace[i]));\n\n            // Color\n            GLint colorLoc = glGetUniformLocation(\n                currentRoom->getGLId(),\n                (\"uAdditionalLightColor[\" + idx + \"]\").c_str());\n            glUniform3fv(colorLoc, 1, glm::value_ptr(simpleLights[i].color));\n\n            // Initialize intensity to zero; will be set per object\n            GLint intenLoc = glGetUniformLocation(\n                currentRoom->getGLId(),\n                (\"uAdditionalLightIntensity[\" + idx + \"]\").c_str());\n            glUniform1f(intenLoc, 0.0f);\n        }\n\n        // Set main light properties once per frame\n        glUniform3fv(uLightPos_vsLocation, 1, glm::value_ptr(lightPosViewSpace));\n        glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(lightIntensity));\n\n        // Set the updated light space matrix\n        glUniformMatrix4fv(glGetUniformLocation(currentRoom->getGLId(), \"lightSpaceMatrix\"), 1, GL_FALSE, glm::value_ptr(lightSpaceMatrix));\n\n        // Bind the depth cube map to texture unit 1\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubeMap);\n        glUniform1i(glGetUniformLocation(currentRoom->getGLId(), \"depthMap\"), 1);\n\n        // Set light and camera positions in world space\n        glUniform3fv(glGetUniformLocation(currentRoom->getGLId(), \"lightPosWorld\"), 1, glm::value_ptr(lightPosWorld));\n        glUniform3fv(glGetUniformLocation(currentRoom->getGLId(), \"cameraPosWorld\"), 1, glm::value_ptr(cameraPos));\n\n        // Set far plane\n        glUniform1f(glGetUniformLocation(currentRoom->getGLId(), \"farPlane\"), farPlane);\n\n        // **Sort Transparent Objects Back-to-Front**\n        if (inRoom2 && !utils_scene::sceneObjectsTransparent.empty())\n        {\n            std::sort(utils_scene::sceneObjectsTransparent.begin(), utils_scene::sceneObjectsTransparent.end(),\n                    [&](const utils_scene::SceneObject &a, const utils_scene::SceneObject &b)\n                    {\n                        float distanceA = glm::length(cameraPos - a.position);\n                        float distanceB = glm::length(cameraPos - b.position);\n                        return distanceA > distanceB;\n                    });\n        }\n\n        glDisable(GL_CULL_FACE);\n\n        auto deltaObj = 0.0f;\n        auto deltaLight = 0.0f;\n        bool sameRoom = false;\n\n        GLint uTimeLocation = currentRoom->getUniformLocation(\"uTime\");\n        if (uTimeLocation != -1) {\n            glUniform1f(uTimeLocation, currentFrame);\n        }\n\n        // Render all scene objects (opaque)\n        for (const auto &object : utils_scene::sceneObjects)\n        {\n            // Setup model matrix\n            glm::mat4 modelMatrix = glm::mat4(1.0f);\n            modelMatrix = glm::translate(modelMatrix, object.position);\n            if (object.rotationAngle != 0.0f)\n            {\n                modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n            }\n            modelMatrix = glm::scale(modelMatrix, object.scale);\n\n            // Calculate matrices\n            glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n            glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n            glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n            // Set uniforms for shaders\n            glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix));\n            glUniformMatrix4fv(uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n            glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n            glUniformMatrix3fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n            // Determine if the object is in the same room as the main light\n            float deltaObj   = 20.5f - object.position.x;\n            float deltaLight = 20.5f - lightPosWorld.x;\n            bool sameRoom    = (deltaObj * deltaLight) > 0; // true if object & light are on the same side\n\n            if (sameRoom) {\n                // Main light affects this object\n                glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(lightIntensity));\n            } else {\n                // Main light does not affect this object\n                glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(glm::vec3(0.0f)));\n            }\n\n            // **Additional Lights Uniforms**\n            for (int i = 0; i < numLights; ++i)\n            {\n                float deltaObjForAddLight   = 20.5f - object.position.x;\n                float deltaAdditionalLight  = 20.5f - simpleLights[i].position.x;\n                bool sameRoomForAddLight    = (deltaObjForAddLight * deltaAdditionalLight) > 0;\n\n                std::string idx = std::to_string(i);\n                GLint intenLoc  = glGetUniformLocation(currentRoom->getGLId(), (\"uAdditionalLightIntensity[\" + idx + \"]\").c_str());\n                // also position\n                GLint posLoc    = glGetUniformLocation(currentRoom->getGLId(), (\"uAdditionalLightPos[\" + idx + \"]\").c_str());\n\n                if (sameRoomForAddLight)\n                {\n                    // Enable this additional light for the object\n                    glUniform1f(intenLoc, simpleLights[i].intensity);\n                }\n                else\n                {\n                    // Disable this additional light for the object\n                    glUniform1f(intenLoc, 0.0f);\n                }\n            }\n\n            // Retrieve the material from the manager\n            const Material &mat = materialManager.getMaterial(object.materialIndex);\n\n            // 1) Diffuse color\n            if (uKdLocation != -1)\n            {\n                glUniform3fv(uKdLocation, 1, glm::value_ptr(mat.Kd));\n            }\n\n            // 2) Specular color\n            if (uKsLocation != -1)\n            {\n                glUniform3fv(uKsLocation, 1, glm::value_ptr(mat.Ks));\n            }\n\n            // 3) Shininess\n            if (uShininessLocation != -1)\n            {\n                glUniform1f(uShininessLocation, mat.shininess);\n            }\n\n            // 4) Alpha\n            if (uAlphaLocation != -1)\n            {\n                glUniform1f(uAlphaLocation, mat.alpha);\n            }\n\n            // Bind textures if applicable\n            if (mat.hasDiffuseMap && mat.diffuseMapID != 0 && uUseTextureLocation != -1)\n            {\n                glActiveTexture(GL_TEXTURE0);\n                glBindTexture(GL_TEXTURE_2D, mat.diffuseMapID);\n                glUniform1i(uTextureLocation, 0);\n                glUniform1f(uUseTextureLocation, 1.0f);\n            }\n            else\n            {\n                if (uUseTextureLocation != -1)\n                {\n                    glUniform1f(uUseTextureLocation, 0.0f);\n                }\n            }\n\n            // Bind normal map if applicable\n            if (mat.hasNormalMap && mat.normalMapID != 0 && uUseNormalMapLocation != -1)\n            {\n                glActiveTexture(GL_TEXTURE2); // Use texture unit 2 for normal maps\n                glBindTexture(GL_TEXTURE_2D, mat.normalMapID);\n                glUniform1i(uNormalMapLocation, 2);\n                glUniform1f(uUseNormalMapLocation, 1.0f);\n            }\n            else\n            {\n                if (uUseNormalMapLocation != -1)\n                {\n                    glUniform1f(uUseNormalMapLocation, 0.0f);\n                }\n            }\n\n            // Bind specular map if applicable\n            if (mat.hasSpecularMap && mat.specularMapID != 0 && uUseSpecularMapLocation != -1)\n            {\n                glActiveTexture(GL_TEXTURE3); // Use texture unit 3 for specular maps\n                glBindTexture(GL_TEXTURE_2D, mat.specularMapID);\n                glUniform1i(uSpecularMapLocation, 3);\n                glUniform1f(uUseSpecularMapLocation, 1.0f);\n            }\n            else\n            {\n                if (uUseSpecularMapLocation != -1)\n                {\n                    glUniform1f(uUseSpecularMapLocation, 0.0f);\n                }\n            }\n\n            // Bind VAO and draw the object\n            glBindVertexArray(object.vaoID);\n            if (object.type == utils_scene::ObjectType::Cube)\n            {\n                glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n            }\n            else if (object.type == utils_scene::ObjectType::Sphere)\n            {\n                glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n            }\n            else if (object.type == utils_scene::ObjectType::Model)\n            {\n                glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n            }\n            glBindVertexArray(0);\n        }\n\n        // =======================\n        // Render Skybox Objects\n        skyboxShader.use();\n\n        for (const auto &object : utils_scene::sceneObjectsSkybox)\n        {\n            // print object name\n            // std::cout << \"Object Name: \" << object.name << std::endl;\n            // Transformation Matrices\n            glm::mat4 modelMatrix = glm::mat4(1.0f);\n            modelMatrix = glm::translate(modelMatrix, object.position);\n            if (object.rotationAngle != 0.0f)\n            {\n                modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n            }\n            modelMatrix = glm::scale(modelMatrix, object.scale);\n\n            glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n            glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n            glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n            // Set Skybox Shader Uniforms\n            glUniformMatrix4fv(sky_uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n            glUniformMatrix4fv(sky_uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n            glUniformMatrix3fv(sky_uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n            // Retrieve the material for the object\n            const Material &mat = materialManager.getMaterial(object.materialIndex);\n\n            // 1) Diffuse Color\n            if (sky_uKdLocation != -1)\n            {\n                glUniform3fv(sky_uKdLocation, 1, glm::value_ptr(mat.Kd));\n            }\n\n            // 2) Specular Color\n            if (sky_uKsLocation != -1)\n            {\n                glUniform3fv(sky_uKsLocation, 1, glm::value_ptr(mat.Ks));\n            }\n\n            // 3) Shininess\n            if (sky_uShininessLocation != -1)\n            {\n                glUniform1f(sky_uShininessLocation, mat.shininess);\n            }\n\n            // 4) Alpha (Transparency)\n            GLint sky_uAlphaLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uAlpha\");\n            if (sky_uAlphaLocation != -1)\n            {\n                glUniform1f(sky_uAlphaLocation, mat.alpha);\n            }\n\n            // 5) Diffuse Map\n            if (mat.hasDiffuseMap && mat.diffuseMapID != 0)\n            {\n                glActiveTexture(GL_TEXTURE0);\n                glBindTexture(GL_TEXTURE_2D, mat.diffuseMapID);\n                if (sky_uTextureLocation != -1)\n                {\n                    glUniform1i(sky_uTextureLocation, 0);\n                }\n                if (sky_uUseTextureLocation != -1)\n                {\n                    glUniform1f(sky_uUseTextureLocation, 1.0f);\n                }\n            }\n            else\n            {\n                if (sky_uUseTextureLocation != -1)\n                {\n                    glUniform1f(sky_uUseTextureLocation, 0.0f);\n                }\n            }\n\n            // 6) Normal Map\n            GLint sky_uNormalMapLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uNormalMap\");\n            GLint sky_uUseNormalMapLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uUseNormalMap\");\n            if (mat.hasNormalMap && mat.normalMapID != 0)\n            {\n                glActiveTexture(GL_TEXTURE2);\n                glBindTexture(GL_TEXTURE_2D, mat.normalMapID);\n                if (sky_uNormalMapLocation != -1)\n                {\n                    glUniform1i(sky_uNormalMapLocation, 2);\n                }\n                if (sky_uUseNormalMapLocation != -1)\n                {\n                    glUniform1f(sky_uUseNormalMapLocation, 1.0f);\n                }\n            }\n            else\n            {\n                if (sky_uUseNormalMapLocation != -1)\n                {\n                    glUniform1f(sky_uUseNormalMapLocation, 0.0f);\n                }\n            }\n\n            // 7) Specular Map\n            GLint sky_uSpecularMapLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uSpecularMap\");\n            GLint sky_uUseSpecularMapLocation = glGetUniformLocation(skyboxShader.getGLId(), \"uUseSpecularMap\");\n            if (mat.hasSpecularMap && mat.specularMapID != 0)\n            {\n                glActiveTexture(GL_TEXTURE3);\n                glBindTexture(GL_TEXTURE_2D, mat.specularMapID);\n                if (sky_uSpecularMapLocation != -1)\n                {\n                    glUniform1i(sky_uSpecularMapLocation, 3);\n                }\n                if (sky_uUseSpecularMapLocation != -1)\n                {\n                    glUniform1f(sky_uUseSpecularMapLocation, 1.0f);\n                }\n            }\n            else\n            {\n                if (sky_uUseSpecularMapLocation != -1)\n                {\n                    glUniform1f(sky_uUseSpecularMapLocation, 0.0f);\n                }\n            }\n\n            // Draw Skybox Object\n            glBindVertexArray(object.vaoID);\n            if (object.type == utils_scene::ObjectType::Cube)\n            {\n                glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n            }\n            else if (object.type == utils_scene::ObjectType::Sphere)\n            {\n                glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n            }\n            else if (object.type == utils_scene::ObjectType::Model)\n            {\n                glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n            }\n\n            // Unbind Textures\n            glBindTexture(GL_TEXTURE_2D, 0);\n        }\n\n        glBindVertexArray(0);\n        glUseProgram(0);\n\n        // =======================\n\n        // back to previosu shader\n\n        lightShader.use();\n    \n        if (lightIntensity != glm::vec3(0.0f))\n        {\n            // material is lightMaterial\n            const Material &mat = lightMaterial;\n\n            // Create model matrix with translation and scaling\n            glm::mat4 modelMatrix = glm::mat4(1.0f);\n\n            // Translate the sphere to the light source position\n            modelMatrix = glm::translate(modelMatrix, lightPosWorld);\n\n            // Scale the sphere to make it smaller\n            modelMatrix = glm::scale(modelMatrix, glm::vec3(0.1f)); // Scale down to 10%\n\n            // Calculate matrices\n            glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n            glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n            glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n            // Pass matrices to the shader\n            glUniformMatrix4fv(light_uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n            glUniformMatrix4fv(light_uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n            glUniformMatrix3fv(light_uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n            // Retrieve the material for the object\n\n            // 1) Diffuse Color\n            if (light_uKdLocation != -1)\n            {\n                glUniform3fv(light_uKdLocation, 1, glm::value_ptr(mat.Kd));\n            }\n\n            // Draw the smaller sphere\n            glBindVertexArray(sphereVAO);\n            glDrawArrays(GL_TRIANGLES, 0, sphereVertexCountGL);\n            glBindVertexArray(0);\n        }\n\n        glUseProgram(0);\n\n        lightShader.use();\n\n        // Set material properties once for all point lights\n        glUniform3fv(light_uKdLocation, 1, glm::value_ptr(simpleLightMaterial.Kd));\n        glUniform3fv(light_uKsLocation, 1, glm::value_ptr(simpleLightMaterial.Ks));\n        glUniform1f(light_uShininessLocation, simpleLightMaterial.shininess);\n        glUniform1f(glGetUniformLocation(lightShader.getGLId(), \"uAlpha\"), simpleLightMaterial.alpha);\n\n        for (const auto &light : simpleLights)\n        {\n            if (light.intensity <= 0.0f)\n                continue;\n\n            // one more condition, we don't need to render the light if the light position is above 20.5\n\n            // if (light.position.x > 20.5f)\n            // {\n            //     continue;\n            // }\n\n            // skip specific light IDs\n            if (light.id == 8 || light.id == 11)\n            {\n                continue;\n            }\n\n            glm::mat4 modelMatrix = glm::mat4(1.0f);\n            modelMatrix = glm::translate(modelMatrix, light.position);\n            modelMatrix = glm::scale(modelMatrix, glm::vec3(0.1f));\n\n            glm::mat4 mvMatrix     = ViewMatrix * modelMatrix;\n            glm::mat4 mvpMatrix    = ProjMatrix * mvMatrix;\n            glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n            // Pass transformation matrices\n            glUniformMatrix4fv(light_uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n            glUniformMatrix4fv(light_uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n            glUniformMatrix3fv(light_uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n            // Optional: per-light color\n            glUniform3fv(light_uKdLocation, 1, glm::value_ptr(light.color));\n\n            // Render light sphere\n            glBindVertexArray(sphereVAO);\n            glDrawArrays(GL_TRIANGLES, 0, sphereVertexCountGL);\n            glBindVertexArray(0);\n        }\n\n        glUseProgram(0);\n\n        currentRoom->use();\n        // check which room we are in\n        // std::cout << \"Camera Position: \" << cameraPos.x << std::endl;\n\n        // Check if in Room 2 (assuming cameraPos.x >= 20.5f indicates Room 2)\n        if (cameraPos.x >= 20.5f)\n        {\n            // =======================\n            // **Multi-Pass Rendering for Room 2**\n            // =======================\n\n            // Enable additive blending for accumulating color channels\n            glEnable(GL_BLEND);\n            glBlendFunc(GL_ONE, GL_ONE); // Additive blending\n\n            // Disable depth writing to allow blending\n            glDepthMask(GL_FALSE);\n\n            // Iterate over each color channel\n            for (int channel = 0; channel < 3; ++channel)\n            {\n                // Set the colorMask uniform\n                glUniform3fv(room2_uColorMaskLocation, 1, glm::value_ptr(colorMasks[channel]));\n\n                // Iterate over each transparent object\n                for (const auto &object : utils_scene::sceneObjectsTransparent)\n                {\n                    // Check material index validity\n                    if (object.materialIndex < 0 || object.materialIndex >= static_cast<int>(materialManager.materials.size()))\n                    {\n                        std::cerr << \"Invalid material index for object: \" << object.name << std::endl;\n                        continue; // Skip rendering this object\n                    }\n\n                    // **Main Light** (object vs. main light) for transparency\n                    float deltaObjectTrans = 20.5f - object.position.x;\n                    float deltaMainLight   = 20.5f - lightPosWorld.x;\n                    bool sameRoomTrans     = (deltaObjectTrans * deltaMainLight) > 0;\n\n                    if (sameRoomTrans)\n                    {\n                        glUniform3fv(uLightPos_vsLocation, 1, glm::value_ptr(lightPosViewSpace));\n                        glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(lightIntensity));\n                    }\n                    else\n                    {\n                        glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(glm::vec3(0.0f)));\n                    }\n\n                    // **Additional Lights** (object vs. each additional light)\n                    int numLights = static_cast<int>(simpleLights.size());\n                    for (int i = 0; i < numLights; ++i)\n                    {\n                        float deltaObjForAddLight   = 20.5f - object.position.x;\n                        float deltaAdditionalLight  = 20.5f - simpleLights[i].position.x;\n                        bool sameRoomForAddLight    = (deltaObjForAddLight * deltaAdditionalLight) > 0;\n\n                        std::string idx  = std::to_string(i);\n                        GLint intenLoc   = glGetUniformLocation(currentRoom->getGLId(), (\"uAdditionalLightIntensity[\" + idx + \"]\").c_str());\n\n                        if (sameRoomForAddLight)\n                        {\n                            // Position\n                            GLint posLoc = glGetUniformLocation(currentRoom->getGLId(),\n                                            (\"uAdditionalLightPos[\" + idx + \"]\").c_str());\n                            glUniform3fv(posLoc, 1, glm::value_ptr(additionalLightPosViewSpace[i]));\n\n                            // Color\n                            GLint colorLoc = glGetUniformLocation(currentRoom->getGLId(),\n                                            (\"uAdditionalLightColor[\" + idx + \"]\").c_str());\n                            glUniform3fv(colorLoc, 1, glm::value_ptr(simpleLights[i].color));\n\n                            // Intensity\n                            glUniform1f(intenLoc, simpleLights[i].intensity);\n                        }\n                        else\n                        {\n                            glUniform1f(intenLoc, 0.0f);\n                        }\n                    }\n\n                    // Retrieve the material\n                    const Material &mat = materialManager.getMaterial(object.materialIndex);\n\n                    // **Alpha Check for Special Opaque-like Rendering (alpha == 0.9)**\n                    if (abs(mat.alpha - 0.9f) < 0.001f) {\n                        // Treat object as opaque\n                        glEnable(GL_CULL_FACE); // Enable face culling to prevent inside rendering\n                        glDepthMask(GL_TRUE);   // Enable depth writing for proper occlusion\n                        glDisable(GL_BLEND);    // Disable blending for solid rendering\n                    } else {\n                        // Standard transparency handling\n                        glDisable(GL_CULL_FACE); // Disable face culling for transparency\n                        glDepthMask(GL_FALSE);   // Disable depth writing for blending\n                        glEnable(GL_BLEND);      // Ensure blending is enabled\n                    }\n\n                    // Set alpha uniform\n                    if (uAlphaLocation != -1) {\n                        glUniform1f(uAlphaLocation, mat.alpha);\n                    }\n\n                    // Calculate model matrix\n                    glm::mat4 modelMatrix = glm::mat4(1.0f);\n                    modelMatrix = glm::translate(modelMatrix, object.position);\n                    if (object.rotationAngle != 0.0f)\n                    {\n                        modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n                    }\n                    modelMatrix = glm::scale(modelMatrix, object.scale);\n\n                    glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n                    glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n                    glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n                    // Set transform uniforms\n                    glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix));\n                    glUniformMatrix4fv(uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n                    glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n                    glUniformMatrix3fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n                    // 1) Diffuse color\n                    if (uKdLocation != -1)\n                    {\n                        glUniform3fv(uKdLocation, 1, glm::value_ptr(mat.Kd));\n                    }\n\n                    // 2) Specular color\n                    if (uKsLocation != -1)\n                    {\n                        glUniform3fv(uKsLocation, 1, glm::value_ptr(mat.Ks));\n                    }\n\n                    // 3) Shininess\n                    if (uShininessLocation != -1)\n                    {\n                        glUniform1f(uShininessLocation, mat.shininess);\n                    }\n\n                    // 4) Diffuse texture\n                    if (mat.hasDiffuseMap && mat.diffuseMapID != 0)\n                    {\n                        glActiveTexture(GL_TEXTURE0);\n                        glBindTexture(GL_TEXTURE_2D, mat.diffuseMapID);\n                        if (uTextureLocation != -1)\n                        {\n                            glUniform1i(uTextureLocation, 0);\n                        }\n                        if (uUseTextureLocation != -1)\n                        {\n                            glUniform1f(uUseTextureLocation, 1.0f);\n                        }\n                    }\n                    else\n                    {\n                        if (uUseTextureLocation != -1)\n                        {\n                            glUniform1f(uUseTextureLocation, 0.0f);\n                        }\n                    }\n\n                    // 5) Normal map\n                    GLint uNormalMapLoc = glGetUniformLocation(currentRoom->getGLId(), \"uNormalMap\");\n                    GLint uUseNormalMapLoc = glGetUniformLocation(currentRoom->getGLId(), \"uUseNormalMap\");\n                    if (mat.hasNormalMap && mat.normalMapID != 0)\n                    {\n                        glActiveTexture(GL_TEXTURE2);\n                        glBindTexture(GL_TEXTURE_2D, mat.normalMapID);\n                        if (uNormalMapLoc != -1)\n                        {\n                            glUniform1i(uNormalMapLoc, 2);\n                        }\n                        if (uUseNormalMapLoc != -1)\n                        {\n                            glUniform1f(uUseNormalMapLoc, 1.0f);\n                        }\n                    }\n                    else\n                    {\n                        if (uUseNormalMapLoc != -1)\n                        {\n                            glUniform1f(uUseNormalMapLoc, 0.0f);\n                        }\n                    }\n\n                    // 6) Specular map\n                    GLint uSpecularMapLocation = glGetUniformLocation(currentRoom->getGLId(), \"uSpecularMap\");\n                    GLint uUseSpecularMapLocation = glGetUniformLocation(currentRoom->getGLId(), \"uUseSpecularMap\");\n                    if (mat.hasSpecularMap && mat.specularMapID != 0)\n                    {\n                        glActiveTexture(GL_TEXTURE3); // Use texture unit 3 for specular maps\n                        glBindTexture(GL_TEXTURE_2D, mat.specularMapID);\n                        if (uSpecularMapLocation != -1)\n                        {\n                            glUniform1i(uSpecularMapLocation, 3); // Set sampler to texture unit 3\n                        }\n                        if (uUseSpecularMapLocation != -1)\n                        {\n                            glUniform1f(uUseSpecularMapLocation, 1.0f); // Enable specular map usage\n                        }\n                    }\n                    else\n                    {\n                        if (uUseSpecularMapLocation != -1)\n                        {\n                            glUniform1f(uUseSpecularMapLocation, 0.0f); // Disable specular map usage\n                        }\n                    }\n\n                    // Draw transparent object\n                    glBindVertexArray(object.vaoID);\n                    if (object.type == utils_scene::ObjectType::Cube)\n                    {\n                        glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                    }\n                    else if (object.type == utils_scene::ObjectType::Sphere)\n                    {\n                        glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n                    }\n                    else if (object.type == utils_scene::ObjectType::Model)\n                    {\n                        glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                    }\n                    glBindVertexArray(0);\n\n                    // (Optional) unbind textures afterwards\n                    glActiveTexture(GL_TEXTURE0);\n                    glBindTexture(GL_TEXTURE_2D, 0);\n                    glActiveTexture(GL_TEXTURE2);\n                    glBindTexture(GL_TEXTURE_2D, 0);\n                    glActiveTexture(GL_TEXTURE3);\n                    glBindTexture(GL_TEXTURE_2D, 0);\n                }\n            }\n\n            // Restore default blending\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n            // Restore depth writing\n            glDepthMask(GL_TRUE);\n\n            // Reset colorMask to default (no shift)\n            glm::vec3 defaultColorMask = glm::vec3(1.0f, 1.0f, 1.0f);\n            glUniform3fv(room2_uColorMaskLocation, 1, glm::value_ptr(defaultColorMask));\n        }\n        else // ELSE (cameraPos.x < 20.5f, not in Room 2)\n        {\n            // =======================\n            // **Normal Rendering (No RGB Shift)**\n            // =======================\n\n            // Render all transparent objects normally\n            if (!utils_scene::sceneObjectsTransparent.empty())\n            {\n                // Enable standard alpha blending\n                glEnable(GL_BLEND);\n                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n                // Disable depth writing for transparency\n                glDepthMask(GL_FALSE);\n\n                for (const auto &object : utils_scene::sceneObjectsTransparent)\n                {\n                    // Check material index validity\n                    if (object.materialIndex < 0 || object.materialIndex >= static_cast<int>(materialManager.materials.size()))\n                    {\n                        std::cerr << \"Invalid material index for object: \" << object.name << std::endl;\n                        continue; // Skip rendering this object\n                    }\n\n                    // **Main Light** (object vs. main light) for transparency\n                    float deltaObjectTrans = 20.5f - object.position.x;\n                    float deltaMainLight   = 20.5f - lightPosWorld.x;\n                    bool sameRoomTrans     = (deltaObjectTrans * deltaMainLight) > 0;\n\n                    if (sameRoomTrans)\n                    {\n                        glUniform3fv(uLightPos_vsLocation, 1, glm::value_ptr(lightPosViewSpace));\n                        glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(lightIntensity));\n                    }\n                    else\n                    {\n                        glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(glm::vec3(0.0f)));\n                    }\n\n                    // **Additional Lights** (object vs. each additional light)\n                    int numLights = static_cast<int>(simpleLights.size());\n                    for (int i = 0; i < numLights; ++i)\n                    {\n                        float deltaObjForAddLight   = 20.5f - object.position.x;\n                        float deltaAdditionalLight  = 20.5f - simpleLights[i].position.x;\n                        bool sameRoomForAddLight    = (deltaObjForAddLight * deltaAdditionalLight) > 0;\n\n                        std::string idx  = std::to_string(i);\n                        GLint intenLoc   = glGetUniformLocation(currentRoom->getGLId(), (\"uAdditionalLightIntensity[\" + idx + \"]\").c_str());\n\n                        if (sameRoomForAddLight)\n                        {\n                            // Position\n                            GLint posLoc = glGetUniformLocation(currentRoom->getGLId(),\n                                            (\"uAdditionalLightPos[\" + idx + \"]\").c_str());\n                            glUniform3fv(posLoc, 1, glm::value_ptr(additionalLightPosViewSpace[i]));\n\n                            // Color\n                            GLint colorLoc = glGetUniformLocation(currentRoom->getGLId(),\n                                            (\"uAdditionalLightColor[\" + idx + \"]\").c_str());\n                            glUniform3fv(colorLoc, 1, glm::value_ptr(simpleLights[i].color));\n\n                            // Intensity\n                            glUniform1f(intenLoc, simpleLights[i].intensity);\n                        }\n                        else\n                        {\n                            glUniform1f(intenLoc, 0.0f);\n                        }\n                    }\n\n                    // Retrieve the material\n                    const Material &mat = materialManager.getMaterial(object.materialIndex);\n\n                    // **Alpha Check for Special Opaque-like Rendering (alpha == 0.9)**\n                    if (abs(mat.alpha - 0.9f) < 0.001f) {\n                        // Treat object as opaque\n                        glEnable(GL_CULL_FACE); // Enable face culling to prevent inside rendering\n                        glDepthMask(GL_TRUE);   // Enable depth writing for proper occlusion\n                        glDisable(GL_BLEND);    // Disable blending for solid rendering\n                    } else {\n                        // Standard transparency handling\n                        glDisable(GL_CULL_FACE); // Disable face culling for transparency\n                        glDepthMask(GL_FALSE);   // Disable depth writing for blending\n                        glEnable(GL_BLEND);      // Ensure blending is enabled\n                        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Standard alpha blending\n                    }\n\n                    // Set alpha uniform\n                    if (uAlphaLocation != -1) {\n                        glUniform1f(uAlphaLocation, mat.alpha);\n                    }\n\n                    // Calculate model matrix\n                    glm::mat4 modelMatrix = glm::mat4(1.0f);\n                    modelMatrix = glm::translate(modelMatrix, object.position);\n                    if (object.rotationAngle != 0.0f)\n                    {\n                        modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n                    }\n                    modelMatrix = glm::scale(modelMatrix, object.scale);\n\n                    glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n                    glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n                    glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n                    // Set transform uniforms\n                    glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix));\n                    glUniformMatrix4fv(uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n                    glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n                    glUniformMatrix3fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n                    // 1) Diffuse color\n                    if (uKdLocation != -1)\n                    {\n                        glUniform3fv(uKdLocation, 1, glm::value_ptr(mat.Kd));\n                    }\n\n                    // 2) Specular color\n                    if (uKsLocation != -1)\n                    {\n                        glUniform3fv(uKsLocation, 1, glm::value_ptr(mat.Ks));\n                    }\n\n                    // 3) Shininess\n                    if (uShininessLocation != -1)\n                    {\n                        glUniform1f(uShininessLocation, mat.shininess);\n                    }\n\n                    // 4) Diffuse texture\n                    if (mat.hasDiffuseMap && mat.diffuseMapID != 0)\n                    {\n                        glActiveTexture(GL_TEXTURE0);\n                        glBindTexture(GL_TEXTURE_2D, mat.diffuseMapID);\n                        if (uTextureLocation != -1)\n                        {\n                            glUniform1i(uTextureLocation, 0);\n                        }\n                        if (uUseTextureLocation != -1)\n                        {\n                            glUniform1f(uUseTextureLocation, 1.0f);\n                        }\n                    }\n                    else\n                    {\n                        if (uUseTextureLocation != -1)\n                        {\n                            glUniform1f(uUseTextureLocation, 0.0f);\n                        }\n                    }\n\n                    // 5) Normal map\n                    GLint uNormalMapLoc = glGetUniformLocation(currentRoom->getGLId(), \"uNormalMap\");\n                    GLint uUseNormalMapLoc = glGetUniformLocation(currentRoom->getGLId(), \"uUseNormalMap\");\n                    if (mat.hasNormalMap && mat.normalMapID != 0)\n                    {\n                        glActiveTexture(GL_TEXTURE2);\n                        glBindTexture(GL_TEXTURE_2D, mat.normalMapID);\n                        if (uNormalMapLoc != -1)\n                        {\n                            glUniform1i(uNormalMapLoc, 2);\n                        }\n                        if (uUseNormalMapLoc != -1)\n                        {\n                            glUniform1f(uUseNormalMapLoc, 1.0f);\n                        }\n                    }\n                    else\n                    {\n                        if (uUseNormalMapLoc != -1)\n                        {\n                            glUniform1f(uUseNormalMapLoc, 0.0f);\n                        }\n                    }\n\n                    // 6) Specular map\n                    GLint uSpecularMapLocation = glGetUniformLocation(currentRoom->getGLId(), \"uSpecularMap\");\n                    GLint uUseSpecularMapLocation = glGetUniformLocation(currentRoom->getGLId(), \"uUseSpecularMap\");\n                    if (mat.hasSpecularMap && mat.specularMapID != 0)\n                    {\n                        glActiveTexture(GL_TEXTURE3); // Use texture unit 3 for specular maps\n                        glBindTexture(GL_TEXTURE_2D, mat.specularMapID);\n                        if (uSpecularMapLocation != -1)\n                        {\n                            glUniform1i(uSpecularMapLocation, 3); // Set sampler to texture unit 3\n                        }\n                        if (uUseSpecularMapLocation != -1)\n                        {\n                            glUniform1f(uUseSpecularMapLocation, 1.0f); // Enable specular map usage\n                        }\n                    }\n                    else\n                    {\n                        if (uUseSpecularMapLocation != -1)\n                        {\n                            glUniform1f(uUseSpecularMapLocation, 0.0f); // Disable specular map usage\n                        }\n                    }\n\n                    // Draw transparent object\n                    glBindVertexArray(object.vaoID);\n                    if (object.type == utils_scene::ObjectType::Cube)\n                    {\n                        glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                    }\n                    else if (object.type == utils_scene::ObjectType::Sphere)\n                    {\n                        glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n                    }\n                    else if (object.type == utils_scene::ObjectType::Model)\n                    {\n                        glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                    }\n                    glBindVertexArray(0);\n\n                    // (Optional) unbind textures afterwards\n                    glActiveTexture(GL_TEXTURE0);\n                    glBindTexture(GL_TEXTURE_2D, 0);\n                    glActiveTexture(GL_TEXTURE2);\n                    glBindTexture(GL_TEXTURE_2D, 0);\n                    glActiveTexture(GL_TEXTURE3);\n                    glBindTexture(GL_TEXTURE_2D, 0);\n                }\n            }\n\n            // Restore default blending\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n            // Restore depth writing\n            glDepthMask(GL_TRUE);\n\n            // Reset colorMask to default (no shift)\n            glm::vec3 defaultColorMask = glm::vec3(1.0f, 1.0f, 1.0f);\n            glUniform3fv(room2_uColorMaskLocation, 1, glm::value_ptr(defaultColorMask));\n        }\n\n        \n\n        \n\n        // for (const auto &object : utils_scene::sceneObjects) {\n        //     std::cout << \"Object: \" << object.name << \", Material Index: \" << object.materialIndex << std::endl;\n        //     const Material& mat = materialManager.getMaterial(object.materialIndex);\n        //     std::cout << \"  Has Diffuse Map: \" << mat.hasDiffuseMap\n        //             << \", Diffuse Map ID: \" << mat.diffuseMapID\n        //             << \", Has Normal Map: \" << mat.hasNormalMap\n        //             << \", Normal Map ID: \" << mat.normalMapID << std::endl;\n        // }\n\n        // Re-enable face culling after rendering transparent objects\n        // glEnable(GL_CULL_FACE);\n\n        // Swap buffers\n        windowManager.swapBuffers();\n    }\n\n    // Clean up resources\n    glDeleteBuffers(1, &sphereVBO);\n    glDeleteVertexArrays(1, &sphereVAO);\n\n    glDeleteBuffers(1, &cubeVBO);\n    glDeleteBuffers(1, &cubeEBO);\n    glDeleteVertexArrays(1, &cubeVAO);\n\n    // At the end of main, before program termination, we clean up textures from the vector allTextures from file models.cpp\n    for (const auto &texture : utils_object::allTextures)\n    {\n        // print the texture name\n        std::cout << \"Deleting model texture: \" << texture << std::endl;\n        glDeleteTextures(1, &texture);\n    }\n\n    for (const auto &texture : utils_loader::allTextures)\n    {\n        // print the texture name\n        std::cout << \"Deleting textures: \" << texture << std::endl;\n        glDeleteTextures(1, &texture);\n    }\n\n    // Clean up model buffers\n    // glDeleteBuffers(1, &heaterModelData.vbo);\n    // glDeleteBuffers(1, &heaterModelData.ebo);\n    // glDeleteVertexArrays(1, &heaterModelData.vao);\n\n    glDeleteBuffers(1, &rockingChairModelData.vbo);\n    glDeleteBuffers(1, &rockingChairModelData.ebo);\n    glDeleteVertexArrays(1, &rockingChairModelData.vao);\n\n    glDeleteBuffers(1, &torusModelData.vbo);\n    glDeleteBuffers(1, &torusModelData.ebo);\n    glDeleteVertexArrays(1, &torusModelData.vao);\n\n    // Clean up framebuffer and texture\n    glDeleteFramebuffers(1, &shadowMapFBO);\n    glDeleteTextures(1, &depthCubeMap);\n\n    // Clean up shaders\n    // depthShader.deleteProgram();\n    // room1.deleteProgram();\n    // room2.deleteProgram();\n    // skyboxShader.deleteProgram();\n\n    // Clean up materials\n    // materialManager.clear();\n\n    // Clean up scene objects\n    utils_scene::sceneObjects.clear();\n    utils_scene::sceneObjectsTransparent.clear();\n    utils_scene::sceneObjectsSkybox.clear();\n\n    // Clean up simple lights\n    simpleLights.clear();\n\n    // other cleanup\n    utils_object::allTextures.clear();\n    utils_loader::allTextures.clear();\n\n    std::cout << \"Program terminated successfully\" << std::endl;\n\n    return 0;\n}",
    "APP3/shaders/room2.vs copy.glsl": "#version 330 core\n\n// Vertex Attributes\nlayout(location = 0) in vec3 aPosition;     // Vertex position\nlayout(location = 1) in vec3 aNormal;       // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;    // Texture coordinates\nlayout(location = 3) in vec3 aTangent;      // Tangent vector\nlayout(location = 4) in vec3 aBitangent;    // Bitangent vector\n\n// Uniform Matrices\nuniform mat4 uMVPMatrix;      // Model-View-Projection matrix\nuniform mat4 uMVMatrix;       // Model-View matrix\nuniform mat3 uNormalMatrix;   // Normal matrix\n\n// Light Properties\nuniform vec3 uLightPos_vs;    // Main light position in view space\n\n#define MAX_ADDITIONAL_LIGHTS 100\nuniform int uNumAdditionalLights;          \nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS]; // Additional lights in view space\n\n// Constants for Gravitational Pull\nconst float GRAVITY_STRENGTH = 1.3;   // Controls intensity of gravitational pull\nconst float GRAVITY_RANGE = 3.0;     // Maximum range of gravitational effect\nconst float GRAVITY_FALLOFF = 0.5;    // Prevents division by zero\n\n// Outputs to Fragment Shader\nout vec3 vNormal;\nout vec3 vFragPos;\nout vec2 vTexCoords;\nout vec3 vFragPosWorld;\nout mat3 TBN; // Tangent-Bitangent-Normal matrix\n\n// Pseudo-Random Function for Per-Triangle Variance\nfloat rand(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Gravitational Pull Function\nvec3 calculateGravitationalPull(vec3 vertexPos, vec3 lightPos, float strength, float triangleRandom) {\n    vec3 toLight = normalize(lightPos - vertexPos);\n    float distance = length(lightPos - vertexPos);\n\n    if (distance < GRAVITY_RANGE) {\n        float pullStrength = strength / (distance + GRAVITY_FALLOFF);\n        pullStrength *= triangleRandom; // Triangle-specific randomness\n        return toLight * pullStrength;\n    }\n    return vec3(0.0);\n}\n\n// Triangle Shrink Function\nfloat calculateShrinkFactor(vec3 vertexPos, vec3 lightPos) {\n    float distance = length(lightPos - vertexPos);\n    if (distance < GRAVITY_RANGE) {\n        return clamp(1.0 - (distance / GRAVITY_RANGE), 0.5, 1.0); // Min shrink to 50%\n    }\n    return 1.0; // No shrink beyond range\n}\n\n// Triangle Center Approximation\nvec3 calculateTriangleCenter(vec3 v0, vec3 v1, vec3 v2) {\n    return (v0 + v1 + v2) / 3.0;\n}\n\nvoid main() {\n    // Calculate view-space position of the vertex\n    vec3 viewPosition = (uMVMatrix * vec4(aPosition, 1.0)).xyz;\n    vec3 totalDisplacement = vec3(0.0);\n\n    // Randomness Per Triangle (using TexCoords)\n    float triangleRandom = rand(aTexCoords);\n\n    // Pull towards main light (View Space)\n    totalDisplacement += calculateGravitationalPull(viewPosition, uLightPos_vs, GRAVITY_STRENGTH, triangleRandom);\n\n    // Pull towards additional lights (View Space)\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        totalDisplacement += calculateGravitationalPull(viewPosition, uAdditionalLightPos[i], GRAVITY_STRENGTH, triangleRandom);\n    }\n\n    // Apply gravitational pull displacement\n    vec3 displacedPosition = aPosition + (inverse(uMVMatrix) * vec4(totalDisplacement, 0.0)).xyz;\n\n    // Calculate triangle center (approximate using neighboring vertices)\n    vec3 triangleCenter = calculateTriangleCenter(aPosition, aTangent, aBitangent);\n\n    // Apply shrink factor based on gravitational pull\n    float shrinkFactor = calculateShrinkFactor(viewPosition, uLightPos_vs);\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        shrinkFactor *= calculateShrinkFactor(viewPosition, uAdditionalLightPos[i]);\n    }\n\n    // Limit the maximum displacement towards the triangle center\n    vec3 toCenter = triangleCenter - displacedPosition;\n    float maxDisplacement = 0.5;\n    vec3 clampedToCenter = normalize(toCenter) * min(length(toCenter), maxDisplacement);\n\n    // Interpolate vertex towards triangle center for shrink effect\n    vec3 shrunkPosition = displacedPosition + clampedToCenter * (1.0 - shrinkFactor);\n\n    // Final transformation\n    gl_Position = uMVPMatrix * vec4(shrunkPosition, 1.0);\n\n    // Pass data to Fragment Shader\n    vNormal = uNormalMatrix * aNormal;\n    vFragPos = viewPosition + totalDisplacement;\n    vTexCoords = aTexCoords;\n    vFragPosWorld = (inverse(uMVMatrix) * vec4(viewPosition, 1.0)).xyz;\n\n    // Construct TBN Matrix\n    vec3 T = normalize(uNormalMatrix * aTangent);\n    vec3 B = normalize(uNormalMatrix * aBitangent);\n    vec3 N = normalize(uNormalMatrix * aNormal);\n    TBN = mat3(T, B, N);\n}",
    "APP3/shaders/skybox.fs.glsl": "#version 330 core\n\n// Maximum number of additional point lights\n#define MAX_ADDITIONAL_LIGHTS 100\n\n// Uniforms for additional point lights\nuniform int uNumAdditionalLights;\nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS];      \nuniform vec3 uAdditionalLightColor[MAX_ADDITIONAL_LIGHTS];\nuniform float uAdditionalLightIntensity[MAX_ADDITIONAL_LIGHTS];\n\n// Input from vertex shader\nin vec3 vNormal;\nin vec3 vFragPos;         \nin vec3 vFragPosWorld;    \nin vec2 vTexCoords;\nin mat3 TBN;\n\nout vec4 FragColor;\n\n// Material properties\nuniform vec3 uKd;           \nuniform vec3 uKs;           \nuniform float uShininess;   \n\n// Transparency\nuniform float uAlpha;\n\n// Main light properties (in view space)\nuniform vec3 uLightPos_vs;    \nuniform vec3 uLightIntensity; \nuniform float farPlane;\n\n// Camera position in world space\nuniform vec3 cameraPosWorld;\n\n// Texture samplers\nuniform sampler2D uTexture;\nuniform float uUseTexture;        \n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap;\n\n// Specular map\nuniform sampler2D uSpecularMap;\nuniform float uUseSpecularMap;\n\n// Shadow mapping\nuniform samplerCube depthMap;\n\n// Light position in world space\nuniform vec3 lightPosWorld;\n// we keep the uniforms even though they are not used in the skybox fragment shader, but this way, we can still see what stuff we have access to\n\n// **Fragment Shader Main Function**\nvoid main() {\n    // **Simplified Output: Directly Sample and Output Texture Color with Alpha**\n    \n    // Sample the texture color\n    vec4 texColor = texture(uTexture, vTexCoords);\n    \n    // Combine texture alpha with uniform alpha\n    float finalAlpha = texColor.a * uAlpha;\n    \n    // Set the final fragment color\n    FragColor = vec4(texColor.rgb, finalAlpha);\n}",
    "APP3/shaders/room2.fs.glsl": "#version 330 core\n\n// Maximum number of additional point lights\n#define MAX_ADDITIONAL_LIGHTS 100\n\n// Uniforms for additional point lights\nuniform int uNumAdditionalLights;\nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS];      \nuniform vec3 uAdditionalLightColor[MAX_ADDITIONAL_LIGHTS];\nuniform float uAdditionalLightIntensity[MAX_ADDITIONAL_LIGHTS];\n\n// Input from vertex shader\nin vec3 vNormal;\nin vec3 vFragPos;         \nin vec3 vFragPosWorld;    \nin vec2 vTexCoords;\nin mat3 TBN;\n\nout vec4 FragColor;\n\nuniform vec3 uColorMask;\n\n// Material properties\nuniform vec3 uKd;           \nuniform vec3 uKs;           \nuniform float uShininess;   \n\n// Transparency\nuniform float uAlpha;\n\n// Main light properties (in view space)\nuniform vec3 uLightPos_vs;    \nuniform vec3 uLightIntensity; \nuniform float farPlane;\n\n// Camera position in world space\nuniform vec3 cameraPosWorld;\n\n// Texture samplers\nuniform sampler2D uTexture;\nuniform float uUseTexture;        \n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap;\n\n// Specular map\nuniform sampler2D uSpecularMap;\nuniform float uUseSpecularMap;\n\n// Shadow mapping\nuniform samplerCube depthMap;\n\n// Light position in world space\nuniform vec3 lightPosWorld;\n\n// Hardcoded map strengths\nconst float NORMAL_MAP_STRENGTH = 0.3;\nconst float SPECULAR_MAP_STRENGTH = 3.0;\n\n// Sampling offsets for shadow mapping\nconst vec3 gridSamplingDisk[20] = vec3[](\n    vec3( 1,  0,  0), vec3(-1,  0,  0), vec3( 0,  1,  0), vec3( 0, -1,  0), \n    vec3( 0,  0,  1), vec3( 0,  0, -1), vec3( 1,  1,  0), vec3(-1,  1,  0), \n    vec3( 1, -1,  0), vec3(-1, -1,  0), vec3( 1,  0,  1), vec3(-1,  0,  1), \n    vec3( 1,  0, -1), vec3(-1,  0, -1), vec3( 0,  1,  1), vec3( 0, -1,  1), \n    vec3( 0,  1, -1), vec3( 0, -1, -1), vec3( 1,  1,  1), vec3(-1, -1, -1)\n);\n\n// **Shadow Calculation**\nfloat ShadowCalculation(vec3 fragPosWorld) {\n    vec3 fragToLight = fragPosWorld - lightPosWorld;\n    float currentDepth = length(fragToLight);\n    float shadow = 0.0;\n    float bias = 0.25; \n    int samples = 20;\n    float viewDistance = length(cameraPosWorld - fragPosWorld);\n    float diskRadius = (0.0 + (viewDistance / farPlane)) / 50.0;\n\n    for (int i = 0; i < samples; ++i) {\n        vec3 samplePos = fragToLight + gridSamplingDisk[i] * diskRadius;\n        float closestDepth = texture(depthMap, samplePos).r * farPlane;\n\n        if (currentDepth - bias > closestDepth) {\n            shadow += 1.0;\n        }\n    }\n    shadow /= float(samples);\n    return shadow;\n}\n\n// **Normal Map Sampling with Strength**\nvec3 GetNormalFromMap(vec3 defaultNormal) {\n    vec3 normalMap = texture(uNormalMap, vTexCoords).rgb;\n    normalMap = normalMap * 2.0 - 1.0; // Transform from [0,1] to [-1,1]\n\n    // Blend geometry normal and normal map using strength\n    return normalize(mix(defaultNormal, TBN * normalMap, NORMAL_MAP_STRENGTH));\n}\n\n// **Specular Intensity from Map with Strength**\nfloat GetSpecularIntensity() {\n    if (uUseSpecularMap > 0.5) {\n        return texture(uSpecularMap, vTexCoords).r * SPECULAR_MAP_STRENGTH; // Scale with strength\n    }\n    return 1.0 * SPECULAR_MAP_STRENGTH; // Default intensity with strength\n}\n\n// **Main Light - Diffuse**\nvec3 MainLightDiffuse(vec3 albedo, vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n\n    float NdotL = max(dot(N, L), 0.0);\n    return albedo * uLightIntensity * NdotL * attenuation;\n}\n\n// **Main Light - Specular**\nvec3 MainLightSpecular(vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    vec3 V = normalize(-vFragPos); \n    vec3 H = normalize(L + V);\n\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n\n    float NdotH = max(dot(N, H), 0.0);\n    float specularIntensity = GetSpecularIntensity();\n    return uKs * specularIntensity * uLightIntensity * pow(NdotH, uShininess) * attenuation;\n}\n\n// **Additional Lights**\nvec3 AdditionalLights(vec3 albedo, vec3 N) {\n    vec3 totalLight = vec3(0.0);\n\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        vec3 L = normalize(uAdditionalLightPos[i] - vFragPos);\n        vec3 V = normalize(-vFragPos); \n        vec3 H = normalize(L + V);\n\n        float distance = length(uAdditionalLightPos[i] - vFragPos);\n        float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n\n        float NdotL = max(dot(N, L), 0.0);\n        float NdotH = max(dot(N, H), 0.0);\n\n        float specularIntensity = GetSpecularIntensity();\n\n        vec3 diffuse = albedo * uAdditionalLightColor[i] * NdotL * uAdditionalLightIntensity[i] * attenuation;\n        vec3 specular = uKs * specularIntensity * uAdditionalLightColor[i] * pow(NdotH, uShininess) * uAdditionalLightIntensity[i] * attenuation;\n\n        totalLight += diffuse + specular;\n    }\n\n    return totalLight;\n}\n\n// **Transmission Lighting for Main and Additional Lights**\nvec3 TransmissionLighting(vec3 albedo, vec3 N) {\n    vec3 transmissionLight = vec3(0.0);\n\n    // Reverse the normal for back-face lighting\n    vec3 N_back = -N;\n\n    // --- Main Light Transmission ---\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n    float NdotL = max(dot(N_back, L), 0.0); // Use reversed normal\n    vec3 mainDiffuse = albedo * uLightIntensity * NdotL * attenuation;\n    transmissionLight += mainDiffuse;\n\n    // --- Additional Lights Transmission ---\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        vec3 L_add = normalize(uAdditionalLightPos[i] - vFragPos);\n        float distance_add = length(uAdditionalLightPos[i] - vFragPos);\n        float attenuation_add = 1.0 / (1.0 + 0.09 * distance_add + 0.032 * distance_add * distance_add);\n        float NdotL_add = max(dot(N_back, L_add), 0.0); // Use reversed normal\n\n        vec3 additionalDiffuse = albedo * uAdditionalLightColor[i] * NdotL_add * uAdditionalLightIntensity[i] * attenuation_add;\n\n        transmissionLight += additionalDiffuse;\n    }\n\n    // Apply alpha as transmission strength\n    return transmissionLight * uAlpha;\n}\n\n// **Helper Function: Quantize a Single Color Channel**\nfloat quantizeChannel(float color, int levels) {\n    float step = 1.0 / float(levels);\n    return floor(color / step + 0.5) * step;\n}\n\n// ----------------------------- //\n//    **Old TV Pixel Effect**    //\n// ----------------------------- //\n\nvec3 filterTV(vec3 color) {\n    int column = int(gl_FragCoord.x) % 3; // Determine the column (0,1,2)\n    \n    if (column == 0) {\n        // First column: Only Red channel\n        return vec3(color.r, 0.0, 0.0);\n    } \n    else if (column == 1) {\n        // Second column: Only Green channel\n        return vec3(0.0, color.g, 0.0);\n    } \n    else if (column == 2) {\n        // Third column: Only Blue channel\n        return vec3(0.0, 0.0, color.b);\n    } \n    else {\n        // Fourth column: Black edge\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 tempo;\n\nvoid main() {\n    // Determine albedo based on whether a diffuse texture is used\n    vec3 albedo = (uUseTexture > 0.5) ? texture(uTexture, vTexCoords).rgb : uKd;\n    \n    // Determine normal based on whether a normal map is used\n    vec3 N = (uUseNormalMap > 0.5) ? GetNormalFromMap(normalize(vNormal)) : normalize(vNormal);\n\n    // Calculate shadow factor based on main light's shadow\n    float shadow = ShadowCalculation(vFragPosWorld);\n\n    // Calculate main light's lighting contributions\n    vec3 mainDiffuse = MainLightDiffuse(albedo, N);\n    vec3 mainSpecular = MainLightSpecular(N);\n    vec3 mainLighting = (mainDiffuse + mainSpecular) * (1.0 - shadow);\n\n    // Calculate additional lights' lighting contributions\n    vec3 additionalLighting = AdditionalLights(albedo, N);\n\n    // Calculate transmission lighting for both main and additional lights\n    vec3 transmissionLighting = TransmissionLighting(albedo, N);\n\n    // Combine all light sources\n    vec3 lighting = mainLighting + additionalLighting + transmissionLighting;\n\n    // Sample the texture's color and alpha\n    vec4 texColor = texture(uTexture, vTexCoords);\n\n    // Combine texture alpha with uniform alpha\n    float finalAlpha = texColor.a * uAlpha;\n\n    // ----------------------------- //\n    //       **Color Selection**     //\n    // ----------------------------- //\n    vec3 colorToDither;\n\n    if (abs(uAlpha - 0.9) < 0.001) {\n        // **Special Case: Flat Texture Color for alpha == 0.9**\n        colorToDither = albedo;\n    } else {\n        // **Normal Case: Combined Lighting**\n        if (uUseTexture > 0.5) {\n            colorToDither = lighting * texColor.rgb;\n        } else {\n            colorToDither = lighting * uKd;\n        }\n    }\n\n    // ----------------------------- //\n    //       **Dithering Effect**    //\n    // ----------------------------- //\n    \n    // ----- **Dither Configuration (Hard-Coded)** -----\n    const bool ENABLE_DITHER = false;          // Toggle dithering: true to enable, false to disable\n    const bool MONOCHROME_DITHER = false;     // Toggle monochromatic dithering: true for monochrome, false for color\n    const int COLOR_LEVELS = 8;               // Number of color levels per channel (e.g., 8 for 3-bit color)\n    \n    // 4x4 Bayer Matrix (Normalized)\n    const float bayerMatrix[16] = float[16](\n        0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n        12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n        3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n        15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n    );\n\n    if (ENABLE_DITHER) {\n        // Calculate the position within the 4x4 Bayer matrix\n        float scaledX = gl_FragCoord.x / 4.0; \n        float scaledY = gl_FragCoord.y / 4.0;\n        int x = int(mod(scaledX, 4.0));\n        int y = int(mod(scaledY, 4.0));\n        int index = y * 4 + x;\n\n        float threshold = bayerMatrix[index];\n\n        vec3 ditheredColor = colorToDither;\n\n        for(int i = 0; i < 3; ++i) { // Iterate over R, G, B\n            float channel = ditheredColor[i];\n            float quantized = quantizeChannel(channel, COLOR_LEVELS);\n            float error = fract(channel * float(COLOR_LEVELS)) - 0.5;\n\n            if (error > (threshold - 0.5)) {\n                ditheredColor[i] = quantized + (1.0 / float(COLOR_LEVELS));\n            } else {\n                ditheredColor[i] = quantized;\n            }\n        }\n\n        if (MONOCHROME_DITHER) {\n            const vec3 MONOCHROME_COLOR = vec3(0.95, 0.68, 0.49); \n            float luminance = dot(ditheredColor, vec3(0.299, 0.587, 0.114));\n            float quantizedLuminance = quantizeChannel(luminance + threshold / float(COLOR_LEVELS), COLOR_LEVELS);\n            ditheredColor = MONOCHROME_COLOR * quantizedLuminance;\n        }\n\n        FragColor = vec4(ditheredColor, finalAlpha);\n    }\n    else\n    {\n\n        // only output the color channel of the color mask\n        // if all channels are zero or 1, output the original color\n        // uColorMask\n        if (uColorMask.r == 0.0 && uColorMask.g == 0.0 && uColorMask.b == 0.0) {\n            // FragColor = vec4(colorToDither, finalAlpha);\n            tempo = filterTV(colorToDither);\n            FragColor = vec4(tempo, finalAlpha);\n        } else {\n            vec3 maskedColor = vec3(0.0);\n            maskedColor.r = colorToDither.r * uColorMask.r;\n            maskedColor.g = colorToDither.g * uColorMask.g;\n            maskedColor.b = colorToDither.b * uColorMask.b;\n            tempo = filterTV(maskedColor);\n            FragColor = vec4(tempo, finalAlpha);\n        }\n\n        // debug\n        // FragColor = vec4(uColorMask, finalAlpha);\n    }\n}",
    "APP3/shaders/point_shadow_depth.vs.glsl": "#version 330 core\nlayout(location = 0) in vec3 aPosition;\nuniform mat4 model;\nuniform mat4 shadowMatrix;\nout vec4 FragPos;\n\nvoid main() {\n    FragPos = model * vec4(aPosition, 1.0);\n    gl_Position = shadowMatrix * FragPos;\n}",
    "APP3/shaders/room1.fs.glsl": "#version 330 core\n\n// Maximum number of additional point lights\n#define MAX_ADDITIONAL_LIGHTS 100\n\n// Uniforms for additional point lights\nuniform int uNumAdditionalLights;\nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS];      \nuniform vec3 uAdditionalLightColor[MAX_ADDITIONAL_LIGHTS];\nuniform float uAdditionalLightIntensity[MAX_ADDITIONAL_LIGHTS];\n\n// Input from vertex shader\nin vec3 vNormal;\nin vec3 vFragPos;         \nin vec3 vFragPosWorld;    \nin vec2 vTexCoords;\nin mat3 TBN;\n\nout vec4 FragColor;\n\n// Material properties\nuniform vec3 uKd;           \nuniform vec3 uKs;           \nuniform float uShininess;   \n\n// Transparency\nuniform float uAlpha;\n\n// Main light properties (in view space)\nuniform vec3 uLightPos_vs;    \nuniform vec3 uLightIntensity; \nuniform float farPlane;\n\n// Camera position in world space\nuniform vec3 cameraPosWorld;\n\n// Texture samplers\nuniform sampler2D uTexture;\nuniform float uUseTexture;        \n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap;\n\n// Specular map\nuniform sampler2D uSpecularMap;\nuniform float uUseSpecularMap;\n\n// Shadow mapping\nuniform samplerCube depthMap;\n\n// Light position in world space\nuniform vec3 lightPosWorld;\n\n// Hardcoded map strengths\nconst float NORMAL_MAP_STRENGTH = 0.3;\nconst float SPECULAR_MAP_STRENGTH = 3.0;\n\n// Sampling offsets for shadow mapping\nconst vec3 gridSamplingDisk[20] = vec3[](\n    vec3( 1,  0,  0), vec3(-1,  0,  0), vec3( 0,  1,  0), vec3( 0, -1,  0), \n    vec3( 0,  0,  1), vec3( 0,  0, -1), vec3( 1,  1,  0), vec3(-1,  1,  0), \n    vec3( 1, -1,  0), vec3(-1, -1,  0), vec3( 1,  0,  1), vec3(-1,  0,  1), \n    vec3( 1,  0, -1), vec3(-1,  0, -1), vec3( 0,  1,  1), vec3( 0, -1,  1), \n    vec3( 0,  1, -1), vec3( 0, -1, -1), vec3( 1,  1,  1), vec3(-1, -1, -1)\n);\n\nfloat Random(vec3 seed, int i) {\n    return fract(sin(dot(seed + vec3(i), vec3(12.9898, 78.233, 37.719))) * 43758.5453);\n}\n\n// **Shadow Calculation**\nfloat ShadowCalculation(vec3 fragPosWorld) {\n    vec3 fragToLight = fragPosWorld - lightPosWorld;\n    float currentDepth = length(fragToLight);\n    float shadow = 0.0;\n    float bias = 0.25; // Reduced bias for accuracy\n    int samples = 25; // Number of random samples\n    float viewDistance = length(cameraPosWorld - fragPosWorld);\n    float diskRadius = (0.25 + (viewDistance / farPlane)) / 20.0; // Adjust blur radius (putting lwoer to hide the jagged edges)\n\n    float totalWeight = 0.0;\n\n    for (int i = 0; i < samples; ++i) {\n        // Random offsets based on the fragment position and loop index\n        float randX = Random(fragPosWorld, i) * 2.0 - 1.0;\n        float randY = Random(fragPosWorld, i + samples) * 2.0 - 1.0;\n        float randZ = Random(fragPosWorld, i + samples * 2) * 2.0 - 1.0;\n\n        vec3 offset = vec3(randX, randY, randZ) * diskRadius;\n        vec3 samplePos = fragToLight + offset;\n\n        float closestDepth = texture(depthMap, samplePos).r * farPlane;\n\n        if (currentDepth - bias > closestDepth) {\n            shadow += 1.0;\n        }\n        totalWeight += 1.0;\n    }\n\n    shadow /= totalWeight; // Normalize the shadow value\n    return shadow * 5;\n}\n\n// **Normal Map Sampling with Strength**\nvec3 GetNormalFromMap(vec3 defaultNormal) {\n    vec3 normalMap = texture(uNormalMap, vTexCoords).rgb;\n    normalMap = normalMap * 2.0 - 1.0; // Transform from [0,1] to [-1,1]\n\n    // Blend geometry normal and normal map using strength\n    return normalize(mix(defaultNormal, TBN * normalMap, NORMAL_MAP_STRENGTH));\n}\n\n// **Specular Intensity from Map with Strength**\nfloat GetSpecularIntensity() {\n    if (uUseSpecularMap > 0.5) {\n        return texture(uSpecularMap, vTexCoords).r * SPECULAR_MAP_STRENGTH; // Scale with strength\n    }\n    return 1.0 * SPECULAR_MAP_STRENGTH; // Default intensity with strength\n}\n\n// **Main Light - Diffuse**\nvec3 MainLightDiffuse(vec3 albedo, vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    float distance = length(uLightPos_vs - vFragPos);\n    // float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.010 * distance * distance);\n\n    float NdotL = max(dot(N, L), 0.0);\n    return albedo * uLightIntensity * NdotL * attenuation;\n}\n\n// **Main Light - Specular**\nvec3 MainLightSpecular(vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    vec3 V = normalize(-vFragPos); \n    vec3 H = normalize(L + V);\n\n    float distance = length(uLightPos_vs - vFragPos);\n    // float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n    float attenuation = 1.0 / (1.0 + 0.005 * distance + 0.001 * distance * distance);\n\n    float NdotH = max(dot(N, H), 0.0);\n    float specularIntensity = GetSpecularIntensity();\n    return uKs * specularIntensity * uLightIntensity * pow(NdotH, uShininess) * attenuation;\n}\n\n// **Additional Lights**\nvec3 AdditionalLights(vec3 albedo, vec3 N) {\n    vec3 totalLight = vec3(0.0);\n\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        vec3 L = normalize(uAdditionalLightPos[i] - vFragPos);\n        vec3 V = normalize(-vFragPos); \n        vec3 H = normalize(L + V);\n\n        float distance = length(uAdditionalLightPos[i] - vFragPos);\n        // float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n        float attenuation = 1.0 / (1.0 + 0.06 * distance + 0.032 * distance * distance);\n\n        float NdotL = max(dot(N, L), 0.0);\n        float NdotH = max(dot(N, H), 0.0);\n\n        float specularIntensity = GetSpecularIntensity();\n\n        vec3 diffuse = albedo * uAdditionalLightColor[i] * NdotL * uAdditionalLightIntensity[i] * attenuation;\n        vec3 specular = uKs * specularIntensity * uAdditionalLightColor[i] * pow(NdotH, uShininess) * uAdditionalLightIntensity[i] * attenuation;\n\n        totalLight += diffuse + specular;\n    }\n\n    return totalLight;\n}\n\n// **Omni-Directional Lighting for Transparency**\nvec3 CalculateOmniDirectionalLighting(vec3 albedo, vec3 N) {\n    vec3 omniLight = vec3(0.0);\n\n    // Main Light Contribution\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.05 * distance + 0.01 * distance * distance);\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n\n    float NdotL = max(dot(N, L), 0.0);       \n    float NdotL_inv = max(dot(-N, L), 0.0);  \n\n    // Reduce weight for side directions\n    float weight = (NdotL > 0.5 || NdotL_inv > 0.5) ? 1.0 : 0.5; \n\n    omniLight += albedo * uLightIntensity * attenuation * weight;\n\n    // Additional Lights Contribution\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        float distance_add = length(uAdditionalLightPos[i] - vFragPos);\n        float attenuation_add = 1.0 / (1.0 + 0.05 * distance_add + 0.01 * distance_add * distance_add);\n        vec3 L_add = normalize(uAdditionalLightPos[i] - vFragPos);\n\n        float NdotL_add = max(dot(N, L_add), 0.0);\n        float NdotL_inv_add = max(dot(-N, L_add), 0.0);\n\n        float weight_add = (NdotL_add > 0.5 || NdotL_inv_add > 0.5) ? 1.0 : 0.5; \n\n        omniLight += albedo * uAdditionalLightColor[i] * uAdditionalLightIntensity[i] * attenuation_add * weight_add;\n    }\n\n    return omniLight * uAlpha;\n}\n\n// **Fragment Shader Main Function**\nvoid main() {\n    // Determine albedo based on whether a diffuse texture is used\n    vec3 albedo = (uUseTexture > 0.5) ? texture(uTexture, vTexCoords).rgb : uKd;\n    \n    // Sample the texture's color and alpha\n    vec4 texColor = texture(uTexture, vTexCoords);\n    float finalAlpha = texColor.a * uAlpha;\n\n    vec3 lighting = vec3(0.0);\n\n    if (abs(uAlpha - 0.9) < 0.001) {\n        // **Special Case: Flat Texture Render for alpha == 0.9**\n        lighting = albedo; // Directly use the texture color without lighting\n    } \n    else if (uAlpha < 0.9) {\n        // **Transparent Material: Omni-Directional Lighting**\n        lighting = CalculateOmniDirectionalLighting(albedo, normalize(vNormal));\n    } \n    else {\n        // **Fully Opaque Path: Standard Lighting with Shadows**\n        vec3 N = (uUseNormalMap > 0.5) ? GetNormalFromMap(normalize(vNormal)) : normalize(vNormal);\n        float shadow = ShadowCalculation(vFragPosWorld);\n\n        // Standard opaque lighting\n        vec3 mainDiffuse = MainLightDiffuse(albedo, N);\n        vec3 mainSpecular = MainLightSpecular(N);\n        vec3 mainLighting = (mainDiffuse + mainSpecular) * (1.0 - shadow);\n\n        vec3 additionalLighting = AdditionalLights(albedo, N);\n\n        lighting = mainLighting + additionalLighting;\n    }\n\n    // Final fragment output\n    FragColor = vec4(lighting * texColor.rgb, finalAlpha);\n}",
    "APP3/shaders/point_shadow_depth.fs.glsl": "#version 330 core\nin vec4 FragPos;\nuniform vec3 lightPos;\nuniform float farPlane;\n\nvoid main() {\n    float lightDistance = length(FragPos.xyz - lightPos);\n    lightDistance = lightDistance / farPlane;\n    gl_FragDepth = lightDistance;\n}",
    "APP3/shaders/room2.vs.glsl": "#version 330 core\n\n// Vertex Attributes\nlayout(location = 0) in vec3 aPosition;     // Vertex position\nlayout(location = 1) in vec3 aNormal;       // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;    // Texture coordinates\nlayout(location = 3) in vec3 aTangent;      // Tangent vector\nlayout(location = 4) in vec3 aBitangent;    // Bitangent vector\n\n// Uniform Matrices\nuniform mat4 uMVPMatrix;      // Model-View-Projection matrix\nuniform mat4 uMVMatrix;       // Model-View matrix\nuniform mat3 uNormalMatrix;   // Normal matrix\n\n// Light Properties\nuniform vec3 uLightPos_vs;    // Main light position in view space\nuniform vec3 uLightIntensity; // Main light color\n\n#define MAX_ADDITIONAL_LIGHTS 100\nuniform int uNumAdditionalLights;          \nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS]; // Additional lights in view space\nuniform float uAdditionalLightIntensity[MAX_ADDITIONAL_LIGHTS];\n\n// Constants for Gravitational Pull\nconst float GRAVITY_STRENGTH = 0.8;   // Controls intensity of gravitational pull\nconst float GRAVITY_RANGE = 3.5;     // Maximum range of gravitational effect\nconst float GRAVITY_FALLOFF = 0.9;    // Prevents division by zero\n\n// uTime\nuniform float uTime;\n\n// Color Mask\nuniform vec3 uColorMask; // Color mask for distortion scaling\n\nconst float RED_SCALE = 1.5;    // More distortion\nconst float GREEN_SCALE = 1.0;  // Normal distortion\nconst float BLUE_SCALE = 0.5;   // Less distortion\n\nconst float EPSILON = 0.01;\n\n// Outputs to Fragment Shader\nout vec3 vNormal;\nout vec3 vFragPos;\nout vec2 vTexCoords;\nout vec3 vFragPosWorld;\nout mat3 TBN; // Tangent-Bitangent-Normal matrix\n// out vec3 vTotalDisplacement; // Removed as it's no longer needed\n\n// Pseudo-Random Function for Per-Triangle Variance\nfloat rand(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Gravitational Pull Function\nvec3 calculateGravitationalPull(vec3 vertexPos, vec3 lightPos, float strength, float triangleRandom) {\n    vec3 toLight = normalize(lightPos - vertexPos);\n    float distance = length(lightPos - vertexPos);\n\n    if (distance < GRAVITY_RANGE) {\n        float pullStrength = strength / (distance + GRAVITY_FALLOFF);\n        pullStrength *= triangleRandom; // Triangle-specific randomness\n        return toLight * pullStrength;\n    }\n    return vec3(0.0);\n}\n\nfloat triangleWave(float t) {\n    return abs(fract(t) - 0.5) * 2.0; // Range [0.0, 1.0]\n}\n\n// Triangle Shrink Function\nfloat calculateShrinkFactor(vec3 vertexPos, vec3 lightPos, float intensity) {\n    float distance = length(lightPos - vertexPos);\n    if (distance < GRAVITY_RANGE) {\n        // Also add time factor\n        return clamp(1.0 - (distance / GRAVITY_RANGE) + intensity * 0.2, 0.5, 1.3); // Min shrink to 50%\n    }\n    return 1.0; // No shrink beyond range\n}\n\n// Triangle Center Approximation\nvec3 calculateTriangleCenter(vec3 v0, vec3 v1, vec3 v2) {\n    return (v0 + v1 + v2) / 3.0;\n}\n\nvoid main() {\n    // Calculate view-space position of the vertex\n    vec3 viewPosition = (uMVMatrix * vec4(aPosition, 1.0)).xyz;\n    vec3 totalDisplacement = vec3(0.0);\n\n    // Randomness Per Triangle (using TexCoords)\n    float triangleRandom = rand(aTexCoords);\n\n    // Pull towards main light (View Space)\n    totalDisplacement += calculateGravitationalPull(viewPosition, uLightPos_vs, GRAVITY_STRENGTH, triangleRandom);\n\n    // Pull towards additional lights (View Space)\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        totalDisplacement += calculateGravitationalPull(viewPosition, uAdditionalLightPos[i], GRAVITY_STRENGTH, triangleRandom);\n    }\n\n    // **Apply Color Mask-Based Distortion Scaling**\n    // Check if all channels are fully active (1.0) or fully inactive (0.0)\n    bool allActive = (abs(uColorMask.r - 1.0) < EPSILON) && \n                    (abs(uColorMask.g - 1.0) < EPSILON) && \n                    (abs(uColorMask.b - 1.0) < EPSILON);\n\n    bool allInactive = (abs(uColorMask.r) < EPSILON) && \n                    (abs(uColorMask.g) < EPSILON) && \n                    (abs(uColorMask.b) < EPSILON);\n\n    float distortionScale = 1.0;\n\n    if (allActive) {\n        distortionScale = 1.0; // No extra scaling\n    } else if (allInactive) {\n        distortionScale = 1.0;\n    } else {\n        // Apply cumulative scaling based on active channels\n        distortionScale = (uColorMask.r * RED_SCALE) + \n                        (uColorMask.g * GREEN_SCALE) + \n                        (uColorMask.b * BLUE_SCALE);\n    }\n\n    // Apply the distortion scale to the total displacement\n    vec3 totalDisplacementScaled = totalDisplacement * distortionScale;\n\n    // Apply gravitational pull displacement\n    vec3 displacedPosition = aPosition + (inverse(uMVMatrix) * vec4(totalDisplacementScaled, 0.0)).xyz;\n\n    // Calculate triangle center (approximate using neighboring vertices)\n    vec3 triangleCenter = calculateTriangleCenter(aPosition, aTangent, aBitangent);\n\n    // Apply shrink factor based on gravitational pull\n    float shrinkFactor = calculateShrinkFactor(viewPosition, uLightPos_vs, uLightIntensity.x);\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        shrinkFactor *= calculateShrinkFactor(viewPosition, uAdditionalLightPos[i], uAdditionalLightIntensity[i]);\n    }\n\n    // Limit the maximum displacement towards the triangle center\n    vec3 toCenter = triangleCenter - displacedPosition;\n    float maxDisplacement = 0.5;\n    vec3 clampedToCenter = normalize(toCenter) * min(length(toCenter), maxDisplacement);\n\n    // Interpolate vertex towards triangle center for shrink effect\n    vec3 shrunkPosition = displacedPosition + clampedToCenter * (1.0 - shrinkFactor);\n\n    // Final transformation\n    gl_Position = uMVPMatrix * vec4(shrunkPosition, 1.0);\n\n    // Pass data to Fragment Shader\n    vNormal = uNormalMatrix * aNormal;\n    vFragPos = viewPosition + totalDisplacementScaled;\n    vTexCoords = aTexCoords;\n    vFragPosWorld = (inverse(uMVMatrix) * vec4(viewPosition, 1.0)).xyz;\n\n    // Construct TBN Matrix\n    vec3 T = normalize(uNormalMatrix * aTangent);\n    vec3 B = normalize(uNormalMatrix * aBitangent);\n    vec3 N = normalize(uNormalMatrix * aNormal);\n    TBN = mat3(T, B, N);\n}",
    "APP3/shaders/skybox.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPosition;     // Vertex position\nlayout(location = 1) in vec3 aNormal;       // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;    // Texture coordinates\nlayout(location = 3) in vec3 aTangent;      // Tangent vector\nlayout(location = 4) in vec3 aBitangent;    // Bitangent vector\n\n// Uniforms\nuniform mat4 uMVPMatrix;\nuniform mat4 uMVMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat4 lightSpaceMatrix;\nuniform mat4 uModelMatrix;\n\nout vec3 vNormal;\nout vec3 vFragPos;\nout vec2 vTexCoords;\nout vec4 vFragPosLightSpace;\nout mat3 TBN; // Tangent-Bitangent-Normal matrix\nout vec3 vFragPosWorld;\n\nvoid main()\n{\n    vNormal = normalize(uNormalMatrix * aNormal);\n    vFragPos = vec3(uMVMatrix * vec4(aPosition, 1.0));\n    vTexCoords = aTexCoords;\n    \n    // Calculate world space fragment position\n    vFragPosWorld = vec3(uModelMatrix * vec4(aPosition, 1.0));\n\n    // Transform TBN vectors into view space\n    vec3 T = normalize(uNormalMatrix * aTangent);\n    vec3 B = normalize(uNormalMatrix * aBitangent);\n    vec3 N = normalize(uNormalMatrix * aNormal);\n    TBN = mat3(T, B, N);\n\n    // Transform fragment position to light space\n    vFragPosLightSpace = lightSpaceMatrix * uModelMatrix * vec4(aPosition, 1.0);\n\n    gl_Position = uMVPMatrix * vec4(aPosition, 1.0);\n}",
    "APP3/shaders/room2.fs copy.glsl": "#version 330 core\n\n// Maximum number of additional point lights\n#define MAX_ADDITIONAL_LIGHTS 100\n\n// Uniforms for additional point lights\nuniform int uNumAdditionalLights;\nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS];      \nuniform vec3 uAdditionalLightColor[MAX_ADDITIONAL_LIGHTS];\nuniform float uAdditionalLightIntensity[MAX_ADDITIONAL_LIGHTS];\n\n// Input from vertex shader\nin vec3 vNormal;\nin vec3 vFragPos;         \nin vec3 vFragPosWorld;    \nin vec2 vTexCoords;\nin mat3 TBN;\n\nout vec4 FragColor;\n\nuniform vec3 colorMask;\n\n// Material properties\nuniform vec3 uKd;           \nuniform vec3 uKs;           \nuniform float uShininess;   \n\n// Transparency\nuniform float uAlpha;\n\n// Main light properties (in view space)\nuniform vec3 uLightPos_vs;    \nuniform vec3 uLightIntensity; \nuniform float farPlane;\n\n// Camera position in world space\nuniform vec3 cameraPosWorld;\n\n// Texture samplers\nuniform sampler2D uTexture;\nuniform float uUseTexture;        \n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap;\n\n// Specular map\nuniform sampler2D uSpecularMap;\nuniform float uUseSpecularMap;\n\n// Shadow mapping\nuniform samplerCube depthMap;\n\n// Light position in world space\nuniform vec3 lightPosWorld;\n\n// Hardcoded map strengths\nconst float NORMAL_MAP_STRENGTH = 0.3;\nconst float SPECULAR_MAP_STRENGTH = 3.0;\n\n// Sampling offsets for shadow mapping\nconst vec3 gridSamplingDisk[20] = vec3[](\n    vec3( 1,  0,  0), vec3(-1,  0,  0), vec3( 0,  1,  0), vec3( 0, -1,  0), \n    vec3( 0,  0,  1), vec3( 0,  0, -1), vec3( 1,  1,  0), vec3(-1,  1,  0), \n    vec3( 1, -1,  0), vec3(-1, -1,  0), vec3( 1,  0,  1), vec3(-1,  0,  1), \n    vec3( 1,  0, -1), vec3(-1,  0, -1), vec3( 0,  1,  1), vec3( 0, -1,  1), \n    vec3( 0,  1, -1), vec3( 0, -1, -1), vec3( 1,  1,  1), vec3(-1, -1, -1)\n);\n\n// **Shadow Calculation**\nfloat ShadowCalculation(vec3 fragPosWorld) {\n    vec3 fragToLight = fragPosWorld - lightPosWorld;\n    float currentDepth = length(fragToLight);\n    float shadow = 0.0;\n    float bias = 0.25; \n    int samples = 20;\n    float viewDistance = length(cameraPosWorld - fragPosWorld);\n    float diskRadius = (0.0 + (viewDistance / farPlane)) / 50.0;\n\n    for (int i = 0; i < samples; ++i) {\n        vec3 samplePos = fragToLight + gridSamplingDisk[i] * diskRadius;\n        float closestDepth = texture(depthMap, samplePos).r * farPlane;\n\n        if (currentDepth - bias > closestDepth) {\n            shadow += 1.0;\n        }\n    }\n    shadow /= float(samples);\n    return shadow;\n}\n\n// **Normal Map Sampling with Strength**\nvec3 GetNormalFromMap(vec3 defaultNormal) {\n    vec3 normalMap = texture(uNormalMap, vTexCoords).rgb;\n    normalMap = normalMap * 2.0 - 1.0; // Transform from [0,1] to [-1,1]\n\n    // Blend geometry normal and normal map using strength\n    return normalize(mix(defaultNormal, TBN * normalMap, NORMAL_MAP_STRENGTH));\n}\n\n// **Specular Intensity from Map with Strength**\nfloat GetSpecularIntensity() {\n    if (uUseSpecularMap > 0.5) {\n        return texture(uSpecularMap, vTexCoords).r * SPECULAR_MAP_STRENGTH; // Scale with strength\n    }\n    return 1.0 * SPECULAR_MAP_STRENGTH; // Default intensity with strength\n}\n\n// **Main Light - Diffuse**\nvec3 MainLightDiffuse(vec3 albedo, vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n\n    float NdotL = max(dot(N, L), 0.0);\n    return albedo * uLightIntensity * NdotL * attenuation;\n}\n\n// **Main Light - Specular**\nvec3 MainLightSpecular(vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    vec3 V = normalize(-vFragPos); \n    vec3 H = normalize(L + V);\n\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n\n    float NdotH = max(dot(N, H), 0.0);\n    float specularIntensity = GetSpecularIntensity();\n    return uKs * specularIntensity * uLightIntensity * pow(NdotH, uShininess) * attenuation;\n}\n\n// **Additional Lights**\nvec3 AdditionalLights(vec3 albedo, vec3 N) {\n    vec3 totalLight = vec3(0.0);\n\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        vec3 L = normalize(uAdditionalLightPos[i] - vFragPos);\n        vec3 V = normalize(-vFragPos); \n        vec3 H = normalize(L + V);\n\n        float distance = length(uAdditionalLightPos[i] - vFragPos);\n        float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n\n        float NdotL = max(dot(N, L), 0.0);\n        float NdotH = max(dot(N, H), 0.0);\n\n        float specularIntensity = GetSpecularIntensity();\n\n        vec3 diffuse = albedo * uAdditionalLightColor[i] * NdotL * uAdditionalLightIntensity[i] * attenuation;\n        vec3 specular = uKs * specularIntensity * uAdditionalLightColor[i] * pow(NdotH, uShininess) * uAdditionalLightIntensity[i] * attenuation;\n\n        totalLight += diffuse + specular;\n    }\n\n    return totalLight;\n}\n\n// **Transmission Lighting for Main and Additional Lights**\nvec3 TransmissionLighting(vec3 albedo, vec3 N) {\n    vec3 transmissionLight = vec3(0.0);\n\n    // Reverse the normal for back-face lighting\n    vec3 N_back = -N;\n\n    // --- Main Light Transmission ---\n    vec3 L = normalize(uLightPos_vs - vFragPos);\n    float distance = length(uLightPos_vs - vFragPos);\n    float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);\n    float NdotL = max(dot(N_back, L), 0.0); // Use reversed normal\n    vec3 mainDiffuse = albedo * uLightIntensity * NdotL * attenuation;\n    transmissionLight += mainDiffuse;\n\n    // --- Additional Lights Transmission ---\n    for (int i = 0; i < uNumAdditionalLights; ++i) {\n        vec3 L_add = normalize(uAdditionalLightPos[i] - vFragPos);\n        float distance_add = length(uAdditionalLightPos[i] - vFragPos);\n        float attenuation_add = 1.0 / (1.0 + 0.09 * distance_add + 0.032 * distance_add * distance_add);\n        float NdotL_add = max(dot(N_back, L_add), 0.0); // Use reversed normal\n\n        vec3 additionalDiffuse = albedo * uAdditionalLightColor[i] * NdotL_add * uAdditionalLightIntensity[i] * attenuation_add;\n\n        transmissionLight += additionalDiffuse;\n    }\n\n    // Apply alpha as transmission strength\n    return transmissionLight * uAlpha;\n}\n\n// **Helper Function: Quantize a Single Color Channel**\nfloat quantizeChannel(float color, int levels) {\n    float step = 1.0 / float(levels);\n    return floor(color / step + 0.5) * step;\n}\n\nvoid main() {\n    // Determine albedo based on whether a diffuse texture is used\n    vec3 albedo = (uUseTexture > 0.5) ? texture(uTexture, vTexCoords).rgb : uKd;\n    \n    // Determine normal based on whether a normal map is used\n    vec3 N = (uUseNormalMap > 0.5) ? GetNormalFromMap(normalize(vNormal)) : normalize(vNormal);\n\n    // Calculate shadow factor based on main light's shadow\n    float shadow = ShadowCalculation(vFragPosWorld);\n\n    // Calculate main light's lighting contributions\n    vec3 mainDiffuse = MainLightDiffuse(albedo, N);\n    vec3 mainSpecular = MainLightSpecular(N);\n    vec3 mainLighting = (mainDiffuse + mainSpecular) * (1.0 - shadow);\n\n    // Calculate additional lights' lighting contributions\n    vec3 additionalLighting = AdditionalLights(albedo, N);\n\n    // Calculate transmission lighting for both main and additional lights\n    vec3 transmissionLighting = TransmissionLighting(albedo, N);\n\n    // Combine all light sources\n    vec3 lighting = mainLighting + additionalLighting + transmissionLighting;\n\n    // Sample the texture's color and alpha\n    vec4 texColor = texture(uTexture, vTexCoords);\n\n    // Combine texture alpha with uniform alpha\n    float finalAlpha = texColor.a * uAlpha;\n\n    // ----------------------------- //\n    //       **Color Selection**     //\n    // ----------------------------- //\n    vec3 colorToDither;\n\n    if (abs(uAlpha - 0.9) < 0.001) {\n        // **Special Case: Flat Texture Color for alpha == 0.9**\n        colorToDither = albedo;\n    } else {\n        // **Normal Case: Combined Lighting**\n        colorToDither = lighting * texColor.rgb;\n    }\n\n    // ----------------------------- //\n    //       **Dithering Effect**    //\n    // ----------------------------- //\n    \n    // ----- **Dither Configuration (Hard-Coded)** -----\n    const bool ENABLE_DITHER = false;          // Toggle dithering: true to enable, false to disable\n    const bool MONOCHROME_DITHER = false;     // Toggle monochromatic dithering: true for monochrome, false for color\n    const int COLOR_LEVELS = 8;               // Number of color levels per channel (e.g., 8 for 3-bit color)\n    \n    // 4x4 Bayer Matrix (Normalized)\n    const float bayerMatrix[16] = float[16](\n        0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n        12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n        3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n        15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n    );\n\n    if (ENABLE_DITHER) {\n        // Calculate the position within the 4x4 Bayer matrix\n        float scaledX = gl_FragCoord.x / 4.0; \n        float scaledY = gl_FragCoord.y / 4.0;\n        int x = int(mod(scaledX, 4.0));\n        int y = int(mod(scaledY, 4.0));\n        int index = y * 4 + x;\n\n        float threshold = bayerMatrix[index];\n\n        vec3 ditheredColor = colorToDither;\n\n        for(int i = 0; i < 3; ++i) { // Iterate over R, G, B\n            float channel = ditheredColor[i];\n            float quantized = quantizeChannel(channel, COLOR_LEVELS);\n            float error = fract(channel * float(COLOR_LEVELS)) - 0.5;\n\n            if (error > (threshold - 0.5)) {\n                ditheredColor[i] = quantized + (1.0 / float(COLOR_LEVELS));\n            } else {\n                ditheredColor[i] = quantized;\n            }\n        }\n\n        if (MONOCHROME_DITHER) {\n            const vec3 MONOCHROME_COLOR = vec3(0.95, 0.68, 0.49); \n            float luminance = dot(ditheredColor, vec3(0.299, 0.587, 0.114));\n            float quantizedLuminance = quantizeChannel(luminance + threshold / float(COLOR_LEVELS), COLOR_LEVELS);\n            ditheredColor = MONOCHROME_COLOR * quantizedLuminance;\n        }\n\n        FragColor = vec4(ditheredColor, finalAlpha);\n    } else {\n\n        // only output the color channel of the color mask\n        // if all channels are zero or 1, output the original color\n        // colorMask\n        if (colorMask.r == 0.0 && colorMask.g == 0.0 && colorMask.b == 0.0) {\n            FragColor = vec4(colorToDither, finalAlpha);\n        } else {\n            vec3 maskedColor = vec3(0.0);\n            maskedColor.r = colorToDither.r * colorMask.r;\n            maskedColor.g = colorToDither.g * colorMask.g;\n            maskedColor.b = colorToDither.b * colorMask.b;\n            FragColor = vec4(maskedColor, finalAlpha);\n        }\n    }\n}",
    "APP3/shaders/light.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPosition;     // Vertex position\nlayout(location = 1) in vec3 aNormal;       // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;    // Texture coordinates\nlayout(location = 3) in vec3 aTangent;      // Tangent vector\nlayout(location = 4) in vec3 aBitangent;    // Bitangent vector\n\n// Uniforms\nuniform mat4 uMVPMatrix;\nuniform mat4 uMVMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat4 lightSpaceMatrix;\nuniform mat4 uModelMatrix;\n\nout vec3 vNormal;\nout vec3 vFragPos;\nout vec2 vTexCoords;\nout vec4 vFragPosLightSpace;\nout mat3 TBN; // Tangent-Bitangent-Normal matrix\nout vec3 vFragPosWorld;\n\nvoid main()\n{\n    vNormal = normalize(uNormalMatrix * aNormal);\n    vFragPos = vec3(uMVMatrix * vec4(aPosition, 1.0));\n    vTexCoords = aTexCoords;\n    \n    // Calculate world space fragment position\n    vFragPosWorld = vec3(uModelMatrix * vec4(aPosition, 1.0));\n\n    // Transform TBN vectors into view space\n    vec3 T = normalize(uNormalMatrix * aTangent);\n    vec3 B = normalize(uNormalMatrix * aBitangent);\n    vec3 N = normalize(uNormalMatrix * aNormal);\n    TBN = mat3(T, B, N);\n\n    // Transform fragment position to light space\n    vFragPosLightSpace = lightSpaceMatrix * uModelMatrix * vec4(aPosition, 1.0);\n\n    gl_Position = uMVPMatrix * vec4(aPosition, 1.0);\n}",
    "APP3/shaders/light.fs.glsl": "#version 330 core\n\n// Maximum number of additional point lights\n#define MAX_ADDITIONAL_LIGHTS 100\n\n// Uniforms for additional point lights\nuniform int uNumAdditionalLights;\nuniform vec3 uAdditionalLightPos[MAX_ADDITIONAL_LIGHTS];      \nuniform vec3 uAdditionalLightColor[MAX_ADDITIONAL_LIGHTS];\nuniform float uAdditionalLightIntensity[MAX_ADDITIONAL_LIGHTS];\n\n// Input from vertex shader\nin vec3 vNormal;\nin vec3 vFragPos;         \nin vec3 vFragPosWorld;    \nin vec2 vTexCoords;\nin mat3 TBN;\n\nout vec4 FragColor;\n\n// Material properties\nuniform vec3 uKd;           \nuniform vec3 uKs;           \nuniform float uShininess;   \n\n// Transparency\nuniform float uAlpha;\n\n// Main light properties (in view space)\nuniform vec3 uLightPos_vs;    \nuniform vec3 uLightIntensity; \nuniform float farPlane;\n\n// Camera position in world space\nuniform vec3 cameraPosWorld;\n\n// Texture samplers\nuniform sampler2D uTexture;\nuniform float uUseTexture;        \n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap;\n\n// Specular map\nuniform sampler2D uSpecularMap;\nuniform float uUseSpecularMap;\n\n// Shadow mapping\nuniform samplerCube depthMap;\n\n// Light position in world space\nuniform vec3 lightPosWorld;\n\n// main output is main light intensity, no texture or anything else\n\n// **Fragment Shader Main Function**\nvoid main() {\n    // FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    // try kD light\n    FragColor = vec4(uKd, 1.0);\n}",
    "APP3/shaders/room1.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPosition;     // Vertex position\nlayout(location = 1) in vec3 aNormal;       // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;    // Texture coordinates\nlayout(location = 3) in vec3 aTangent;      // Tangent vector\nlayout(location = 4) in vec3 aBitangent;    // Bitangent vector\n\n// Uniforms\nuniform mat4 uMVPMatrix;\nuniform mat4 uMVMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat4 lightSpaceMatrix;\nuniform mat4 uModelMatrix;\n\nout vec3 vNormal;\nout vec3 vFragPos;\nout vec2 vTexCoords;\nout vec4 vFragPosLightSpace;\nout mat3 TBN; // Tangent-Bitangent-Normal matrix\nout vec3 vFragPosWorld;\n\nvoid main()\n{\n    vNormal = normalize(uNormalMatrix * aNormal);\n    vFragPos = vec3(uMVMatrix * vec4(aPosition, 1.0));\n    vTexCoords = aTexCoords;\n    \n    // Calculate world space fragment position\n    vFragPosWorld = vec3(uModelMatrix * vec4(aPosition, 1.0));\n\n    // Transform TBN vectors into view space\n    vec3 T = normalize(uNormalMatrix * aTangent);\n    vec3 B = normalize(uNormalMatrix * aBitangent);\n    vec3 N = normalize(uNormalMatrix * aNormal);\n    TBN = mat3(T, B, N);\n\n    // Transform fragment position to light space\n    vFragPosLightSpace = lightSpaceMatrix * uModelMatrix * vec4(aPosition, 1.0);\n\n    gl_Position = uMVPMatrix * vec4(aPosition, 1.0);\n}",
    "APP3/utils/rendering.cpp": "#include \"rendering.hpp\"\n\nnamespace utils_game_loop {\n\nvoid dynamic_loop(float &deltaTime, float &lastFrame, float &currentFrame,\n                  glimac::SDLWindowManager &windowManager, glm::vec3 &cameraPos,\n                  glm::vec3 &cameraFront, glm::vec3 &cameraUp, float cameraSpeed,\n                  bool &done, bool &isRockingChairPaused, double &rockingChairStartTime,\n                  double &rockingChairPausedTime, float &yaw, float &pitch, float cameraRadius,\n                  double frequency, double radius, double length,\n                  float cameraHeight) {\n\n    // Update dynamic only objects before rendering\n    for (auto& object : utils_scene::sceneObjects) {\n        if (!object.isStatic) {\n            // we place here all objects that we want to move\n            if (object.name == \"rocking_chair\") {\n                double adjustedTime = currentFrame - rockingChairStartTime;\n                if (isRockingChairPaused) {\n                    adjustedTime = rockingChairPausedTime - rockingChairStartTime;\n                }\n\n                glm::vec3 offsetPosition;\n                glm::vec3 rotation;\n                float rotationAngleRadians;\n                utils_object::GetRockingChairPositionAndRotation(\n                    adjustedTime,\n                    frequency,\n                    radius,\n                    length,\n                    offsetPosition,\n                    rotation\n                );\n\n                // Update position and rotation\n                object.position = object.initialPosition + offsetPosition;\n\n                object.rotationAngle = rotation.z; // Rotation around Z-axis\n                object.rotationAxis = glm::vec3(1.0f, 0.0f, 0.0f); // Rotation around X-axis\n            }\n            // if (object.name == \"\") {\n                \n            // }\n        }\n    }\n\n    // Update dynamic objects\n    for (auto& object : utils_scene::sceneObjectsSkybox) {\n        if (!object.isStatic) {\n            if (object.name == \"sky\") {\n                // Keep skybox centered on the camera\n                object.position = cameraPos;\n\n                // Increment the rotation angle based on speed and deltaTime\n                skyboxRotation.currentAngle += skyboxRotation.speedDegrees * deltaTime;\n\n                // Wrap the angle within [0, 360) degrees\n                if (skyboxRotation.currentAngle >= 360.0f) {\n                    skyboxRotation.currentAngle -= 360.0f;\n                }\n\n                // Apply the updated rotation angle to the object\n                object.rotationAngle = skyboxRotation.currentAngle;\n                object.rotationAxis = skyboxRotation.axis;\n\n                // Debug output\n                // std::cout << \"Skybox rotation angle: \" << object.rotationAngle << \" degrees\" << std::endl;\n            }\n        }\n    }\n}\n\n} // namespace utils_game_loop",
    "APP3/utils/scene_object.cpp": "// scene_object.cpp\n#include \"scene_object.hpp\"\n\nnamespace utils_scene\n{\n\n    // **Define** the map for planet spiral parameters\n    std::map<std::string, PlanetSpiralParams> planetSpiralParameters;\n\n    // Base Values\n    const float BASE_EARTH_SPEED = 0.2f;  // Base speed for Earth revolution (arbitrary)\n    const float MIN_DISTANCE = 2.0f;      // Minimum scaled distance (Mercury)\n    const float MAX_DISTANCE = 10.0f;     // Maximum scaled distance (Neptune)\n    const float MIN_HEIGHT = -5.0f;       // Minimum height offset\n    const float MAX_HEIGHT = -30.0f;      // Maximum height offset\n\n    // Relative orbital speed multipliers (scaled from Earth's speed)\n    std::map<std::string, float> speedScale = {\n        {\"mercury\", 4.15f},\n        {\"venus\", 1.63f},\n        {\"venus_atmosphere\", 1.63f},\n        {\"earth\", 1.0f},\n        {\"earth_atmosphere\", 1.0f},\n        {\"mars\", 0.63f},\n        {\"jupiter\", 0.484f},\n        {\"saturn\", 0.334f},\n        {\"saturn_ring\", 0.334f},\n        {\"uranus\", 0.112f},\n        {\"neptune\", 0.066f}\n    };\n\n    // Relative distance multipliers (scaled between MIN_DISTANCE and MAX_DISTANCE)\n    std::map<std::string, float> distanceScale = {\n        {\"mercury\", 0.0f},  // Closest to MIN_DISTANCE\n        {\"venus\", 0.2f},\n        {\"venus_atmosphere\", 0.2f},\n        {\"earth\", 0.3f},\n        {\"earth_atmosphere\", 0.3f},\n        {\"mars\", 0.4f},\n        {\"jupiter\", 0.6f},\n        {\"saturn\", 0.8f},\n        {\"saturn_ring\", 0.8f},\n        {\"uranus\", 0.9f},\n        {\"neptune\", 1.0f}   // Farthest at MAX_DISTANCE\n    };\n\n    // **Initialize Parameters**\n    void initializePlanetSpiralParameters() {\n        for (auto it = speedScale.begin(); it != speedScale.end(); ++it) {\n            const std::string& planet = it->first;\n            float speed = it->second;\n\n            // Interpolate distance and height directly\n            float scaledDistance = MIN_DISTANCE + (MAX_DISTANCE - MIN_DISTANCE) * distanceScale[planet];\n            float scaledHeight = MIN_HEIGHT + (MAX_HEIGHT - MIN_HEIGHT) * distanceScale[planet];\n\n            planetSpiralParameters[planet] = {\n                scaledDistance,               // Scaled Radius\n                BASE_EARTH_SPEED * speed,     // Scaled Speed\n                scaledHeight                  // Scaled Height\n            };\n        }\n    }\n\n    // **Update planet positions dynamically**\n    void updatePlanetPositions(float currentFrame, const glm::vec3& spiralCenter) {\n        for (const auto& pair : planetSpiralParameters) {\n            const std::string& planetName = pair.first;\n            const PlanetSpiralParams& params = pair.second;\n\n            // Calculate new position based on spiral motion\n            glm::vec3 newPosition;\n            newPosition.x = spiralCenter.x + params.spiralRadius * cos(currentFrame * params.spiralSpeed);\n            newPosition.y = spiralCenter.y + params.fixedHeight;\n            newPosition.z = spiralCenter.z + params.spiralRadius * sin(currentFrame * params.spiralSpeed);\n\n            // Apply the new position\n            setObjectPosition(planetName, newPosition);\n        }\n    }\n\n    void updateDisplayPlanetPositions(float currentFrame) {\n        // Default rotation settings for most display planets\n        const float ROTATION_SPEED = 1.3f;\n        const glm::vec3 ROTATION_AXIS = glm::vec3(0.5f, 0.5f, 1.0f);\n\n        // Custom rotation settings for atmosphere displays\n        const float ATMOSPHERE_ROTATION_SPEED = 0.8f; // Slower rotation for atmosphere\n        const glm::vec3 ATMOSPHERE_ROTATION_AXIS = glm::vec3(0.0f, 1.0f, 0.0f); // Vertical rotation\n\n        // List of planet display names\n        std::vector<std::string> displayPlanets = {\n            \"mercury_display\", \"venus_display\", \"venus_atmosphere_display\",\n            \"earth_display\", \"earth_atmosphere_display\", \"mars_display\",\n            \"jupiter_display\", \"saturn_display\", \"saturn_ring_display\",\n            \"uranus_display\", \"neptune_display\"\n        };\n\n        // Apply rotation to each display planet\n        for (const auto &planetName : displayPlanets) {\n            if (planetName == \"earth_atmosphere_display\" || planetName == \"venus_atmosphere_display\") {\n                // Custom rotation for atmospheres\n                float rotationAngle = currentFrame * ATMOSPHERE_ROTATION_SPEED; \n                setObjectRotation(planetName, ATMOSPHERE_ROTATION_AXIS, rotationAngle);\n            } else {\n                // Default rotation for other planets\n                float rotationAngle = currentFrame * ROTATION_SPEED; \n                setObjectRotation(planetName, ROTATION_AXIS, rotationAngle);\n            }\n        }\n    }\n\n    std::vector<SceneObject> sceneObjects;\n    std::vector<SceneObject> sceneObjectsTransparent;\n    std::vector<SceneObject> sceneObjectsSkybox;\n\n    void addCube(const std::string &name,\n                const glm::vec3 &position,\n                const glm::vec3 &scale,\n                const Material &material,\n                const glm::vec3 &rotationAxis,\n                float rotationAngle,\n                GLuint vaoID,\n                GLsizei indexCount,\n                bool isStatic)\n    {\n        SceneObject cube;\n        cube.name = name;\n        cube.type = ObjectType::Cube;\n        cube.position = position;\n        cube.initialPosition = position;\n        cube.scale = scale;\n        cube.rotationAxis = rotationAxis;\n        cube.rotationAngle = rotationAngle;\n        cube.vaoID = vaoID;\n        cube.indexCount = indexCount;\n        cube.isStatic = isStatic;\n\n        // Calculate bounding box\n        glm::vec3 halfSize = scale * 0.5f;\n        cube.boundingBox.min = position - halfSize;\n        cube.boundingBox.max = position + halfSize;\n\n        // Ensure material is reused\n        int materialIndex = MaterialManager::getInstance().findMaterial(material);\n        if (materialIndex == -1) {\n            materialIndex = MaterialManager::getInstance().addOrGetMaterial(material);\n        }\n        cube.materialIndex = materialIndex;\n\n        sceneObjects.push_back(cube);\n    }\n\n    void addTransparentCube(const std::string &name,\n                            const glm::vec3 &position,\n                            const glm::vec3 &scale,\n                            const Material &material,\n                            const glm::vec3 &rotationAxis,\n                            float rotationAngle,\n                            GLuint vaoID,\n                            GLsizei indexCount,\n                            bool isStatic)\n    {\n        SceneObject cube;\n        cube.name = name;\n        cube.type = ObjectType::Cube;\n        cube.position = position;\n        cube.initialPosition = position;\n        cube.scale = scale;\n        cube.rotationAxis = rotationAxis;\n        cube.rotationAngle = rotationAngle;\n        cube.vaoID = vaoID;\n        cube.indexCount = indexCount;\n        cube.isStatic = isStatic;\n\n        // Calculate bounding box\n        glm::vec3 halfSize = scale * 0.5f;\n        cube.boundingBox.min = position - halfSize;\n        cube.boundingBox.max = position + halfSize;\n\n        // Assign material using MaterialManager\n        int materialIndex = MaterialManager::getInstance().findMaterial(material);\n        if (materialIndex == -1) {\n            materialIndex = MaterialManager::getInstance().addOrGetMaterial(material);\n        }\n        cube.materialIndex = materialIndex;\n\n        sceneObjectsTransparent.push_back(cube);\n    }\n\n    void addSphere(const std::string &name,\n                   const glm::vec3 &position,\n                   float radius,\n                   const Material &material,\n                   GLuint vaoID,\n                   GLsizei vertexCount,\n                   bool isStatic)\n    {\n        SceneObject sphereObject;\n        sphereObject.name = name;\n        sphereObject.type = ObjectType::Sphere;\n        sphereObject.position = position;\n        sphereObject.initialPosition = position;\n        sphereObject.scale = glm::vec3(radius);\n        sphereObject.rotationAxis = glm::vec3(0.0f);\n        sphereObject.rotationAngle = 0.0f;\n        sphereObject.vaoID = vaoID;\n        sphereObject.indexCount = vertexCount;\n        sphereObject.isStatic = isStatic;\n\n\n        // Assign material using MaterialManager\n        int materialIndex = MaterialManager::getInstance().findMaterial(material);\n        if (materialIndex == -1) {\n            materialIndex = MaterialManager::getInstance().addOrGetMaterial(material);\n        }\n        sphereObject.materialIndex = materialIndex;\n\n        sceneObjects.push_back(sphereObject);\n    }\n\n    // transparent sphere\n    void addTransparentSphere(const std::string &name,\n                   const glm::vec3 &position,\n                   float radius,\n                   const Material &material,\n                   GLuint vaoID,\n                   GLsizei vertexCount,\n                   bool isStatic)\n    {\n        SceneObject sphereObject;\n        sphereObject.name = name;\n        sphereObject.type = ObjectType::Sphere;\n        sphereObject.position = position;\n        sphereObject.initialPosition = position;\n        // if name is saturn_ring, override the scale, keep the radius for the just the radius, and squish the ring\n        if (name == \"saturn_ring\" || name == \"saturn_ring_display\") {\n            sphereObject.scale = glm::vec3(radius, 0.01f, radius);\n        } else {\n            sphereObject.scale = glm::vec3(radius);\n        }\n        sphereObject.rotationAxis = glm::vec3(0.0f);\n        sphereObject.rotationAngle = 0.0f;\n        sphereObject.vaoID = vaoID;\n        sphereObject.indexCount = vertexCount;\n        sphereObject.isStatic = isStatic;\n\n        // Assign material using MaterialManager\n        int materialIndex = MaterialManager::getInstance().findMaterial(material);\n        if (materialIndex == -1) {\n            materialIndex = MaterialManager::getInstance().addOrGetMaterial(material);\n        }\n        sphereObject.materialIndex = materialIndex;\n\n        sceneObjectsTransparent.push_back(sphereObject);\n    }\n    \n    // add sphere no bounding box\n    void addSkySphere(const std::string &name,\n                   const glm::vec3 &position,\n                   float radius,\n                   const Material &material,\n                   GLuint vaoID,\n                   GLsizei vertexCount,\n                   bool isStatic)\n    {\n        SceneObject sphereObject;\n        sphereObject.name = name;\n        sphereObject.type = ObjectType::Sphere;\n        sphereObject.position = position;\n        sphereObject.initialPosition = position;\n        sphereObject.scale = glm::vec3(radius);\n        sphereObject.rotationAxis = glm::vec3(0.0f);\n        sphereObject.rotationAngle = 0.0f;\n        sphereObject.vaoID = vaoID;\n        sphereObject.indexCount = vertexCount;\n        sphereObject.isStatic = isStatic;\n\n        // Assign material using MaterialManager\n        int materialIndex = MaterialManager::getInstance().findMaterial(material);\n        if (materialIndex == -1) {\n            materialIndex = MaterialManager::getInstance().addOrGetMaterial(material);\n        }\n        sphereObject.materialIndex = materialIndex;\n\n        sceneObjectsSkybox.push_back(sphereObject);\n        // sceneObjects.push_back(sphereObject);\n        // print object name\n        std::cout << \"Skybox sphere name: \" << sphereObject.name << std::endl;\n    }\n\n    void createCompositeCube(const std::string &name,\n                             const glm::vec3 &origin,\n                             const glm::vec3 &size,\n                             const Material &material,\n                             GLuint vaoID,\n                             GLsizei indexCount,\n                             bool isStatic)\n    {\n        int numCubesX = static_cast<int>(size.x);\n        int numCubesY = static_cast<int>(size.y);\n        int numCubesZ = static_cast<int>(size.z);\n\n        for (int x = 0; x < numCubesX; ++x)\n        {\n            for (int y = 0; y < numCubesY; ++y)\n            {\n                for (int z = 0; z < numCubesZ; ++z)\n                {\n                    glm::vec3 position = origin + glm::vec3(x, y, z);\n                    std::string cubeName = name + \"_\" + std::to_string(x) + \"_\" + std::to_string(y) + \"_\" + std::to_string(z);\n                    addCube(\n                        cubeName,        // Name\n                        position,        // Position\n                        glm::vec3(1.0f), // Scale (individual cubes are 1x1x1 units)\n                        material,        // Material\n                        glm::vec3(0.0f), // Rotation axis\n                        0.0f,            // Rotation angle\n                        vaoID,           // VAO ID\n                        indexCount,      // Index count\n                        isStatic         // Is static\n                    );\n                }\n            }\n        }\n    }\n\n    void createTransparentCompositeCube(const std::string &name,\n                                        const glm::vec3 &origin,\n                                        const glm::vec3 &size,\n                                        const Material &material,\n                                        GLuint vaoID,\n                                        GLsizei indexCount,\n                                        bool isStatic)\n    {\n        int numCubesX = static_cast<int>(size.x);\n        int numCubesY = static_cast<int>(size.y);\n        int numCubesZ = static_cast<int>(size.z);\n\n        for (int x = 0; x < numCubesX; ++x)\n        {\n            for (int y = 0; y < numCubesY; ++y)\n            {\n                for (int z = 0; z < numCubesZ; ++z)\n                {\n                    glm::vec3 position = origin + glm::vec3(x, y, z);\n                    std::string cubeName = name + \"_\" + std::to_string(x) + \"_\" + std::to_string(y) + \"_\" + std::to_string(z);\n                    addTransparentCube(\n                        cubeName,        // Name\n                        position,        // Position\n                        glm::vec3(1.0f), // Scale (individual cubes are 1x1x1 units)\n                        material,        // Material\n                        glm::vec3(0.0f), // Rotation axis\n                        0.0f,            // Rotation angle\n                        vaoID,           // VAO ID\n                        indexCount,      // Index count\n                        isStatic         // Is static\n                    );\n                }\n            }\n        }\n    }\n\n    void addModel(const std::string &name,\n                  const glm::vec3 &position,\n                  const glm::vec3 &scale,\n                  const Material &material,\n                  GLuint vaoID,\n                  GLsizei indexCount,\n                  const AABB &boundingBox,\n                  const glm::vec3 &rotationAxis,\n                  float rotationAngle,\n                  bool isStatic)\n    {\n        SceneObject obj;\n        obj.name = name;\n        obj.type = ObjectType::Model;\n        obj.position = position;\n        obj.initialPosition = position;\n        obj.scale = scale;\n        obj.rotationAxis = rotationAxis;\n        obj.rotationAngle = rotationAngle;\n        obj.vaoID = vaoID;\n        obj.indexCount = indexCount;\n        obj.isStatic = isStatic;\n\n        obj.boundingBox = boundingBox;\n\n        // Assign material using MaterialManager\n        int materialIndex = MaterialManager::getInstance().findMaterial(material);\n        if (materialIndex == -1) {\n            materialIndex = MaterialManager::getInstance().addOrGetMaterial(material);\n        }\n        obj.materialIndex = materialIndex;\n\n        sceneObjects.push_back(obj);\n    }\n\n    // getTransparentObjectPosition\n    glm::vec3 getTransparentObjectPosition(const std::string &name)\n    {\n        for (const auto &obj : sceneObjectsTransparent)\n        {\n            if (obj.name == name)\n            {\n                return obj.position;\n            }\n        }\n        return glm::vec3(0.0f);\n    }\n\n    // getObjectPosition\n    glm::vec3 getObjectPosition(const std::string &name)\n    {\n        for (const auto &obj : sceneObjects)\n        {\n            if (obj.name == name)\n            {\n                return obj.position;\n            }\n        }\n        return glm::vec3(0.0f);\n    }\n\n    // setObjectPosition\n    void setObjectPosition(const std::string &name, const glm::vec3 &position)\n    {\n        for (auto &obj : sceneObjects)\n        {\n            if (obj.name == name)\n            {\n                obj.position = position;\n            }\n        }\n        // for transparent objects\n        for (auto &obj : sceneObjectsTransparent)\n        {\n            if (obj.name == name)\n            {\n                obj.position = position;\n            }\n        }\n    }\n\n    // set obect rotation\n    void setObjectRotation(const std::string &name, const glm::vec3 &rotationAxis, float rotationAngle)\n    {\n        for (auto &obj : sceneObjects)\n        {\n            if (obj.name == name)\n            {\n                obj.rotationAxis = rotationAxis;\n                obj.rotationAngle = rotationAngle;\n            }\n        }\n        // for transparent objects\n        for (auto &obj : sceneObjectsTransparent)\n        {\n            if (obj.name == name)\n            {\n                obj.rotationAxis = rotationAxis;\n                obj.rotationAngle = rotationAngle;\n            }\n        }\n    }\n\n} // namespace utils_scene",
    "APP3/utils/sphere.cpp": "#include \"sphere.hpp\"\n#include <glm/glm.hpp>\n\nnamespace utils_object {\n\nsize_t createSphereVertices(std::vector<SphereVertex>& sphereVertices, glimac::Sphere& sphere) {\n    size_t sphereVertexCount = sphere.getVertexCount();\n    const glimac::ShapeVertex* sphereData = sphere.getDataPointer();\n    sphereVertices.resize(sphereVertexCount);\n\n    for (size_t i = 0; i < sphereVertexCount; ++i) {\n        sphereVertices[i].position = sphereData[i].position;\n        sphereVertices[i].normal = sphereData[i].normal;\n        sphereVertices[i].texCoords = sphereData[i].texCoords;\n        sphereVertices[i].tangent = glm::vec3(0.0f);\n        sphereVertices[i].bitangent = glm::vec3(0.0f);\n    }\n\n    return sphereVertexCount; // Return the vertex count\n}\n\nvoid computeSphereTangents(std::vector<SphereVertex>& vertices) {\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::vec3(0.0f);\n        vertex.bitangent = glm::vec3(0.0f);\n    }\n\n    for (size_t i = 0; i < vertices.size(); i += 3) {\n        SphereVertex& v0 = vertices[i];\n        SphereVertex& v1 = vertices[i + 1];\n        SphereVertex& v2 = vertices[i + 2];\n\n        glm::vec3 edge1 = v1.position - v0.position;\n        glm::vec3 edge2 = v2.position - v0.position;\n\n        glm::vec2 deltaUV1 = v1.texCoords - v0.texCoords;\n        glm::vec2 deltaUV2 = v2.texCoords - v0.texCoords;\n\n        float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n\n        glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\n        glm::vec3 bitangent = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);\n\n        v0.tangent += tangent;\n        v1.tangent += tangent;\n        v2.tangent += tangent;\n\n        v0.bitangent += bitangent;\n        v1.bitangent += bitangent;\n        v2.bitangent += bitangent;\n    }\n\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::normalize(vertex.tangent);\n        vertex.bitangent = glm::normalize(vertex.bitangent);\n    }\n}\n\nvoid setupSphereBuffers(const std::vector<SphereVertex>& sphereVertices, GLuint& sphereVBO, GLuint& sphereVAO) {\n    glGenBuffers(1, &sphereVBO);\n    glGenVertexArrays(1, &sphereVAO);\n\n    glBindVertexArray(sphereVAO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, sphereVBO);\n    glBufferData(GL_ARRAY_BUFFER, sphereVertices.size() * sizeof(SphereVertex), sphereVertices.data(), GL_STATIC_DRAW);\n\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, position));\n\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, normal));\n\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, texCoords));\n\n    glEnableVertexAttribArray(3);\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, tangent));\n\n    glEnableVertexAttribArray(4);\n    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, bitangent));\n\n    glBindVertexArray(0);\n}\n\n} // namespace utils_object",
    "APP3/utils/global.cpp": "#include \"global.hpp\"\n\n// Window dimensions\nint window_width = 1600;\nint window_height = 1000;\n\n// Stone floor coordinates\nint numCubesX = 15;    // Number of cubes along the x-axis\nint numCubesZ = 15;    // Number of cubes along the z-axis\nfloat spacingX = 1.0f; // Distance between each cube along the x-axis\nfloat spacingZ = 1.0f; // Distance between each cube along the z-axis\n\nconst GLuint SHADOW_WIDTH = 4096, SHADOW_HEIGHT = 4096;\n\nfloat cameraRadius = 0.15f; // Radius of the camera sphere for collision detection\nfloat cameraHeight = 2.0f;  // Height of the camera cylinder\n\nbool isRockingChairPaused = false;\ndouble rockingChairPausedTime = 0.0;\ndouble rockingChairStartTime = 0.0;\n\nbool isLightPaused = false;\n\nfloat sensitivity = 0.1f;\nfloat currentFrame = 0.0f;\n\nint MAX_ADDITIONAL_LIGHTS = 100; // Maximum number of additional lights excluding the main point light which has shadows\n\nbool wireframeMode = false;\n\n// Define color masks for RGB channels\nglm::vec3 colorMasks[3] = {\n    glm::vec3(1.0f, 0.0f, 0.0f), // Red\n    glm::vec3(0.0f, 1.0f, 0.0f), // Green\n    glm::vec3(0.0f, 0.0f, 1.0f)  // Blue\n};",
    "APP3/utils/texture.hpp": "#ifndef TEXTURE_HPP\n#define TEXTURE_HPP\n\n#include <string>\n#include <map>\n#include <glad/glad.h>\n\nextern std::map<std::string, GLuint> textures;\n\nGLuint loadTexture(const std::string& texturePath);\n\nGLuint loadTextureBall(const std::string& texturePath);\n\n#endif // TEXTURE_HPP",
    "APP3/utils/pointer.hpp": "#pragma once\n\n#include <cstddef>\n#include <memory>\n#include <type_traits>\n#include <utility>\n\nnamespace std {\n    template<class T> struct _Unique_if {\n        typedef unique_ptr<T> _Single_object;\n    };\n\n    template<class T> struct _Unique_if<T[]> {\n        typedef unique_ptr<T[]> _Unknown_bound;\n    };\n\n    template<class T, size_t N> struct _Unique_if<T[N]> {\n        typedef void _Known_bound;\n    };\n\n    template<class T, class... Args>\n        typename _Unique_if<T>::_Single_object\n        make_unique(Args&&... args) {\n            return unique_ptr<T>(new T(std::forward<Args>(args)...));\n        }\n\n    template<class T>\n        typename _Unique_if<T>::_Unknown_bound\n        make_unique(size_t n) {\n            typedef typename remove_extent<T>::type U;\n            return unique_ptr<T>(new U[n]());\n        }\n\n    template<class T, class... Args>\n        typename _Unique_if<T>::_Known_bound\n        make_unique(Args&&...) = delete;\n}",
    "APP3/utils/texture.cpp": "#include \"texture.hpp\"\n#include <iostream>\n#include <glimac/Image.hpp>\n#include <glm/glm.hpp>\n\nstd::map<std::string, GLuint> textures;\n\nGLuint loadTexture(const std::string& texturePath) {\n    if (textures.find(texturePath) != textures.end()) {\n        return textures[texturePath];\n    }\n\n    std::unique_ptr<glimac::Image> pImage = glimac::loadImage(texturePath);\n    if (!pImage) {\n        std::cerr << \"Failed to load texture image at \" << texturePath << std::endl;\n        return 0;\n    }\n\n    size_t width = pImage->getWidth();\n    size_t height = pImage->getHeight();\n    glm::vec4* pixels = pImage->getPixels();\n\n    for (size_t row = 0; row < height / 2; ++row) {\n        for (size_t col = 0; col < width; ++col) {\n            size_t topIndex = row * width + col;\n            size_t bottomIndex = (height - 1 - row) * width + col;\n            std::swap(pixels[topIndex], pixels[bottomIndex]);\n        }\n    }\n\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pImage->getWidth(), pImage->getHeight(), 0, GL_RGBA, GL_FLOAT, pImage->getPixels());\n    glGenerateMipmap(GL_TEXTURE_2D);\n\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    textures[texturePath] = textureID;\n    return textureID;\n}\n\nGLuint loadTextureBall(const std::string& texturePath) {\n    if (textures.find(texturePath) != textures.end()) {\n        return textures[texturePath];\n    }\n\n    std::unique_ptr<glimac::Image> pImage = glimac::loadImage(texturePath);\n    if (!pImage) {\n        std::cerr << \"Failed to load texture image at \" << texturePath << std::endl;\n        return 0;\n    }\n\n    size_t width = pImage->getWidth();\n    size_t height = pImage->getHeight();\n    glm::vec4* pixels = pImage->getPixels();\n\n    // no flip for balls\n    // for (size_t row = 0; row < height / 2; ++row) {\n    //     for (size_t col = 0; col < width; ++col) {\n    //         size_t topIndex = row * width + col;\n    //         size_t bottomIndex = (height - 1 - row) * width + col;\n    //         std::swap(pixels[topIndex], pixels[bottomIndex]);\n    //     }\n    // }\n\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pImage->getWidth(), pImage->getHeight(), 0, GL_RGBA, GL_FLOAT, pImage->getPixels());\n    glGenerateMipmap(GL_TEXTURE_2D);\n\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    textures[texturePath] = textureID;\n    return textureID;\n}",
    "APP3/utils/shader.hpp": "#ifndef SHADER_HPP\n#define SHADER_HPP\n\n#include <glimac/Program.hpp>\n#include <string>\n\nnamespace utils_loader {\n\nclass Shader {\npublic:\n    Shader(const std::string& vertexPath, const std::string& fragmentPath);\n\n    // ~Shader();\n\n    void use() const;\n    GLuint getID() const;\n    GLint getUniformLocation(const std::string& name) const;\n    GLuint getGLId() const;\n\n    // void deleteProgram();\n\nprivate:\n    glimac::Program m_program;\n};\n\n} // namespace utils_loader\n\n#endif // SHADER_HPP",
    "APP3/utils/models.cpp": "#include \"models.hpp\"\n#include <src/tiny_obj_loader.h>\n#include <src/stb_image.h>\n#include <iostream>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/constants.hpp> \n#include <cmath> \n\nnamespace utils_object {\n\nstd::vector<GLuint> allTextures;\n\nvoid GetRockingChairPositionAndRotation(\n    double currentTime,\n    double frequency,\n    double radius,\n    double length,\n    glm::vec3& position,\n    glm::vec3& rotation)\n{\n    // Calculate angular frequency and time-dependent angle for rolling motion\n    double omega = 2.0 * glm::pi<double>() * frequency; // Angular frequency\n    double displacement = length * 0.5 * sin(omega * currentTime); // Point P's back and forth motion, clamped to [-length/2, length/2]\n\n    // Compute the angle of rotation based on the displacement of point P\n    double theta = displacement / radius; // Rotation angle in radians, derived from s = r * theta\n\n    // Set position (displacement along the X-axis, assuming rolling along X-axis)\n    position = glm::vec3(0.0, 0.0, -displacement); // Adjust axes as necessary for your specific setup\n\n    // Set rotation around the Z-axis to simulate rolling (assuming circle rolls along X-axis)\n    rotation = glm::vec3(0.0, 0.0, -1.0 * static_cast<float>(glm::degrees(theta))); // Convert theta to degrees for rotation\n}\n\nGLuint LoadTextureFromFile(const char* path) {\n    int width, height, nrComponents;\n    unsigned char *data = stbi_load(path, &width, &height, &nrComponents, 0);\n    if (data) {\n        GLenum format = GL_RGB;\n        if (nrComponents == 1)\n            format = GL_RED;\n        else if (nrComponents == 3)\n            format = GL_RGB;\n        else if (nrComponents == 4)\n            format = GL_RGBA;\n\n        GLuint textureID;\n        glGenTextures(1, &textureID);\n        glBindTexture(GL_TEXTURE_2D, textureID);\n        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);\n        glGenerateMipmap(GL_TEXTURE_2D);\n\n        // Set texture parameters (wrapping, filtering)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\t\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\t\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n        stbi_image_free(data);\n\n        // print ID\n        std::cout << \"Texture ID: \" << textureID << std::endl;\n\n        // register the texture, easier for cleanup\n        allTextures.push_back(textureID);\n\n        return textureID;\n    } else {\n        std::cerr << \"Texture failed to load at path: \" << path << std::endl;\n        stbi_image_free(data);\n        return 0;\n    }\n}\n\nvoid computeTangents(ModelData &model) {\n    size_t vertexCount = model.vertices.size() / 3;\n    size_t indexCount = model.indices.size();\n\n    // Initialize tangents and bitangents\n    model.tangents.assign(vertexCount * 3, 0.0f);\n    model.bitangents.assign(vertexCount * 3, 0.0f);\n\n    // Iterate over each triangle\n    for (size_t i = 0; i < indexCount; i += 3) {\n        unsigned int index0 = model.indices[i];\n        unsigned int index1 = model.indices[i + 1];\n        unsigned int index2 = model.indices[i + 2];\n\n        // Positions\n        glm::vec3 pos0(model.vertices[index0 * 3 + 0], model.vertices[index0 * 3 + 1], model.vertices[index0 * 3 + 2]);\n        glm::vec3 pos1(model.vertices[index1 * 3 + 0], model.vertices[index1 * 3 + 1], model.vertices[index1 * 3 + 2]);\n        glm::vec3 pos2(model.vertices[index2 * 3 + 0], model.vertices[index2 * 3 + 1], model.vertices[index2 * 3 + 2]);\n\n        // Texture coordinates\n        glm::vec2 uv0(model.texcoords[index0 * 2 + 0], model.texcoords[index0 * 2 + 1]);\n        glm::vec2 uv1(model.texcoords[index1 * 2 + 0], model.texcoords[index1 * 2 + 1]);\n        glm::vec2 uv2(model.texcoords[index2 * 2 + 0], model.texcoords[index2 * 2 + 1]);\n\n        // Edges of the triangle\n        glm::vec3 edge1 = pos1 - pos0;\n        glm::vec3 edge2 = pos2 - pos0;\n\n        glm::vec2 deltaUV1 = uv1 - uv0;\n        glm::vec2 deltaUV2 = uv2 - uv0;\n\n        float f = 1.0f;\n        float denominator = (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n        if (denominator != 0.0f) {\n            f = 1.0f / denominator;\n        }\n\n        glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\n        glm::vec3 bitangent = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);\n\n        // Accumulate the tangents and bitangents\n        for (int j = 0; j < 3; ++j) {\n            unsigned int idx = model.indices[i + j];\n            model.tangents[idx * 3 + 0] += tangent.x;\n            model.tangents[idx * 3 + 1] += tangent.y;\n            model.tangents[idx * 3 + 2] += tangent.z;\n\n            model.bitangents[idx * 3 + 0] += bitangent.x;\n            model.bitangents[idx * 3 + 1] += bitangent.y;\n            model.bitangents[idx * 3 + 2] += bitangent.z;\n        }\n    }\n\n    // Normalize the tangents and bitangents\n    for (size_t i = 0; i < vertexCount; ++i) {\n        glm::vec3 tangent(model.tangents[i * 3 + 0], model.tangents[i * 3 + 1], model.tangents[i * 3 + 2]);\n        tangent = glm::normalize(tangent);\n        model.tangents[i * 3 + 0] = tangent.x;\n        model.tangents[i * 3 + 1] = tangent.y;\n        model.tangents[i * 3 + 2] = tangent.z;\n\n        glm::vec3 bitangent(model.bitangents[i * 3 + 0], model.bitangents[i * 3 + 1], model.bitangents[i * 3 + 2]);\n        bitangent = glm::normalize(bitangent);\n        model.bitangents[i * 3 + 0] = bitangent.x;\n        model.bitangents[i * 3 + 1] = bitangent.y;\n        model.bitangents[i * 3 + 2] = bitangent.z;\n    }\n}\n\nvoid centerModel(ModelData& modelData) {\n    // Compute the centroid of the model\n    glm::vec3 centroid(0.0f);\n    size_t vertexCount = modelData.vertices.size() / 3;\n\n    for (size_t i = 0; i < vertexCount; ++i) {\n        centroid.x += modelData.vertices[3 * i + 0];\n        centroid.y += modelData.vertices[3 * i + 1];\n        centroid.z += modelData.vertices[3 * i + 2];\n    }\n    centroid /= static_cast<float>(vertexCount);\n\n    // Find the minimum Z (height) value among all vertices\n    float minZ = std::numeric_limits<float>::max();\n    for (size_t i = 0; i < vertexCount; ++i) {\n        minZ = std::min(minZ, modelData.vertices[3 * i + 2]);\n    }\n\n    // Calculate the height adjustment needed to move the centroid to the minimum Z height\n    float heightAdjustment = centroid.z - minZ;\n\n    // Translate vertices to move the centroid to (centroid.x, centroid.y, minZ)\n    for (size_t i = 0; i < vertexCount; ++i) {\n        modelData.vertices[3 * i + 0] -= centroid.x; // Center X\n        modelData.vertices[3 * i + 1] -= centroid.y; // Center Y\n        modelData.vertices[3 * i + 2] -= heightAdjustment; // Move Z to minZ\n    }\n}\n\nbool loadOBJ(const std::string& filePath, const std::string& basePath, ModelData& modelData) {\n    // Use the older tinyobj loader function\n    std::vector<tinyobj::shape_t> shapes;\n    std::vector<tinyobj::material_t> materials;\n    std::string err = tinyobj::LoadObj(shapes, materials, filePath.c_str(), basePath.empty() ? nullptr : basePath.c_str());\n    \n    if (!err.empty()) {\n        std::cerr << \"TinyOBJLoader Error: \" << err << std::endl;\n        return false;\n    }\n\n    // Clear existing model data\n    modelData.vertices.clear();\n    modelData.normals.clear();\n    modelData.texcoords.clear();\n    modelData.indices.clear();\n    modelData.tangents.clear();\n    modelData.bitangents.clear();\n    modelData.materialToTexture.clear();\n    modelData.shapes.clear();\n    modelData.materials.clear();\n\n    // For deduplicating (position/normal/uv)\n    struct Vertex {\n        glm::vec3 position;\n        glm::vec3 normal;\n        glm::vec2 texcoord;\n    };\n    struct VertexHash {\n        size_t operator()(const Vertex& v) const {\n            // Simple hash combining floats (not ideal for production)\n            auto h1 = std::hash<float>()(v.position.x) ^ std::hash<float>()(v.position.y) ^ std::hash<float>()(v.position.z);\n            auto h2 = std::hash<float>()(v.normal.x) ^ std::hash<float>()(v.normal.y) ^ std::hash<float>()(v.normal.z);\n            auto h3 = std::hash<float>()(v.texcoord.x) ^ std::hash<float>()(v.texcoord.y);\n            return h1 ^ (h2 << 1) ^ (h3 << 2);\n        }\n    };\n    struct VertexEq {\n        bool operator()(const Vertex& a, const Vertex& b) const {\n            return a.position == b.position &&\n                   a.normal   == b.normal &&\n                   a.texcoord == b.texcoord;\n        }\n    };\n\n    std::unordered_map<Vertex, unsigned int, VertexHash, VertexEq> uniqueVertices;\n\n    // Populate model data from each shape\n    for (size_t s = 0; s < shapes.size(); s++) {\n        const auto& mesh = shapes[s].mesh;\n        for (size_t i = 0; i < mesh.indices.size(); i++) {\n            unsigned int idx = mesh.indices[i];\n\n            // Read position\n            glm::vec3 position(0.0f);\n            if (!mesh.positions.empty()) {\n                position.x = mesh.positions[3 * idx + 0];\n                position.y = mesh.positions[3 * idx + 1];\n                position.z = mesh.positions[3 * idx + 2];\n            }\n\n            // Read normal\n            glm::vec3 normal(0.0f);\n            if (!mesh.normals.empty()) {\n                normal.x = mesh.normals[3 * idx + 0];\n                normal.y = mesh.normals[3 * idx + 1];\n                normal.z = mesh.normals[3 * idx + 2];\n            }\n\n            // Read texcoord\n            glm::vec2 texcoord(0.0f);\n            if (!mesh.texcoords.empty()) {\n                texcoord.x = mesh.texcoords[2 * idx + 0];\n                texcoord.y = mesh.texcoords[2 * idx + 1];\n            }\n\n            Vertex vertex{position, normal, texcoord};\n\n            // Avoid duplicates\n            if (uniqueVertices.count(vertex) == 0) {\n                uniqueVertices[vertex] = static_cast<unsigned int>(modelData.vertices.size() / 3);\n\n                // Store position\n                modelData.vertices.push_back(position.x);\n                modelData.vertices.push_back(position.y);\n                modelData.vertices.push_back(position.z);\n\n                // Store normal\n                modelData.normals.push_back(normal.x);\n                modelData.normals.push_back(normal.y);\n                modelData.normals.push_back(normal.z);\n\n                // Store texcoord\n                modelData.texcoords.push_back(texcoord.x);\n                modelData.texcoords.push_back(texcoord.y);\n\n                // Initialize tangent/bitangent\n                modelData.tangents.push_back(0.0f);\n                modelData.tangents.push_back(0.0f);\n                modelData.tangents.push_back(0.0f);\n\n                modelData.bitangents.push_back(0.0f);\n                modelData.bitangents.push_back(0.0f);\n                modelData.bitangents.push_back(0.0f);\n            }\n            modelData.indices.push_back(uniqueVertices[vertex]);\n        }\n    }\n\n    // Compute normals if they're missing/zero\n    if (modelData.normals.empty() || modelData.normals[0] == 0.0f) {\n        size_t numFaces = modelData.indices.size() / 3;\n        for (size_t i = 0; i < numFaces; i++) {\n            unsigned int i0 = modelData.indices[3*i + 0];\n            unsigned int i1 = modelData.indices[3*i + 1];\n            unsigned int i2 = modelData.indices[3*i + 2];\n            \n            glm::vec3 v0(modelData.vertices[3*i0 + 0], modelData.vertices[3*i0 + 1], modelData.vertices[3*i0 + 2]);\n            glm::vec3 v1(modelData.vertices[3*i1 + 0], modelData.vertices[3*i1 + 1], modelData.vertices[3*i1 + 2]);\n            glm::vec3 v2(modelData.vertices[3*i2 + 0], modelData.vertices[3*i2 + 1], modelData.vertices[3*i2 + 2]);\n            \n            glm::vec3 normal = glm::normalize(glm::cross(v1 - v0, v2 - v0));\n            for (int j = 0; j < 3; j++) {\n                auto idx = modelData.indices[3*i + j];\n                modelData.normals[3*idx + 0] += normal.x;\n                modelData.normals[3*idx + 1] += normal.y;\n                modelData.normals[3*idx + 2] += normal.z;\n            }\n        }\n        // Normalize them\n        for (size_t i = 0; i < modelData.vertices.size() / 3; i++) {\n            glm::vec3 n(modelData.normals[3*i+0], modelData.normals[3*i+1], modelData.normals[3*i+2]);\n            n = glm::normalize(n);\n            modelData.normals[3*i+0] = n.x;\n            modelData.normals[3*i+1] = n.y;\n            modelData.normals[3*i+2] = n.z;\n        }\n    }\n\n    // Load textures\n    for (size_t i = 0; i < materials.size(); i++) {\n        tinyobj::material_t& mat = materials[i];\n        if (!mat.diffuse_texname.empty()) {\n            std::string texturePath = basePath + mat.diffuse_texname;\n            GLuint texID = LoadTextureFromFile(texturePath.c_str()); // Your custom function\n            modelData.materialToTexture[i] = texID;\n        } else {\n            modelData.materialToTexture[i] = 0;\n        }\n    }\n\n    // Store shapes/materials\n    modelData.shapes = shapes;\n    modelData.materials = materials;\n\n    // Compute tangents (if you have a function for that)\n    computeTangents(modelData);\n\n    // Center or transform the model as you wish\n    // centerModel(modelData);\n\n    return true;\n}\n\nvoid setupModelBuffers(ModelData &modelData) {\n    glGenVertexArrays(1, &modelData.vao);\n    glGenBuffers(1, &modelData.vbo);\n    glGenBuffers(1, &modelData.ebo);\n\n    glBindVertexArray(modelData.vao);\n\n    // Interleave data: Position (3) + Normal (3) + Texcoord (2) + Tangent (3) + Bitangent (3)\n    std::vector<float> interleavedData;\n    size_t numVertices = modelData.vertices.size() / 3; // Assuming positions are x,y,z\n\n    for (size_t i = 0; i < numVertices; ++i) {\n        // Positions (x, y, z)\n        interleavedData.push_back(modelData.vertices[3 * i]);\n        interleavedData.push_back(modelData.vertices[3 * i + 1]);\n        interleavedData.push_back(modelData.vertices[3 * i + 2]);\n\n        // Normals (nx, ny, nz)\n        interleavedData.push_back(modelData.normals[3 * i]);\n        interleavedData.push_back(modelData.normals[3 * i + 1]);\n        interleavedData.push_back(modelData.normals[3 * i + 2]);\n\n        // Texture Coordinates (u, v)\n        interleavedData.push_back(modelData.texcoords[2 * i]);\n        interleavedData.push_back(modelData.texcoords[2 * i + 1]);\n\n        // Tangents (tx, ty, tz)\n        interleavedData.push_back(modelData.tangents[3 * i]);\n        interleavedData.push_back(modelData.tangents[3 * i + 1]);\n        interleavedData.push_back(modelData.tangents[3 * i + 2]);\n\n        // Bitangents (bx, by, bz)\n        interleavedData.push_back(modelData.bitangents[3 * i]);\n        interleavedData.push_back(modelData.bitangents[3 * i + 1]);\n        interleavedData.push_back(modelData.bitangents[3 * i + 2]);\n    }\n\n    // Upload interleaved data to VBO\n    glBindBuffer(GL_ARRAY_BUFFER, modelData.vbo);\n    glBufferData(GL_ARRAY_BUFFER, interleavedData.size() * sizeof(float), interleavedData.data(), GL_STATIC_DRAW);\n\n    // Upload index data to EBO\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, modelData.ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, modelData.indices.size() * sizeof(unsigned int), modelData.indices.data(), GL_STATIC_DRAW);\n\n    // Set up vertex attributes\n    GLsizei stride = (3 + 3 + 2 + 3 + 3) * sizeof(float); // Position, Normal, Texcoord, Tangent, Bitangent\n    size_t offset = 0;\n\n    // Position attribute (location = 0)\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    // Normal attribute (location = 1)\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    // Texture Coordinate attribute (location = 2)\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 2 * sizeof(float);\n\n    // Tangent attribute (location = 3)\n    glEnableVertexAttribArray(3);\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    // Bitangent attribute (location = 4)\n    glEnableVertexAttribArray(4);\n    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    glBindVertexArray(0);\n}\n\n} // namespace utils_scene",
    "APP3/utils/utilities.cpp": "#include \"utilities.hpp\"\n#include \"global.hpp\"\n\n\n#include <glm/glm.hpp>\n#include <cstdlib>\n\n#include <iostream>\n\nfloat randomFloat() {\n    return static_cast<float>(rand()) / static_cast<float>(RAND_MAX);\n}\n\nglm::vec3 randomColor() {\n    return glm::vec3(0.6f);\n}\n\nAABB computeAABB(const std::vector<float>& vertices) {\n    if (vertices.empty()) {\n        return AABB(glm::vec3(0.0f), glm::vec3(0.0f));\n    }\n    \n    glm::vec3 minVertex(vertices[0], vertices[1], vertices[2]);\n    glm::vec3 maxVertex = minVertex;\n    \n    for (size_t i = 3; i < vertices.size(); i += 3) {\n        glm::vec3 vertex(vertices[i], vertices[i + 1], vertices[i + 2]);\n        minVertex = glm::min(minVertex, vertex);\n        maxVertex = glm::max(maxVertex, vertex);\n    }\n    \n    return AABB(minVertex, maxVertex);\n}\n\nnamespace utils_game_loop {\n\nvoid eventHandler(glimac::SDLWindowManager &windowManager, bool &done, bool &isRockingChairPaused, double &rockingChairStartTime, double &rockingChairPausedTime, float &yaw, float &pitch, glm::vec3 &cameraFront, float &currentFrame) {\n\n    // Event handling\n    SDL_Event e;\n    while (windowManager.pollEvent(e))\n    {\n    if (e.type == SDL_QUIT)\n        {\n            done = true;\n        }\n        if (e.type == SDL_KEYDOWN)\n        {\n            if (e.key.keysym.sym == SDLK_ESCAPE)\n            {\n                done = true;\n            }\n            else if (e.key.keysym.sym == SDLK_t)\n            {\n                isRockingChairPaused = !isRockingChairPaused;\n                if (isRockingChairPaused)\n                {\n                    // Record the time when paused\n                    rockingChairPausedTime = currentFrame;\n                }\n                else\n                {\n                    // Adjust the start time when unpausing\n                    double pauseDuration = currentFrame - rockingChairPausedTime;\n                    rockingChairStartTime += pauseDuration;\n                }\n            }\n            else if (e.key.keysym.sym == SDLK_y)\n            {\n                wireframeMode = !wireframeMode;\n                glPolygonMode(GL_FRONT_AND_BACK, wireframeMode ? GL_LINE : GL_FILL);\n            }\n            else if (e.key.keysym.sym == SDLK_r)\n            {\n                isLightPaused = !isLightPaused;\n            }\n        }\n\n        // Mouse movement\n        if (e.type == SDL_MOUSEMOTION)\n        {\n            float xpos = e.motion.xrel;\n            float ypos = e.motion.yrel;\n\n            xpos *= sensitivity;\n            ypos *= sensitivity;\n\n            yaw += xpos;\n            pitch -= ypos; // Invert y-axis if necessary\n\n            // Constrain pitch\n            if (pitch > 89.0f)\n                pitch = 89.0f;\n            if (pitch < -89.0f)\n                pitch = -89.0f;\n\n            // Update camera front vector\n            glm::vec3 front;\n            front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));\n            front.y = sin(glm::radians(pitch));\n            front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));\n            cameraFront = glm::normalize(front);\n        }\n    }\n}\n\n} // namespace utils_game_loop",
    "APP3/utils/global.hpp": "#ifndef GLOBAL_HPP\n#define GLOBAL_HPP\n\n#include <glad/glad.h>\n#include <glm/glm.hpp>\n\n// Window dimensions\nextern int window_width;\nextern int window_height;\n\n// Stone floor coordinates\nextern int numCubesX;\nextern int numCubesZ;\nextern float spacingX;\nextern float spacingZ;\n\nextern const GLuint SHADOW_WIDTH;\nextern const GLuint SHADOW_HEIGHT;\n\nextern float cameraRadius; // Radius of the camera sphere for collision detection\nextern float cameraHeight; // Height of the camera cylinder\n\nextern bool isRockingChairPaused;\nextern double rockingChairPausedTime;\nextern double rockingChairStartTime;\n\nextern bool isLightPaused;\n\nextern float sensitivity;\nextern float currentFrame;\n\nextern int MAX_ADDITIONAL_LIGHTS;\n\nextern bool wireframeMode;\n\n// Structure for 3D vertices with position, normal, and texture coordinates\nstruct Vertex3D {\n    glm::vec3 position;  // Vertex position\n    glm::vec3 normal;    // Vertex normal\n    glm::vec2 texCoords; // Texture coordinates\n    glm::vec3 tangent;\n    glm::vec3 bitangent;\n\n    Vertex3D(const glm::vec3& pos, const glm::vec3& norm, const glm::vec2& uv)\n        : position(pos), normal(norm), texCoords(uv), tangent(0.0f), bitangent(0.0f) {}\n};\n\nstruct SphereVertex {\n    glm::vec3 position;\n    glm::vec3 normal;\n    glm::vec2 texCoords;\n    glm::vec3 tangent;\n    glm::vec3 bitangent;\n};\n\n// Define color masks for RGB channels\nextern glm::vec3 colorMasks[3];\n\n#endif // GLOBAL_HPP",
    "APP3/utils/cube.hpp": "#ifndef CUBE_HPP\n#define CUBE_HPP\n\n#include \"global.hpp\"\n#include <vector>\n\nnamespace utils_object {\n\nvoid createCube(std::vector<Vertex3D>& vertices, std::vector<GLuint>& indices);\nvoid computeCubeTangents(std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices);\nvoid setupCubeBuffers(const std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices, GLuint& cubeVBO, GLuint& cubeEBO, GLuint& cubeVAO);\n\n}\n\n#endif // CUBE_HPP",
    "APP3/utils/rendering.hpp": "#ifndef RENDERING_HPP\n#define RENDERING_HPP\n\n#include <glm/glm.hpp>\n#include <vector>\n#include \"utils/scene_object.hpp\"\n#include \"utils/utilities.hpp\"\n#include \"utils/scene_object.hpp\"\n#include \"utils/models.hpp\"\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils_game_loop {\n\nstruct RotationParams {\n    glm::vec3 axis;        // Rotation axis\n    float speedDegrees;    // Rotation speed in degrees per second\n    float currentAngle;    // Current rotation angle in degrees\n};\n\n// Initialize rotation parameters for the skybox\nstatic RotationParams skyboxRotation = {\n    glm::normalize(glm::vec3(0.1f, 0.1f, 1.0f)), // Slightly off Z-axis for natural rotation\n    0.5f,                                       // 15 degrees per second\n    150.0f                                       // Starting at 150 degrees\n};\n\nvoid dynamic_loop(float &deltaTime, float &lastFrame, float &currentFrame,\n                  glimac::SDLWindowManager &windowManager, glm::vec3 &cameraPos,\n                  glm::vec3 &cameraFront, glm::vec3 &cameraUp, float cameraSpeed,\n                  bool &done, bool &isRockingChairPaused, double &rockingChairStartTime,\n                  double &rockingChairPausedTime, float &yaw, float &pitch, float cameraRadius,\n                  double frequency, double radius, double length,\n                  float cameraHeight);\n\n\n\n} // namespace utils_game_loop\n\n#endif // RENDERING_HPP",
    "APP3/utils/material.hpp": "#ifndef MATERIAL_HPP\n#define MATERIAL_HPP\n\n#include <glm/glm.hpp>\n#include \"utils/global.hpp\"\n\nstruct Material\n{\n    // Diffuse properties\n    glm::vec3 Kd;        // Diffuse color\n    bool hasDiffuseMap;  // Flag to indicate if diffuse map is used\n    GLuint diffuseMapID; // Diffuse texture ID\n\n    // Specular properties\n    glm::vec3 Ks;         // Specular color\n    float shininess;      // Shininess exponent\n    bool hasSpecularMap;  // Flag to indicate if specular map is used\n    GLuint specularMapID; // Specular texture ID\n\n    // Normal mapping\n    bool hasNormalMap;  // Flag to indicate if normal map is used\n    GLuint normalMapID; // Normal texture ID\n\n    float alpha = 1.0f; // Transparency\n\n    bool operator==(const Material& other) const {\n        return Kd == other.Kd &&\n            hasDiffuseMap == other.hasDiffuseMap &&\n            diffuseMapID == other.diffuseMapID &&\n            Ks == other.Ks &&\n            shininess == other.shininess &&\n            hasSpecularMap == other.hasSpecularMap &&\n            specularMapID == other.specularMapID &&\n            hasNormalMap == other.hasNormalMap &&\n            normalMapID == other.normalMapID &&\n            alpha == other.alpha;\n    }\n\n    // Constructor with default values\n    Material()\n        : Kd(1.0f, 1.0f, 1.0f),\n          hasDiffuseMap(false),\n          diffuseMapID(0),\n          Ks(0.3f, 0.3f, 0.3f),\n          shininess(32.0f),\n          hasSpecularMap(false),\n          specularMapID(0),\n          hasNormalMap(false),\n          normalMapID(0),\n          alpha(1.0f) {}\n\n    // destructor\n    ~Material() {}\n    \n};\n\n#endif // MATERIAL_HPP",
    "APP3/utils/lights.cpp": "#include \"lights.hpp\"\n\nnamespace utils_light\n{\n\n    // A simple static function-scope variable to auto-increment IDs\n    // Each call returns a new unique integer ID\n    int generateLightID()\n    {\n        static int s_nextLightID = 0;\n        return s_nextLightID++;\n    }\n\n    // Adds a new light to the container\n    // Returns the newly generated light ID\n    int addLight(std::vector<SimplePointLight> &lights,\n                 const glm::vec3 &position,\n                 const glm::vec3 &color,\n                 float intensity)\n    {\n        SimplePointLight light;\n        light.id = generateLightID();\n        light.position = position;\n        light.color = color;\n        light.intensity = intensity;\n\n        lights.push_back(light);\n        return light.id; // Return the assigned ID\n    }\n\n    // Removes a light from the container by ID\n    // Returns true if found and removed, false otherwise\n    bool removeLight(std::vector<SimplePointLight> &lights, int lightID)\n    {\n        for (auto it = lights.begin(); it != lights.end(); ++it)\n        {\n            if (it->id == lightID)\n            {\n                lights.erase(it);\n                return true;\n            }\n        }\n        return false; // Not found\n    }\n\n    // Update a light's position by ID\n    void updateLightPosition(std::vector<SimplePointLight> &lights, int lightID, const glm::vec3 &newPosition)\n    {\n        for (auto &light : lights)\n        {\n            if (light.id == lightID)\n            {\n                light.position = newPosition;\n                break;\n            }\n        }\n    }\n\n    // Update a light\u2019s color by ID\n    void updateLightColor(std::vector<SimplePointLight> &lights, int lightID, const glm::vec3 &newColor)\n    {\n        for (auto &light : lights)\n        {\n            if (light.id == lightID)\n            {\n                light.color = newColor;\n                break;\n            }\n        }\n    }\n\n    // Update a light\u2019s intensity by ID\n    void updateLightIntensity(std::vector<SimplePointLight> &lights, int lightID, float newIntensity)\n    {\n        for (auto &light : lights)\n        {\n            if (light.id == lightID)\n            {\n                light.intensity = newIntensity;\n                break;\n            }\n        }\n    }\n\n// Simple hash function for pseudo-random generation\n    float pseudoRandom(float seed)\n    {\n        return glm::fract(sin(seed) * 43758.5453f);\n    }\n\n    // Update all lights dynamically\n    void updateDynamicLights(std::vector<std::shared_ptr<SimplePointLight>> &lights, float currentFrame)\n    {\n        // Constants for dynamic behavior\n        const float HEIGHT_AMPLITUDE = 0.004f;          // Max vertical displacement\n        const float COLOR_VARIATION_SPEED = 2.5f;       // Speed of color variation\n        const glm::vec3 BASE_COLOR = glm::vec3(1.0f, 0.8f, 0.6f); // Base light color\n\n        // Update each light dynamically\n        for (size_t i = 0; i < lights.size(); i++) {\n            auto light = lights[i];\n\n            // **Dynamic Vertical Movement**\n            float verticalOffset = sin(currentFrame * 0.5f + i * 0.5f) * HEIGHT_AMPLITUDE;\n            light->position.y += verticalOffset; // Adjust Y-position dynamically\n\n            // **Dynamic Color Variation**\n            float colorFactorR = (sin(currentFrame + i * COLOR_VARIATION_SPEED) + 1.0f) / 2.0f;\n            float colorFactorG = (sin(currentFrame + i * COLOR_VARIATION_SPEED + 2.0f) + 1.0f) / 2.0f; // Offset phase by 2\n            float colorFactorB = (sin(currentFrame + i * COLOR_VARIATION_SPEED + 4.0f) + 1.0f) / 2.0f; // Offset phase by 4\n\n            light->color = glm::vec3(BASE_COLOR.r * colorFactorR,\n                                    BASE_COLOR.g * colorFactorG,\n                                    BASE_COLOR.b * colorFactorB);\n\n            // **Dynamic Intensity Variation**\n            float intensityFactor = (sin(currentFrame + i * COLOR_VARIATION_SPEED) + 1.0f) / 2.0f;\n            // Clamp the intensity factor to be between 0.2 and 0.8\n            intensityFactor = glm::clamp(intensityFactor, 0.2f, 0.8f);\n            light->intensity = intensityFactor;\n        }\n    }\n\n} // namespace utils_light\n",
    "APP3/utils/sphere.hpp": "#ifndef SPHERE_HPP\n#define SPHERE_HPP\n\n#include \"global.hpp\"\n#include <vector>\n#include <glimac/Sphere.hpp>\n\nnamespace utils_object {\n\nsize_t createSphereVertices(std::vector<SphereVertex>& sphereVertices, glimac::Sphere& sphere);\nvoid computeSphereTangents(std::vector<SphereVertex>& vertices);\nvoid setupSphereBuffers(const std::vector<SphereVertex>& sphereVertices, GLuint& sphereVBO, GLuint& sphereVAO);\n\n}\n\n#endif // SPHERE_HPP",
    "APP3/utils/initialization.cpp": "#include \"initialization.hpp\"\n#include <iostream>\n#include <GL/gl.h>\n#include <GL/glu.h>\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils_init {\n\nglimac::SDLWindowManager initOpenGL(int window_width, int window_height) {\n    std::cout << \"Program started\" << std::endl;\n\n    // Initialize SDL video subsystem\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        std::cerr << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n        throw std::runtime_error(\"Failed to initialize SDL\");\n    }\n\n    // Create OpenGL window\n    SDL_Surface* screen = SDL_SetVideoMode(window_width, window_height, 32, SDL_OPENGL | SDL_FULLSCREEN);\n    if (!screen) {\n        std::cerr << \"Failed to create SDL OpenGL window: \" << SDL_GetError() << std::endl;\n        throw std::runtime_error(\"Failed to create SDL OpenGL window\");\n    }\n\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n\n    // OpenGL setup\n    glViewport(0, 0, window_width, window_height);\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    SDL_GL_SwapBuffers();\n\n    // OpenGL version and renderer\n    const GLubyte *renderer = glGetString(GL_RENDERER);\n    const GLubyte *version = glGetString(GL_VERSION);\n\n    if (renderer)\n        std::cout << \"Renderer: \" << renderer << std::endl;\n    else\n        std::cout << \"Renderer is NULL\" << std::endl;\n\n    if (version)\n        std::cout << \"OpenGL version supported: \" << version << std::endl;\n    else\n        std::cout << \"OpenGL version is NULL\" << std::endl;\n\n    return glimac::SDLWindowManager(window_width, window_height, \"Boules\");\n}\n\n} // namespace utils_init\n",
    "APP3/utils/resource_loader.cpp": "#include \"resource_loader.hpp\"\n#include \"texture.hpp\"\n#include <glimac/Image.hpp>\n#include <iostream>\n\n#include <cstdlib>\n#include <ctime>\n\nnamespace utils_loader {\n\nstd::vector<GLuint> allTextures;\n\n// Load textures\nvoid loadTextures(GLuint& textureID, GLuint& stoneTextureID, GLuint& brownTerracottaTextureID, GLuint& soccerTextureID,\n                  GLuint& textureID_normalMap, GLuint& stoneTextureID_normalMap, GLuint& brownTerracottaTextureID_normalMap, GLuint& soccerTextureID_normalMap,\n                  GLuint& chairBaseColorTextureID, GLuint& chairNormalMapTextureID,\n                  GLuint& texture_ID_deepslate_emerald_ore, GLuint& texture_ID_deepslate_emerald_ore_n, GLuint& texture_ID_deepslate_emerald_ore_s,\n                  GLuint& texture_ID_glass, GLuint& texture_ID_purple_stained_glass,\n                  GLuint& testure_ID_iron_block, GLuint& texture_ID_iron_block_n, GLuint& texture_ID_iron_block_s,\n                  GLuint& texture_ID_note_block, GLuint& texture_ID_note_block_n, GLuint& texture_ID_note_block_s,\n                  GLuint& texture_ID_oak_planks, GLuint& texture_ID_oak_planks_n, GLuint& texture_ID_oak_planks_s,\n                  GLuint& texture_ID_stone_bricks, GLuint& texture_ID_stone_bricks_n, GLuint& texture_ID_stone_bricks_s,\n                  GLuint& skyboxTextureID,\n                  GLuint& sunTextureID, GLuint& mercuryTextureID, GLuint& venusTextureID, GLuint& venus_atmosphereTextureID,\n                  GLuint& marsTextureID, GLuint& jupiterTextureID, GLuint& saturnTextureID, GLuint& saturn_ringTextureID,\n                  GLuint& uranusTextureID, GLuint& neptuneTextureID,\n                  GLuint& earthTextureID, GLuint& earth_nTextureID, GLuint& earth_sTextureID, GLuint& earth_atmosphereTextureID,\n                  GLuint& crying_obsidianTextureID, GLuint& crying_obsidianTextureID_n, GLuint& crying_obsidianTextureID_s,\n                  GLuint& deepslateTextureID, GLuint& deepslateTextureID_n, GLuint& deepslateTextureID_s,\n                  GLuint& mossy_stone_bricksTextureID, GLuint& mossy_stone_bricksTextureID_n, GLuint& mossy_stone_bricksTextureID_s,\n                  GLuint& obsidianTextureID, GLuint& obsidianTextureID_n, GLuint& obsidianTextureID_s,\n                  GLuint& portalTextureID, GLuint& portalTextureID_s,\n                  \n                  const glimac::FilePath& applicationPath) {\n    textureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_HD/cobblestone_8bit.png\");\n    stoneTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_HD/stone_8bit.png\");\n    brownTerracottaTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_HD/brown_glazed_terracotta_8bit.png\");\n    soccerTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_sphere/soccer_sph_s_8bit.png\");\n    chairBaseColorTextureID = loadTexture(applicationPath.dirPath() + \"../assets/models/Rocking_Chair/Textures/BaseColor.png\");\n\n    textureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_HD/cobblestone_8bit_normal_map.png\");\n    stoneTextureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_HD/stone_8bit_normal_map.png\");\n    brownTerracottaTextureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_HD/brown_glazed_terracotta_8bit_normal_map.png\");\n    soccerTextureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_sphere/soccer_sph_s_8bit_normal_map.png\");\n    chairNormalMapTextureID = loadTexture(applicationPath.dirPath() + \"../assets/models/Rocking_Chair/Textures/Normal.png\");\n\n    // final textures\n    // deepslate_emerald_ore\n    texture_ID_deepslate_emerald_ore = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/deepslate_emerald_ore/deepslate_emerald_ore.png\");\n    texture_ID_deepslate_emerald_ore_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/deepslate_emerald_ore/deepslate_emerald_ore_n.png\");\n    texture_ID_deepslate_emerald_ore_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/deepslate_emerald_ore/deepslate_emerald_ore_s2.png\");\n\n    // glass\n    texture_ID_glass = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/glass/glass.png\");\n    texture_ID_purple_stained_glass = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/glass/purple_stained_glass.png\");\n\n    // iron_block\n    testure_ID_iron_block = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/iron_block/iron_block.png\");\n    texture_ID_iron_block_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/iron_block/iron_block_n.png\");\n    texture_ID_iron_block_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/iron_block/iron_block_s.png\");\n\n    // note_block\n    texture_ID_note_block = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/note_block/note_block.png\");\n    texture_ID_note_block_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/note_block/note_block_n.png\");\n    texture_ID_note_block_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/note_block/note_block_s.png\");\n\n    // oak_planks\n    texture_ID_oak_planks = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/oak_planks/oak_planks.png\");\n    texture_ID_oak_planks_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/oak_planks/oak_planks_n.png\");\n    texture_ID_oak_planks_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/oak_planks/oak_planks_s.png\");\n\n    // stone_bricks\n    texture_ID_stone_bricks = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/stone_bricks/stone_bricks.png\");\n    texture_ID_stone_bricks_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/stone_bricks/stone_bricks_n.png\");\n    texture_ID_stone_bricks_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/stone_bricks/stone_bricks_s.png\");\n\n    // skyboxTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/skybox/skybox.png\");\n    // we can randomly chosoe at start one of the skyboxes, skybox1 to skybox4, but we need to load the 4 skyboxes\n    GLuint sky1, sky2, sky3, sky4;\n\n    sky1 = loadTexture(applicationPath.dirPath() + \"../APP3/assets/skybox/1.png\");\n    sky2 = loadTexture(applicationPath.dirPath() + \"../APP3/assets/skybox/2.png\");\n    sky3 = loadTexture(applicationPath.dirPath() + \"../APP3/assets/skybox/3.png\");\n    sky4 = loadTexture(applicationPath.dirPath() + \"../APP3/assets/skybox/4.png\");\n\n    // randomly choose one of the variables sky1 to sky4 for skyboxTextureID\n    srand(static_cast<unsigned int>(time(0)));\n\n    int random = rand() % 4 + 1;\n\n    switch (random) {\n    case 1:\n        skyboxTextureID = sky1;\n        break;\n    case 2:\n        skyboxTextureID = sky2;\n        break;\n    case 3:\n        skyboxTextureID = sky3;\n        break;\n    case 4:\n        skyboxTextureID = sky4;\n        break;\n    default:\n        skyboxTextureID = sky1;\n        break;\n    }\n\n    // print the skybox file\n    std::cout << \"Skybox file: \" << random << \".png\" << std::endl;\n\n    std::cout << \"Textures loaded successfully\" << std::endl;\n\n    // check textures and normals fir the chair : \n    std::cout << \"Chair Base Color Texture ID: \" << chairBaseColorTextureID << std::endl;\n    std::cout << \"Chair Normal Map Texture ID: \" << chairNormalMapTextureID << std::endl;\n\n    // planets in order\n\n    // sun\n    sunTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/sun/sun.png\");\n\n    // mercury\n    mercuryTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/mercury/mercury.png\");\n\n    // venus\n    venusTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/venus/surface.png\");\n    // venus atmosphere\n    venus_atmosphereTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/venus/atmosphere.png\");\n\n    // earth\n    earthTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/earth/earth.png\");\n    earth_nTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/earth/earth_n.png\");\n    earth_sTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/earth/earth_s.png\");\n    // earth atmosphere\n    earth_atmosphereTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/earth/atmosphere.png\");\n\n    // mars\n    marsTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/mars/mars.png\");\n\n    // jupiter\n    jupiterTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/jupiter/jupiter.png\");\n\n    // saturn\n    saturnTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/saturn/saturn.png\");\n    // saturn ring\n    saturn_ringTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/saturn/rings.png\");\n\n    // uranus\n    uranusTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/uranus/uranus.png\");\n\n    // neptune\n    neptuneTextureID = loadTextureBall(applicationPath.dirPath() + \"../APP3/assets/planets/neptune/neptune.png\");\n\n    // crying obs\n    crying_obsidianTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/crying_obsidian/crying_obsidian.png\");\n    crying_obsidianTextureID_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/crying_obsidian/crying_obsidian_n.png\");\n    crying_obsidianTextureID_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/crying_obsidian/crying_obsidian_s.png\");\n\n    // deepslate\n    deepslateTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/deepslate/deepslate.png\");\n    deepslateTextureID_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/deepslate/deepslate_n.png\");\n    deepslateTextureID_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/deepslate/deepslate_s.png\");\n\n    // mossy stone bricks\n    mossy_stone_bricksTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/mossy_stone_bricks/mossy_stone_bricks.png\");\n    mossy_stone_bricksTextureID_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/mossy_stone_bricks/mossy_stone_bricks_n.png\");\n    mossy_stone_bricksTextureID_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/mossy_stone_bricks/mossy_stone_bricks_s.png\");\n\n    // obsidian\n    obsidianTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/obsidian/obsidian.png\");\n    obsidianTextureID_n = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/obsidian/obsidian_n.png\");\n    obsidianTextureID_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/obsidian/obsidian_s.png\");\n\n    // portal\n    portalTextureID = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/portal/portal.png\");\n    portalTextureID_s = loadTexture(applicationPath.dirPath() + \"../APP3/assets/textures_cube_PBR/portal/portal_s.png\");\n\n    // add all textures to the allTextures vector\n    allTextures.push_back(textureID);\n    allTextures.push_back(stoneTextureID);\n    allTextures.push_back(brownTerracottaTextureID);\n    allTextures.push_back(soccerTextureID);\n    allTextures.push_back(textureID_normalMap);\n    allTextures.push_back(stoneTextureID_normalMap);\n    allTextures.push_back(brownTerracottaTextureID_normalMap);\n    allTextures.push_back(soccerTextureID_normalMap);\n    allTextures.push_back(chairBaseColorTextureID);\n\n    allTextures.push_back(texture_ID_deepslate_emerald_ore);\n    allTextures.push_back(texture_ID_deepslate_emerald_ore_n);\n    allTextures.push_back(texture_ID_deepslate_emerald_ore_s);\n    allTextures.push_back(texture_ID_glass);\n    allTextures.push_back(texture_ID_purple_stained_glass);\n    allTextures.push_back(testure_ID_iron_block);\n    allTextures.push_back(texture_ID_iron_block_n);\n    allTextures.push_back(texture_ID_iron_block_s);\n    allTextures.push_back(texture_ID_note_block);\n    allTextures.push_back(texture_ID_note_block_n);\n    allTextures.push_back(texture_ID_note_block_s);\n    allTextures.push_back(texture_ID_oak_planks);\n    allTextures.push_back(texture_ID_oak_planks_n);\n    allTextures.push_back(texture_ID_oak_planks_s);\n    allTextures.push_back(texture_ID_stone_bricks);\n    allTextures.push_back(texture_ID_stone_bricks_n);\n    allTextures.push_back(texture_ID_stone_bricks_s);\n    allTextures.push_back(skyboxTextureID);\n\n    allTextures.push_back(earthTextureID);\n    allTextures.push_back(earth_nTextureID);\n    allTextures.push_back(earth_sTextureID);\n\n    std::cout << \"All textures added to the allTextures vector\" << std::endl;\n}\n\n// Setup depth cube map\nvoid setupDepthCubeMap(GLuint& depthCubeMap, GLuint& shadowMapFBO, int resolution) {\n    glGenTextures(1, &depthCubeMap);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubeMap);\n    for (unsigned int i = 0; i < 6; ++i) {\n        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT32F, resolution, resolution, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);\n    }\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n\n    glGenFramebuffers(1, &shadowMapFBO);\n    glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);\n    glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubeMap, 0);\n    glDrawBuffer(GL_NONE);\n    glReadBuffer(GL_NONE);\n    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {\n        std::cerr << \"Framebuffer not complete!\" << std::endl;\n    }\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n    std::cout << \"Depth cube map setup complete\" << std::endl;\n}\n\n} // namespace utils_loader",
    "APP3/utils/utilities.hpp": "#ifndef UTILITIES_HPP\n#define UTILITIES_HPP\n\n#include <glm/glm.hpp>\n#include <vector>\n// #include <SDL2/SDL.h>\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace glimac {\n    class SDLWindowManager;\n}\n\nstruct AABB {\n    glm::vec3 min;\n    glm::vec3 max;\n    AABB() : min(glm::vec3(0.0f)), max(glm::vec3(0.0f)) {}\n    AABB(const glm::vec3& min_, const glm::vec3& max_) : min(min_), max(max_) {}\n};\n\nfloat randomFloat();\nglm::vec3 randomColor();\nAABB computeAABB(const std::vector<float>& vertices);\n\nnamespace utils_game_loop {\n    void eventHandler(glimac::SDLWindowManager &windowManager, bool &done, bool &isRockingChairPaused, double &rockingChairStartTime, double &rockingChairPausedTime, float &yaw, float &pitch, glm::vec3 &cameraFront, float &currentFrame);\n}\n\n#endif // UTILITIES_HPP",
    "APP3/utils/cube.cpp": "#include \"cube.hpp\"\n#include <glad/glad.h>\n#include <cstddef> // For offsetof\n\nnamespace utils_object {\n\nvoid createCube(std::vector<Vertex3D>& vertices, std::vector<GLuint>& indices) {\n    vertices = {\n        Vertex3D(glm::vec3(-0.5f, -0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(-1, 0, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, 0.5f), glm::vec3(-1, 0, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, 0.5f), glm::vec3(-1, 0, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, -0.5f), glm::vec3(-1, 0, 0), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, -0.5f), glm::vec3(1, 0, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, 0.5f), glm::vec3(1, 0, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(1, 0, 0), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, -0.5f), glm::vec3(1, 0, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, -0.5f), glm::vec3(0, 1, 0), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, 0.5f), glm::vec3(0, 1, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 1, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, -0.5f), glm::vec3(0, 1, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(0, -1, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, 0.5f), glm::vec3(0, -1, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, 0.5f), glm::vec3(0, -1, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, -0.5f), glm::vec3(0, -1, 0), glm::vec2(0.0f, 1.0f))\n    };\n\n    indices = {\n        0, 1, 2, 2, 3, 0,\n        4, 5, 6, 6, 7, 4,\n        8, 9, 10, 10, 11, 8,\n        12, 13, 14, 14, 15, 12,\n        16, 17, 18, 18, 19, 16,\n        20, 21, 22, 22, 23, 20\n    };\n}\n\nvoid computeCubeTangents(std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices) {\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::vec3(0.0f);\n        vertex.bitangent = glm::vec3(0.0f);\n    }\n\n    for (size_t i = 0; i < indices.size(); i += 3) {\n        GLuint i0 = indices[i];\n        GLuint i1 = indices[i + 1];\n        GLuint i2 = indices[i + 2];\n\n        Vertex3D& v0 = vertices[i0];\n        Vertex3D& v1 = vertices[i1];\n        Vertex3D& v2 = vertices[i2];\n\n        glm::vec3 edge1 = v1.position - v0.position;\n        glm::vec3 edge2 = v2.position - v0.position;\n\n        glm::vec2 deltaUV1 = v1.texCoords - v0.texCoords;\n        glm::vec2 deltaUV2 = v2.texCoords - v0.texCoords;\n\n        float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n\n        glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\n        glm::vec3 bitangent = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);\n\n        v0.tangent += tangent;\n        v1.tangent += tangent;\n        v2.tangent += tangent;\n\n        v0.bitangent += bitangent;\n        v1.bitangent += bitangent;\n        v2.bitangent += bitangent;\n    }\n\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::normalize(vertex.tangent);\n        vertex.bitangent = glm::normalize(vertex.bitangent);\n    }\n}\n\nvoid setupCubeBuffers(const std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices, GLuint& cubeVBO, GLuint& cubeEBO, GLuint& cubeVAO) {\n    glGenBuffers(1, &cubeVBO);\n    glGenBuffers(1, &cubeEBO);\n    glGenVertexArrays(1, &cubeVAO);\n\n    glBindVertexArray(cubeVAO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex3D), vertices.data(), GL_STATIC_DRAW);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, cubeEBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), indices.data(), GL_STATIC_DRAW);\n\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, position));\n\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, normal));\n\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, texCoords));\n\n    glEnableVertexAttribArray(3);\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, tangent));\n\n    glEnableVertexAttribArray(4);\n    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, bitangent));\n\n    glBindVertexArray(0);\n}\n\n} // namespace utils_object",
    "APP3/utils/models.hpp": "#ifndef MODELS_HPP\n#define MODELS_HPP\n\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include \"global.hpp\"\n#include <src/tiny_obj_loader.h>\n\nnamespace utils_object {\n\nextern std::vector<GLuint> allTextures;\n\nstruct ModelData {\n    std::vector<float> vertices;\n    std::vector<float> normals;\n    std::vector<float> texcoords;\n    std::vector<unsigned int> indices;\n    std::vector<tinyobj::material_t> materials;\n    std::vector<tinyobj::shape_t> shapes;\n    std::map<int, GLuint> materialToTexture; // Map material ID to texture ID\n    GLuint vao, vbo, ebo;\n    std::vector<float> tangents;\n    std::vector<float> bitangents;\n};\n\nvoid GetRockingChairPositionAndRotation(\n    double currentTime,\n    double frequency,\n    double radius,\n    double length,\n    glm::vec3& position,\n    glm::vec3& rotation\n);\n\n// Function to load a texture from file and return its OpenGL texture ID\nGLuint LoadTextureFromFile(const char* path);\n\nvoid computeTangents(ModelData &modelData);\n\n// Function to load an OBJ model using TinyOBJLoader\nbool loadOBJ(const std::string& filePath, const std::string& basePath, ModelData &modelData);\n\n// Function to set up OpenGL buffers (VAO, VBO, EBO) for the model\nvoid setupModelBuffers(ModelData &modelData);\n\n}\n\n#endif // MODELS_HPP",
    "APP3/utils/scene_object.hpp": "// scene_object.hpp\n#ifndef SCENE_OBJECT_HPP\n#define SCENE_OBJECT_HPP\n\n#include \"utilities.hpp\"\n#include \"global.hpp\"\n#include \"material.hpp\"  \n#include \"material_manager.hpp\"\n#include <map>\n#include <vector>\n#include <string>\n\nnamespace utils_scene\n{\n\n    enum class ObjectType\n    {\n        Cube,\n        Sphere,\n        Model\n    };\n\n// Define a struct to hold spiral parameters for planets\n    struct PlanetSpiralParams {\n        float spiralRadius;\n        float spiralSpeed;\n        float fixedHeight;\n    };\n\n    // Map to hold parameters for each planet\n    extern std::map<std::string, PlanetSpiralParams> planetSpiralParameters;\n\n    // Function to initialize planet spiral parameters\n    void initializePlanetSpiralParameters();\n\n    // Function to update planet positions\n    void updatePlanetPositions(float currentFrame, const glm::vec3& spiralCenter);\n\n    // Function to update display planet positions\n    void updateDisplayPlanetPositions(float currentFrame);\n\n    struct SceneObject\n    {\n        std::string name;\n        ObjectType type;\n        glm::vec3 position;\n        glm::vec3 initialPosition;\n        glm::vec3 scale;\n        glm::vec3 rotationAxis;\n        float rotationAngle;\n        AABB boundingBox;\n        GLuint vaoID;\n        GLsizei indexCount;\n        bool isStatic;\n\n        // Material reference\n        int materialIndex; // Index into MaterialManager's material list\n\n        // Constructor\n        SceneObject()\n            : position(0.0f), initialPosition(0.0f), scale(1.0f),\n              rotationAxis(0.0f), rotationAngle(0.0f), vaoID(0),\n              indexCount(0), isStatic(false), materialIndex(-1) {}\n    };\n\n    extern std::vector<SceneObject> sceneObjects;\n    extern std::vector<SceneObject> sceneObjectsTransparent;\n    extern std::vector<SceneObject> sceneObjectsSkybox;\n\n    // Updated function declarations to accept Material\n    void addCube(const std::string &name,\n                 const glm::vec3 &position,\n                 const glm::vec3 &scale,\n                 const Material &material,\n                 const glm::vec3 &rotationAxis = glm::vec3(0.0f),\n                 float rotationAngle = 0.0f,\n                 GLuint vaoID = 0,\n                 GLsizei indexCount = 0,\n                 bool isStatic = false);\n\n    void addTransparentCube(const std::string &name,\n                            const glm::vec3 &position,\n                            const glm::vec3 &scale,\n                            const Material &material,\n                            const glm::vec3 &rotationAxis = glm::vec3(0.0f),\n                            float rotationAngle = 0.0f,\n                            GLuint vaoID = 0,\n                            GLsizei indexCount = 0,\n                            bool isStatic = false);\n\n    void addSphere(const std::string &name,\n                   const glm::vec3 &position,\n                   float radius,\n                   const Material &material,\n                   GLuint vaoID = 0,\n                   GLsizei vertexCount = 0,\n                   bool isStatic = false);\n\n    void addTransparentSphere(const std::string &name,\n                      const glm::vec3 &position,\n                      float radius,\n                      const Material &material,\n                      GLuint vaoID = 0,\n                      GLsizei vertexCount = 0,\n                      bool isStatic = false);\n\n    void addSkySphere(const std::string &name,\n                      const glm::vec3 &position,\n                      float radius,\n                      const Material &material,\n                      GLuint vaoID = 0,\n                      GLsizei vertexCount = 0,\n                      bool isStatic = false);\n\n    void createCompositeCube(const std::string &name,\n                             const glm::vec3 &origin,\n                             const glm::vec3 &size,\n                             const Material &material,\n                             GLuint vaoID,\n                             GLsizei indexCount,\n                             bool isStatic);\n\n    void createTransparentCompositeCube(const std::string &name,\n                                        const glm::vec3 &origin,\n                                        const glm::vec3 &size,\n                                        const Material &material,\n                                        GLuint vaoID,\n                                        GLsizei indexCount,\n                                        bool isStatic);\n\n    void addModel(const std::string &name,\n                  const glm::vec3 &position,\n                  const glm::vec3 &scale,\n                  const Material &material,\n                  GLuint vaoID,\n                  GLsizei indexCount,\n                  const AABB &boundingBox,\n                  const glm::vec3 &rotationAxis = glm::vec3(0.0f),\n                  float rotationAngle = 0.0f,\n                  bool isStatic = false);\n\n    // getTransparentObjectPosition\n    glm::vec3 getTransparentObjectPosition(const std::string &name);\n\n    // get object position\n    glm::vec3 getObjectPosition(const std::string &name);\n\n    // setObjectPosition\n    void setObjectPosition(const std::string &name, const glm::vec3 &position);\n\n    void setObjectRotation(const std::string &name, const glm::vec3 &rotationAxis, float rotationAngle);\n\n} // namespace utils_scene\n\n#endif // SCENE_OBJECT_HPP",
    "APP3/utils/collision.hpp": "#ifndef COLLISION_HPP\n#define COLLISION_HPP\n\n#include \"utilities.hpp\"\n\nbool checkCollision(const glm::vec3& cylinderBaseCenter, float radius, float height, const AABB& box);\n\n#endif // COLLISION_HPP",
    "APP3/utils/material_manager.hpp": "// material_manager.hpp\n#ifndef MATERIAL_MANAGER_HPP\n#define MATERIAL_MANAGER_HPP\n\n#include \"material.hpp\"\n#include <vector>\n#include <string>\n#include <iostream> // For debugging\n\nclass MaterialManager {\npublic:\n    // Adds a new material and returns its index\n    // If the material already exists, returns the existing index\n    int addOrGetMaterial(const Material& material) {\n        int index = findMaterial(material);\n        if(index != -1) {\n            std::cout << \"Material already exists. Returning existing index: \" << index << std::endl;\n            return index;\n        }\n        materials.push_back(material);\n        std::cout << \"Added new material. New index: \" << static_cast<int>(materials.size() - 1) << std::endl;\n        return static_cast<int>(materials.size() - 1);\n    }\n\n    // Retrieves a material by index\n    const Material& getMaterial(int index) const {\n        if (index >= 0 && index < static_cast<int>(materials.size())) {\n            return materials[index];\n        }\n        // Handle invalid index appropriately (e.g., return a default material or throw an error)\n        // Here, we'll return the last material as a fallback\n        std::cerr << \"Invalid material index: \" << index << \". Returning last material.\" << std::endl;\n        return materials.back();\n    }\n\n    // Singleton pattern for global access\n    static MaterialManager& getInstance() {\n        static MaterialManager instance;\n        return instance;\n    }\n\n    // Finds a material and returns its index, or -1 if not found\n    int findMaterial(const Material& material) const {\n        for (size_t i = 0; i < materials.size(); ++i) {\n            if (materials[i] == material) { // Uses the overloaded operator==\n                return static_cast<int>(i); // Return index if found\n            }\n        }\n        return -1; // Not found\n    }\n\n    std::vector<Material> materials;\n\nprivate:\n    // Private constructor for Singleton\n    MaterialManager() {}\n    // Delete copy constructor and assignment operator\n    MaterialManager(const MaterialManager&) = delete;\n    MaterialManager& operator=(const MaterialManager&) = delete;\n};\n\n#endif // MATERIAL_MANAGER_HPP",
    "APP3/utils/initialization.hpp": "#ifndef INITIALIZATION_HPP\n#define INITIALIZATION_HPP\n\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils_init {\n\nglimac::SDLWindowManager initOpenGL(int window_width, int window_height);\n\n}\n\n#endif // INITIALIZATION_HPP",
    "APP3/utils/resource_loader.hpp": "#ifndef RESOURCE_LOADER_HPP\n#define RESOURCE_LOADER_HPP\n\n#include \"global.hpp\"\n#include <glimac/Program.hpp>\n#include <glimac/FilePath.hpp>\n#include <vector>\n\nnamespace utils_loader {\n\nextern std::vector<GLuint> allTextures;\n\n// Function to load textures\nvoid loadTextures(GLuint& textureID, GLuint& stoneTextureID, GLuint& brownTerracottaTextureID, GLuint& soccerTextureID,\n                  GLuint& textureID_normalMap, GLuint& stoneTextureID_normalMap, GLuint& brownTerracottaTextureID_normalMap, GLuint& soccerTextureID_normalMap,\n                  GLuint& chairBaseColorTextureID, GLuint& chairNormalMapTextureID,\n                  GLuint& texture_ID_deepslate_emerald_ore, GLuint& texture_ID_deepslate_emerald_ore_n, GLuint& texture_ID_deepslate_emerald_ore_s,\n                  GLuint& texture_ID_glass, GLuint& texture_ID_purple_stained_glass,\n                  GLuint& testure_ID_iron_block, GLuint& texture_ID_iron_block_n, GLuint& texture_ID_iron_block_s,\n                  GLuint& texture_ID_note_block, GLuint& texture_ID_note_block_n, GLuint& texture_ID_note_block_s,\n                  GLuint& texture_ID_oak_planks, GLuint& texture_ID_oak_planks_n, GLuint& texture_ID_oak_planks_s,\n                  GLuint& texture_ID_stone_bricks, GLuint& texture_ID_stone_bricks_n, GLuint& texture_ID_stone_bricks_s,\n                  GLuint& skyboxTextureID,\n                  GLuint& sunTextureID, GLuint& mercuryTextureID, GLuint& venusTextureID, GLuint& venus_atmosphereTextureID,\n                  GLuint& marsTextureID, GLuint& jupiterTextureID, GLuint& saturnTextureID, GLuint& saturn_ringTextureID,\n                  GLuint& uranusTextureID, GLuint& neptuneTextureID,\n                  GLuint& earthTextureID, GLuint& earth_nTextureID, GLuint& earth_sTextureID, GLuint& earth_atmosphereTextureID,\n                  GLuint& crying_obsidianTextureID, GLuint& crying_obsidianTextureID_n, GLuint& crying_obsidianTextureID_s,\n                  GLuint& deepslateTextureID, GLuint& deepslateTextureID_n, GLuint& deepslateTextureID_s,\n                  GLuint& mossy_stone_bricksTextureID, GLuint& mossy_stone_bricksTextureID_n, GLuint& mossy_stone_bricksTextureID_s,\n                  GLuint& obsidianTextureID, GLuint& obsidianTextureID_n, GLuint& obsidianTextureID_s,\n                  GLuint& portalTextureID, GLuint& portalTextureID_s,\n                  const glimac::FilePath& applicationPath);\n\n// Function to set up a depth cube map\nvoid setupDepthCubeMap(GLuint& depthCubeMap, GLuint& shadowMapFBO, int resolution = 4096);\n\n} // namespace utils_loader\n\n#endif // RESOURCE_LOADER_HPP",
    "APP3/utils/collision.cpp": "#include \"collision.hpp\"\n\nbool checkCollision(const glm::vec3& cylinderBaseCenter, float radius, float height, const AABB& box) {\n    float horizontalDistanceSquared = 0.0f;\n\n    for (int i = 0; i < 3; i += 2) {\n        if (cylinderBaseCenter[i] < box.min[i]) {\n            horizontalDistanceSquared += (box.min[i] - cylinderBaseCenter[i]) * (box.min[i] - cylinderBaseCenter[i]);\n        } else if (cylinderBaseCenter[i] > box.max[i]) {\n            horizontalDistanceSquared += (cylinderBaseCenter[i] - box.max[i]) * (cylinderBaseCenter[i] - box.max[i]);\n        }\n    }\n\n    if (horizontalDistanceSquared > (radius * radius)) {\n        return false;\n    }\n\n    float cylinderTop = cylinderBaseCenter.y + height / 2.0f;\n    float cylinderBottom = cylinderBaseCenter.y - height / 2.0f;\n    if (cylinderTop < box.min.y || cylinderBottom > box.max.y) {\n        return false;\n    }\n\n    return true;\n}",
    "APP3/utils/lights.hpp": "#ifndef LIGHTS_HPP\n#define LIGHTS_HPP\n\n#include <glm/glm.hpp>\n#include <vector>\n\n#include \"pointer.hpp\"\n\nnamespace utils_light {\n\n    // ---------------------------\n    // Struct for a simple point light\n    // ---------------------------\n    struct SimplePointLight {\n        int id;              // Unique identifier (e.g., auto-incrementing)\n        glm::vec3 position;  // Position in world space\n        glm::vec3 color;     // Color (could be considered 'diffuse' color)\n        float intensity;     // Brightness multiplier\n    };\n\n    // ---------------------------\n    // Light management functions\n    // ---------------------------\n    \n    // Generates a unique ID for a light\n    int generateLightID();\n\n    // Adds a new light to the container, returns assigned ID\n    int addLight(std::vector<SimplePointLight>& lights, \n                 const glm::vec3& position, \n                 const glm::vec3& color, \n                 float intensity);\n\n    // Removes an existing light by ID, returns true on success\n    bool removeLight(std::vector<SimplePointLight>& lights, int lightID);\n\n    // Moves a light\u2019s position\n    void updateLightPosition(std::vector<SimplePointLight>& lights, int lightID, const glm::vec3& newPosition);\n\n    // Changes a light\u2019s color\n    void updateLightColor(std::vector<SimplePointLight>& lights, int lightID, const glm::vec3& newColor);\n\n    // Changes a light\u2019s intensity\n    void updateLightIntensity(std::vector<SimplePointLight>& lights, int lightID, float newIntensity);\n\n    // Generates a pseudo-random value based on a seed\n    float pseudoRandom(float seed);\n\n    // void update simple light pso and colors\n    void updateDynamicLights(std::vector<std::shared_ptr<SimplePointLight>> &lights, float currentFrame);} // namespace utils_light\n\n#endif // LIGHTS_HPP\n",
    "APP3/utils/shader.cpp": "#include \"shader.hpp\"\n#include <iostream>\n#include <glimac/FilePath.hpp>\n\nnamespace utils_loader {\n\nShader::Shader(const std::string& vertexPath, const std::string& fragmentPath) {\n    glimac::FilePath vPath(vertexPath.c_str());\n    glimac::FilePath fPath(fragmentPath.c_str());\n\n    // Debugging: Print paths\n    std::cout << \"Loading vertex shader: \" << vPath.dirPath() << std::endl;\n    std::cout << \"Loading fragment shader: \" << fPath.dirPath() << std::endl;\n\n    // Load shader program\n    m_program = glimac::loadProgram(vPath, fPath);\n    if (m_program.getGLId() == 0) {\n        std::cerr << \"Failed to load shader program: \" << vertexPath << \" and \" << fragmentPath << std::endl;\n    }\n}\n\n// Shader::~Shader() {\n//     if (m_program.getGLId() != 0) {\n//         glDeleteProgram(m_program.getGLId());\n//         std::cout << \"Deleted shader program with ID: \" << m_program.getGLId() << std::endl;\n//     }\n// }\n\nvoid Shader::use() const {\n    m_program.use();\n}\n\nGLuint Shader::getID() const {\n    return m_program.getGLId();\n}\n\nGLint Shader::getUniformLocation(const std::string& name) const {\n    return glGetUniformLocation(m_program.getGLId(), name.c_str());\n}\n\nGLuint Shader::getGLId() const { // New method implementation\n    return m_program.getGLId();\n}\n\n// clean up\n// void Shader::deleteProgram() {\n//     if (m_program.getGLId() != 0) {\n//         glDeleteProgram(m_program.getGLId());\n//         std::cout << \"Explicitly deleted shader program with ID: \" << m_program.getGLId() << std::endl;\n//     }\n// }\n\n} // namespace utils_loader"
}