{
    "APP1/main.cpp": "// main.cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n#include \"utils/Initialization.hpp\"\n#include \"utils/Shader.hpp\"\n#include \"utils/GBuffer.hpp\"\n#include \"utils/Renderer.hpp\"\n#include \"utils/Camera.hpp\"\n#include \"utils/Lighting.hpp\"\n#include \"utils/Buffer.hpp\"\n#include \"utils/Objects.hpp\"\n\nint WINDOW_HEIGHT = 1000;\nint WINDOW_WIDTH = 1600;\n\nint main(int argc, char* argv[]) {\n    (void)argc;\n    glimac::FilePath applicationPath(argv[0]);\n    std::cout << \"Program started\" << std::endl;\n\n    // Initialize SDL and OpenGL\n    glimac::SDLWindowManager windowManager(WINDOW_WIDTH, WINDOW_HEIGHT, \"Deferred Rendering\");\n    if (!utils::initializeSDL_GL(WINDOW_WIDTH, WINDOW_HEIGHT, \"Deferred Rendering\", windowManager)) {\n        return -1;\n    }\n\n    // Create and compile shaders\n    std::cout << \"Creating shaders\" << std::endl;\n    // print current working directory\n    std::cout << \"Current working directory: \" << applicationPath.dirPath() << std::endl;\n    utils::Shader gBufferShader(applicationPath.dirPath() + \"/../APP1/shaders/deferred_gbuffer.vs.glsl\", applicationPath.dirPath() + \"/../APP1/shaders/deferred_gbuffer.fs.glsl\");\n    utils::Shader lightingShader(applicationPath.dirPath() + \"/../APP1/shaders/deferred_lighting.vs.glsl\", applicationPath.dirPath() + \"/../APP1/shaders/deferred_lighting.fs.glsl\");\n\n    // Check if shaders compiled successfully\n    if (gBufferShader.getID() == 0 || lightingShader.getID() == 0) {\n        std::cerr << \"Failed to compile/link shaders. Exiting.\" << std::endl;\n        return -1;\n    }\n\n    // Create a sphere mesh for all spheres\n    glimac::Sphere sphere(1, 32, 16);\n    GLuint sphereVBO, sphereVAO;\n    utils::createVBOAndVAO(sphereVBO, sphereVAO, sphere);\n\n    // Setup G-buffer\n    utils::GBuffer gBuffer(WINDOW_WIDTH, WINDOW_HEIGHT);\n\n    // Create a full-screen quad\n    GLuint quadVAO = utils::createFullScreenQuad();\n\n    // Setup point lights\n    std::vector<utils::PointLight> pointLights;\n\n    utils::PointLight light1;\n    light1.position = glm::vec3(2.0f, 3.0f, 2.0f);\n    light1.color = glm::vec3(1.0f, 0.0f, 0.0f); // Red light\n    light1.intensity = 2.0f;\n    pointLights.push_back(light1);\n\n    utils::PointLight light2;\n    light2.position = glm::vec3(-2.0f, 1.0f, 2.0f);\n    light2.color = glm::vec3(0.0f, 1.0f, 0.0f); // Green light\n    light2.intensity = 2.0f;\n    pointLights.push_back(light2);\n\n    utils::PointLight light3;\n    light3.position = glm::vec3(0.0f, 2.0f, -2.0f);\n    light3.color = glm::vec3(0.0f, 0.0f, 1.0f); // Blue light\n    light3.intensity = 2.0f;\n    pointLights.push_back(light3);\n\n    // create objects here\n    // Initialize spheres using the Objects module\n    objects::addSphere(glm::vec3(0.0f, 0.0f, 0.0f), 1.0f, glm::vec3(1.0f, 1.0f, 1.0f)); // White sphere at origin\n    objects::addSphere(glm::vec3(2.0f, 0.0f, -1.0f), 0.5f, glm::vec3(1.0f, 0.0f, 0.0f)); // Red sphere\n    objects::addSphere(glm::vec3(-2.0f, 0.0f, -1.0f), 0.75f, glm::vec3(0.0f, 1.0f, 0.0f)); // Green sphere\n\n    // Enable depth testing\n    glEnable(GL_DEPTH_TEST);\n    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n\n    // Initialize camera\n    utils::Camera camera({0.0f, 0.0f, 5.0f});\n    SDL_SetRelativeMouseMode(SDL_TRUE); // Capture the mouse\n\n    // Renderer instance\n    utils::Renderer renderer(WINDOW_WIDTH, WINDOW_HEIGHT);\n\n    bool done = false;\n    std::cout << \"Entering main loop\" << std::endl;\n    while (!done) {\n        // Calculate delta time\n        float deltaTime = utils::calculateDeltaTime(windowManager);\n\n        // Handle input\n        done = utils::handleInput(camera, windowManager, deltaTime, 0.1f);\n\n        // Geometry Pass\n        glm::mat4 modelMatrix = glm::mat4(1.0f); // Identity matrix (no transformations)\n        renderer.geometryPass(camera, sphereVAO, objects::getSpheres(), sphereMesh.getVertexCount(), WINDOW_WIDTH, WINDOW_HEIGHT);\n        \n        // Lighting Pass\n        renderer.lightingPass(camera, quadVAO, pointLights, lightingShader);\n\n        // Swap buffers\n        windowManager.swapBuffers();\n    }\n\n    // Cleanup\n    glDeleteBuffers(1, &sphereVBO);\n    glDeleteVertexArrays(1, &sphereVAO);\n    glDeleteVertexArrays(1, &quadVAO);\n\n    std::cout << \"Program terminated successfully\" << std::endl;\n    return 0;\n}",
    "APP1/utils/Renderer.hpp": "// utils/Renderer.hpp\n#ifndef RENDERER_HPP\n#define RENDERER_HPP\n\n#include <glad/glad.h>\n#include <glm/glm.hpp>\n#include <vector>\n\n#include \"Shader.hpp\"\n#include \"GBuffer.hpp\"\n#include \"Camera.hpp\"\n#include \"Lighting.hpp\"\n#include \"Objects.hpp\"\n\n\nstruct ShapeVertex {\n    glm::vec3 position;   // Position of the vertex\n    glm::vec3 normal;     // Normal vector at the vertex\n    glm::vec2 texCoords;  // Texture coordinates\n};\n\nnamespace utils {\n\nclass Renderer {\npublic:\n    Renderer(int width, int height, Shader& gShader, Shader& lShader);\n    \n    // Destructor\n    ~Renderer();\n\n    // Geometry Pass: Accepts a list of spheres\n    void geometryPass(const Camera& camera, GLuint sphereVAO, const std::vector<objects::Sphere>& spheres, GLsizei vertexCount, int width, int height);\n\n    // Lighting Pass\n    void lightingPass(const Camera& camera, GLuint quadVAO, const std::vector<PointLight>& pointLights);\n    // Getters for G-buffer textures\n    GLuint getGPosition() const { return m_gBuffer.getPositionTexture(); }\n    GLuint getGNormal() const { return m_gBuffer.getNormalTexture(); }\n    GLuint getGAlbedoSpec() const { return m_gBuffer.getAlbedoSpecTexture(); }\n\nprivate:\n    GBuffer m_gBuffer; // Encapsulates the G-buffer\n};\n\n} // namespace utils\n\n#endif // RENDERER_HPP",
    "APP1/utils/Camera.cpp": "#include \"Camera.hpp\"\n\nnamespace utils {\n\n    Camera::Camera(const glm::vec3& initialPosition)\n        : cameraPos(initialPosition), cameraFront(0.0f, 0.0f, -1.0f), cameraUp(0.0f, 1.0f, 0.0f),\n          yaw(-90.0f), pitch(0.0f), initialYPos(initialPosition.y) {}\n\n    glm::mat4 Camera::getViewMatrix() const {\n        return glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);\n    }\n\n    void Camera::processKeyboard(const Uint8* state, float deltaTime) {\n        glm::vec3 frontDirection = glm::normalize(glm::vec3(cameraFront.x, 0.0f, cameraFront.z));\n        glm::vec3 rightDirection = glm::normalize(glm::cross(frontDirection, cameraUp));\n        float speed = deltaTime * cameraSpeed;\n\n        if (state[SDL_SCANCODE_W]) cameraPos += speed * frontDirection;\n        if (state[SDL_SCANCODE_S]) cameraPos -= speed * frontDirection;\n        if (state[SDL_SCANCODE_A]) cameraPos -= speed * rightDirection;\n        if (state[SDL_SCANCODE_D]) cameraPos += speed * rightDirection;\n\n        cameraPos.y = initialYPos;\n    }\n\n    void Camera::processMouseMovement(float xOffset, float yOffset, float sensitivity) {\n        yaw += xOffset * sensitivity;\n        pitch -= yOffset * sensitivity;\n\n        if (pitch > 89.0f) pitch = 89.0f;\n        if (pitch < -89.0f) pitch = -89.0f;\n\n        glm::vec3 front;\n        front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));\n        front.y = sin(glm::radians(pitch));\n        front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));\n        cameraFront = glm::normalize(front);\n    }\n\n    bool handleInput(Camera& camera, glimac::SDLWindowManager& windowManager, float deltaTime, float sensitivity) {\n        SDL_Event e;\n        while (windowManager.pollEvent(e)) {\n            if (e.type == SDL_QUIT) return true;\n            if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE) return true;\n            if (e.type == SDL_MOUSEMOTION) {\n                camera.processMouseMovement(e.motion.xrel, e.motion.yrel, sensitivity);\n            }\n        }\n        const Uint8* state = SDL_GetKeyboardState(NULL);\n        camera.processKeyboard(state, deltaTime);\n        return false;\n    }\n\n    float calculateDeltaTime(glimac::SDLWindowManager& windowManager) {\n        static float lastFrame = 0.0f;\n        static float fpsTimer = 0.0f; // Accumulate time for FPS calculation\n        static int frameCount = 0;    // Count frames\n        static int fps = 0;          // Store FPS value\n\n        float currentFrame = windowManager.getTime();\n        float deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n\n        // Increment frame count and accumulate time\n        fpsTimer += deltaTime;\n        frameCount++;\n\n        // Update FPS once every second\n        if (fpsTimer >= 1.0f) {\n            fps = frameCount;      // Calculate FPS as an integer\n            frameCount = 0;       // Reset frame count\n            fpsTimer -= 1.0f;     // Reset timer\n\n            // Update window title with new FPS\n            std::string newTitle = \"FPS: \" + std::to_string(fps);\n            SDL_SetWindowTitle(windowManager.getWindow(), newTitle.c_str());\n        }\n\n        return deltaTime;\n    }\n    \n\n} // namespace utils",
    "APP1/utils/Objects.cpp": "// utils/Objects.cpp\n#include \"Objects.hpp\"\n#include <iostream>\n\nnamespace objects {\n\n// Internal list to store all spheres\nstatic std::vector<Sphere> spheres;\n\n// Adds a new sphere to the scene\nvoid addSphere(const glm::vec3& position, float size, const glm::vec3& color) {\n    spheres.emplace_back(Sphere(position, size, color));\n    std::cout << \"Added sphere at position (\" \n              << position.x << \", \" << position.y << \", \" << position.z \n              << \") with size \" << size << \" and color (\" \n              << color.r << \", \" << color.g << \", \" << color.b << \").\" \n              << std::endl;\n}\n\n// Removes a sphere from the scene by its index\nvoid removeSphere(size_t index) {\n    if (index < spheres.size()) {\n        std::cout << \"Removing sphere at index \" << index << \".\" << std::endl;\n        spheres.erase(spheres.begin() + index);\n    } else {\n        std::cerr << \"removeSphere: Index \" << index << \" is out of range! No sphere removed.\" << std::endl;\n    }\n}\n\n// Moves a sphere to a new position by its index\nvoid moveSphere(size_t index, const glm::vec3& newPosition) {\n    if (index < spheres.size()) {\n        std::cout << \"Moving sphere at index \" << index \n                  << \" to new position (\" \n                  << newPosition.x << \", \" << newPosition.y << \", \" << newPosition.z \n                  << \").\" << std::endl;\n        spheres[index].position = newPosition;\n    } else {\n        std::cerr << \"moveSphere: Index \" << index << \" is out of range! No sphere moved.\" << std::endl;\n    }\n}\n\n// Retrieves the list of all spheres\nconst std::vector<Sphere>& getSpheres() {\n    return spheres;\n}\n\n} // namespace objects",
    "APP1/utils/Initialization.cpp": "// utils/Initialization.cpp\n#include \"Initialization.hpp\"\n#include <iostream>\n\nnamespace utils {\n\nbool initializeSDL_GL(int width, int height, const std::string& title, glimac::SDLWindowManager& windowManager) {\n    // Initialize SDL video subsystem\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        std::cerr << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n\n    // Set OpenGL context version and profile\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3) != 0) {\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MAJOR_VERSION: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3) != 0) {\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MINOR_VERSION: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE) != 0) {\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_PROFILE_MASK: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n\n#ifdef __APPLE__\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG) != 0) {\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_FLAGS: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n#endif\n\n    // Create the window manager\n    std::cout << \"SDLWindowManager initialized\" << std::endl;\n\n    // Initialize GLAD\n    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress)) {\n        std::cerr << \"Failed to initialize GLAD\" << std::endl;\n        return false;\n    }\n    std::cout << \"GLAD initialized\" << std::endl;\n\n    // Output OpenGL version and renderer\n    const GLubyte* renderer = glGetString(GL_RENDERER);\n    const GLubyte* version = glGetString(GL_VERSION);\n    if (renderer)\n        std::cout << \"Renderer: \" << renderer << std::endl;\n    else\n        std::cout << \"Renderer is NULL\" << std::endl;\n\n    if (version)\n        std::cout << \"OpenGL version supported: \" << version << std::endl;\n    else\n        std::cout << \"OpenGL version is NULL\" << std::endl;\n\n    return true;\n}\n\n} // namespace utils",
    "APP1/utils/GBuffer.hpp": "// utils/GBuffer.hpp\n#ifndef GBUFFER_HPP\n#define GBUFFER_HPP\n\n#include <glad/glad.h>\n\nnamespace utils {\n\nclass GBuffer {\npublic:\n    // Constructor: Initializes the G-buffer with the specified window dimensions\n    GBuffer(int width, int height);\n\n    // Destructor: Cleans up allocated OpenGL resources\n    ~GBuffer();\n\n    // Bind the G-buffer framebuffer for writing (geometry pass)\n    void bindForWriting() const;\n\n    // Getters for the G-buffer textures\n    GLuint getPositionTexture() const { return gPosition; }\n    GLuint getNormalTexture() const { return gNormal; }\n    GLuint getAlbedoSpecTexture() const { return gAlbedoSpec; }\n\nprivate:\n    GLuint gBuffer;       // Framebuffer object\n    GLuint gPosition;     // Position texture\n    GLuint gNormal;       // Normal texture\n    GLuint gAlbedoSpec;   // Albedo + Specular texture\n    GLuint rboDepth;      // Renderbuffer for depth\n    int m_width;          // Window width\n    int m_height;         // Window height\n};\n\n} // namespace utils\n\n#endif // GBUFFER_HPP",
    "APP1/utils/Shader.cpp": "// utils/Shader.cpp\n#include \"Shader.hpp\"\n#include <glimac/FilePath.hpp>\n#include <iostream>\n\nnamespace utils {\n\nShader::Shader(const std::string& vertexPath, const std::string& fragmentPath) {\n    glimac::FilePath vPath(vertexPath.c_str());\n    glimac::FilePath fPath(fragmentPath.c_str());\n    // print the path attempted to be loaded\n    std::cout << \"Vertex path: \" << vPath.dirPath() << std::endl;\n    std::cout << \"Fragment path: \" << fPath.dirPath() << std::endl;\n    m_program = glimac::loadProgram(vPath, fPath);\n\n    if (m_program.getGLId() == 0) {\n        std::cerr << \"Failed to load shader program: \" << vertexPath << \" and \" << fragmentPath << std::endl;\n    }\n}\n\nvoid Shader::use() const {\n    m_program.use();\n}\n\nGLuint Shader::getID() const {\n    return m_program.getGLId();\n}\n\nGLint Shader::getUniformLocation(const std::string& name) const {\n    return glGetUniformLocation(m_program.getGLId(), name.c_str());\n}\n\n} // namespace utils",
    "APP1/utils/Buffer.cpp": "// utils/Buffer.cpp\n#include \"Buffer.hpp\"\n#include \"Renderer.hpp\"\n#include <cstddef> // For offsetof\n#include <iostream>\n\nnamespace utils {\n\nvoid createVBOAndVAO(GLuint& vbo, GLuint& vao, const glimac::Sphere& sphere) {\n    // Generate and bind the VBO\n    glGenBuffers(1, &vbo);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, sphere.getVertexCount() * sizeof(glimac::ShapeVertex), sphere.getDataPointer(), GL_STATIC_DRAW);\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n    // Generate and bind the VAO\n    glGenVertexArrays(1, &vao);\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n    // Enable and set vertex attribute pointers\n    glEnableVertexAttribArray(0); // Position attribute\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, position));\n\n    glEnableVertexAttribArray(1); // Normal attribute\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, normal));\n\n    glEnableVertexAttribArray(2); // Texture Coordinates attribute\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, texCoords));\n\n    // Unbind the VAO and VBO\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}\n\nGLuint createFullScreenQuad() {\n    GLuint quadVAO, quadVBO;\n    float quadVertices[] = {\n        // positions   // texCoords\n        -1.0f,  1.0f,  0.0f,  1.0f,\n        -1.0f, -1.0f,  0.0f,  0.0f,\n         1.0f, -1.0f,  1.0f,  0.0f,\n\n        -1.0f,  1.0f,  0.0f,  1.0f,\n         1.0f, -1.0f,  1.0f,  0.0f,\n         1.0f,  1.0f,  1.0f,  1.0f\n    };\n    glGenVertexArrays(1, &quadVAO);\n    glGenBuffers(1, &quadVBO);\n    \n    glBindVertexArray(quadVAO);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, quadVBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW);\n    \n    // Position attribute\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);\n    \n    // Texture Coordinates attribute\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));\n    \n    glBindVertexArray(0);\n    \n    // Optionally, you can delete the VBO if you don't need to modify it later\n    glDeleteBuffers(1, &quadVBO);\n    \n    return quadVAO;\n}\n\n} // namespace utils",
    "APP1/utils/Lighting.cpp": "#include \"Lighting.hpp\"\n",
    "APP1/utils/Objects.hpp": "// utils/Objects.hpp\n#ifndef OBJECTS_HPP\n#define OBJECTS_HPP\n\n#include <glm/glm.hpp>\n#include <vector>\n\nnamespace objects {\n\nstruct Sphere {\n    glm::vec3 position; // Position of the sphere in world space\n    float size;         // Scale factor for the sphere\n    glm::vec3 color;    // Color of the sphere\n\n    Sphere(const glm::vec3& pos = glm::vec3(0.0f), \n           float s = 1.0f, \n           const glm::vec3& col = glm::vec3(1.0f))\n        : position(pos), size(s), color(col) {}\n};\n\n// Adds a new sphere to the scene\nvoid addSphere(const glm::vec3& position, float size, const glm::vec3& color);\n\n// Removes a sphere from the scene by its index\nvoid removeSphere(size_t index);\n\n// Moves a sphere to a new position by its index\nvoid moveSphere(size_t index, const glm::vec3& newPosition);\n\n// Retrieves the list of all spheres\nconst std::vector<Sphere>& getSpheres();\n\n} // namespace objects\n\n#endif // OBJECTS_HPP",
    "APP1/utils/Initialization.hpp": "// utils/Initialization.hpp\n#ifndef INITIALIZATION_HPP\n#define INITIALIZATION_HPP\n\n#include <glad/glad.h>\n#include <SDL2/SDL.h>\n#include <string>\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils {\n\n// Initializes SDL, creates a window, and initializes GLAD\n// Returns true on success, false on failure\nbool initializeSDL_GL(int width, int height, const std::string& title, glimac::SDLWindowManager& windowManager);\n\n} // namespace utils\n\n#endif // INITIALIZATION_HPP",
    "APP1/utils/GBuffer.cpp": "// utils/GBuffer.cpp\n#include \"GBuffer.hpp\"\n#include <iostream>\n\nnamespace utils {\n\nGBuffer::GBuffer(int width, int height) : m_width(width), m_height(height) {\n    // Generate and bind the framebuffer\n    glGenFramebuffers(1, &gBuffer);\n    glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);\n\n    // ----- Position Buffer -----\n    glGenTextures(1, &gPosition);\n    glBindTexture(GL_TEXTURE_2D, gPosition);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, m_width, m_height, 0, GL_RGB, GL_FLOAT, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition, 0);\n\n    // ----- Normal Buffer -----\n    glGenTextures(1, &gNormal);\n    glBindTexture(GL_TEXTURE_2D, gNormal);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, m_width, m_height, 0, GL_RGB, GL_FLOAT, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, gNormal, 0);\n\n    // ----- Albedo + Specular Buffer -----\n    glGenTextures(1, &gAlbedoSpec);\n    glBindTexture(GL_TEXTURE_2D, gAlbedoSpec);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, m_width, m_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, gAlbedoSpec, 0);\n\n    // Specify the color attachments for the framebuffer\n    GLuint attachments[3] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2 };\n    glDrawBuffers(3, attachments);\n\n    // ----- Depth Buffer -----\n    glGenRenderbuffers(1, &rboDepth);\n    glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);\n    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, m_width, m_height);\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);\n\n    // Check if framebuffer is complete\n    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {\n        std::cerr << \"GBuffer: Framebuffer not complete!\" << std::endl;\n    }\n\n    // Unbind the framebuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n}\n\nGBuffer::~GBuffer() {\n    glDeleteFramebuffers(1, &gBuffer);\n    glDeleteTextures(1, &gPosition);\n    glDeleteTextures(1, &gNormal);\n    glDeleteTextures(1, &gAlbedoSpec);\n    glDeleteRenderbuffers(1, &rboDepth);\n}\n\nvoid GBuffer::bindForWriting() const {\n    glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);\n}\n\n} // namespace utils",
    "APP1/utils/Lighting.hpp": "#ifndef LIGHTING_HPP\n#define LIGHTING_HPP\n\n#include <glm/glm.hpp>\n\nnamespace utils {\n\n    struct PointLight {\n        glm::vec3 position;\n        glm::vec3 color;\n        float intensity;\n    };\n\n} // namespace utils\n\n#endif // LIGHTING_HPP",
    "APP1/utils/Buffer.hpp": "// utils/Buffer.hpp\n#ifndef BUFFER_HPP\n#define BUFFER_HPP\n\n#include <glad/glad.h>\n#include <glimac/Sphere.hpp>\n\nnamespace utils {\n\nvoid createVBOAndVAO(GLuint& vbo, GLuint& vao, const glimac::Sphere& sphere);\n\nGLuint createFullScreenQuad();\n\n} // namespace utils\n\n#endif // BUFFER_HPP",
    "APP1/utils/Shader.hpp": "// utils/Shader.hpp\n#ifndef SHADER_HPP\n#define SHADER_HPP\n\n#include <string>\n#include <glimac/Program.hpp>\n#include <glad/glad.h>\n\nnamespace utils {\n\nclass Shader {\npublic:\n    // Constructor that builds the shader program from vertex and fragment shader file paths\n    Shader(const std::string& vertexPath, const std::string& fragmentPath);\n\n    // Activate the shader program\n    void use() const;\n\n    // Retrieve the OpenGL ID of the shader program\n    GLuint getID() const;\n\n    // Retrieve the location of a uniform variable\n    GLint getUniformLocation(const std::string& name) const;\n\nprivate:\n    glimac::Program m_program; // Encapsulates the shader program\n};\n\n} // namespace utils\n\n#endif // SHADER_HPP",
    "APP1/utils/Renderer.cpp": "// utils/Renderer.cpp\n#include \"Renderer.hpp\"\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <iostream>\n\nnamespace utils {\n\nRenderer::Renderer(int width, int height) : m_gBuffer(width, height) {}\n\nRenderer::~Renderer() {}\n\nvoid Renderer::geometryPass(const Camera& camera, GLuint vao, const glm::mat4& modelMatrix, Shader& gBufferShader, GLsizei vertexCount, int width, int height) {\n    // Bind G-buffer for writing\n    m_gBuffer.bindForWriting();\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // Use the G-buffer shader\n    gBufferShader.use();\n\n    // Setup transformation matrices\n    glm::mat4 ProjMatrix = glm::perspective(glm::radians(70.0f), static_cast<float>(width) / height, 0.1f, 100.0f);\n    glm::mat4 ViewMatrix = camera.getViewMatrix();\n\n    // glm::mat4 MVMatrix = ViewMatrix * modelMatrix;\n    // glm::mat4 MVPMatrix = ProjMatrix * MVMatrix;\n    // glm::mat4 NormalMatrix = glm::transpose(glm::inverse(MVMatrix));\n\n    glm::mat4 MVPMatrix = ProjMatrix * ViewMatrix * modelMatrix;\n    glm::mat4 NormalMatrix = glm::transpose(glm::inverse(modelMatrix));\n\n    // Retrieve and set uniform locations\n    GLint uMVPMatrixLocation = gBufferShader.getUniformLocation(\"uMVPMatrix\");\n    GLint uNormalMatrixLocation = gBufferShader.getUniformLocation(\"uNormalMatrix\");\n    GLint uModelMatrixLocation = gBufferShader.getUniformLocation(\"uModelMatrix\");\n\n    if (uMVPMatrixLocation != -1) {\n        glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(MVPMatrix));\n    } else {\n        std::cerr << \"Renderer::geometryPass: uMVPMatrix not found!\" << std::endl;\n    }\n\n    if (uNormalMatrixLocation != -1) {\n        glUniformMatrix4fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(NormalMatrix));\n    } else {\n        std::cerr << \"Renderer::geometryPass: uNormalMatrix not found!\" << std::endl;\n    }\n\n    if (uModelMatrixLocation != -1) {\n        glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix));\n    } else {\n        std::cerr << \"Renderer::geometryPass: uModelMatrix not found!\" << std::endl;\n    }\n\n    // Bind and render the geometry\n    glBindVertexArray(vao);\n    glDrawArrays(GL_TRIANGLES, 0, vertexCount); // Use the passed vertexCount\n    glBindVertexArray(0);\n\n    // Unbind the framebuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n}\n\nvoid Renderer::lightingPass(const Camera& camera, GLuint quadVAO, const std::vector<PointLight>& pointLights, Shader& lightingShader) {\n    // Clear buffers for lighting pass\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // Use the lighting shader\n    lightingShader.use();\n\n    // Set Blinn-Phong uniforms\n    GLint uKsLocation = lightingShader.getUniformLocation(\"uKs\");\n    GLint uShininessLocation = lightingShader.getUniformLocation(\"uShininess\");\n    GLint uCameraPosLocation = lightingShader.getUniformLocation(\"cameraPosWorld\");\n\n    if (uKsLocation != -1) {\n        glUniform3f(uKsLocation, 0.5f, 0.5f, 0.5f); // Specular reflection coefficient\n    } else {\n        std::cerr << \"Renderer::lightingPass: uKs not found!\" << std::endl;\n    }\n\n    if (uShininessLocation != -1) {\n        glUniform1f(uShininessLocation, 32.0f); // Shininess exponent\n    } else {\n        std::cerr << \"Renderer::lightingPass: uShininess not found!\" << std::endl;\n    }\n\n    if (uCameraPosLocation != -1) {\n        glm::vec3 cameraPos = camera.getPosition();\n        glUniform3fv(uCameraPosLocation, 1, glm::value_ptr(cameraPos));\n    } else {\n        std::cerr << \"Renderer::lightingPass: cameraPosWorld not found!\" << std::endl;\n    }\n\n    // Bind G-buffer textures\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, m_gBuffer.getPositionTexture());\n    glUniform1i(lightingShader.getUniformLocation(\"gPosition\"), 0);\n\n    glActiveTexture(GL_TEXTURE1);\n    glBindTexture(GL_TEXTURE_2D, m_gBuffer.getNormalTexture());\n    glUniform1i(lightingShader.getUniformLocation(\"gNormal\"), 1);\n\n    glActiveTexture(GL_TEXTURE2);\n    glBindTexture(GL_TEXTURE_2D, m_gBuffer.getAlbedoSpecTexture());\n    glUniform1i(lightingShader.getUniformLocation(\"gAlbedoSpec\"), 2);\n\n    // Set number of point lights\n    GLint numPointLightsLoc = lightingShader.getUniformLocation(\"numPointLights\");\n    if (numPointLightsLoc != -1) {\n        glUniform1i(numPointLightsLoc, static_cast<int>(pointLights.size()));\n    } else {\n        std::cerr << \"Renderer::lightingPass: numPointLights not found!\" << std::endl;\n    }\n\n    // Set point lights uniforms\n    for (size_t i = 0; i < pointLights.size(); ++i) {\n        std::string baseName = \"pointLights[\" + std::to_string(i) + \"]\";\n        std::string positionName = baseName + \".position\";\n        std::string colorName = baseName + \".color\";\n        std::string intensityName = baseName + \".intensity\";\n\n        GLint positionLoc = lightingShader.getUniformLocation(positionName);\n        GLint colorLoc = lightingShader.getUniformLocation(colorName);\n        GLint intensityLoc = lightingShader.getUniformLocation(intensityName);\n\n        if (positionLoc != -1 && colorLoc != -1 && intensityLoc != -1) {\n            glUniform3fv(positionLoc, 1, glm::value_ptr(pointLights[i].position));\n            glUniform3fv(colorLoc, 1, glm::value_ptr(pointLights[i].color));\n            glUniform1f(intensityLoc, pointLights[i].intensity);\n        } else {\n            std::cerr << \"Renderer::lightingPass: Failed to get uniform locations for pointLights[\" << i << \"]\" << std::endl;\n        }\n    }\n\n    // Render the full-screen quad\n    glBindVertexArray(quadVAO);\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n    glBindVertexArray(0);\n}\n\n} // namespace utils",
    "APP1/utils/Camera.hpp": "#ifndef CAMERA_HPP\n#define CAMERA_HPP\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include \"glimac/SDLWindowManager.hpp\"\n\nnamespace utils {\n\n    constexpr float cameraSpeed = 5.0f;\n\n    class Camera {\n    public:\n        explicit Camera(const glm::vec3& initialPosition);\n        glm::mat4 getViewMatrix() const;\n        void processKeyboard(const Uint8* state, float deltaTime);\n        void processMouseMovement(float xOffset, float yOffset, float sensitivity);\n\n        glm::vec3 getPosition() const { return cameraPos; }\n\n    private:\n        glm::vec3 cameraPos;\n        glm::vec3 cameraFront;\n        glm::vec3 cameraUp;\n        float yaw;\n        float pitch;\n        const float initialYPos;\n    };\n\n    bool handleInput(Camera& camera, glimac::SDLWindowManager& windowManager, float deltaTime, float sensitivity);\n    float calculateDeltaTime(glimac::SDLWindowManager& windowManager);\n\n} // namespace utils\n\n#endif // CAMERA_HPP",
    "APP1/shaders/deferred_gbuffer.fs.glsl": "#version 330 core\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec3 Albedo;\n\nlayout(location = 0) out vec3 gPosition;\nlayout(location = 1) out vec3 gNormal;\nlayout(location = 2) out vec3 gAlbedoSpec;\n\nvoid main() {\n    gPosition = FragPos;\n    gNormal = normalize(Normal);\n    gAlbedoSpec.rgb = Albedo;\n}",
    "APP1/shaders/deferred_lighting.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec2 aPos; // Changed from vec3 to vec2\n\nvoid main() {\n    gl_Position = vec4(aPos, 0.0, 1.0); // Set Z to 0.0 and W to 1.0\n}",
    "APP1/shaders/sphere.vs.glsl": "#version 330 core\n\n// Input attributes from the VBO\nlayout(location = 0) in vec3 aVertexPosition; // Vertex position\nlayout(location = 1) in vec3 aVertexNormal;   // Vertex normal\nlayout(location = 2) in vec2 aVertexTexCoords; // Vertex texture coordinates\n\n// Uniforms for transformation matrices\nuniform mat4 uMVPMatrix;     // Model-View-Projection matrix\nuniform mat4 uMVMatrix;      // Model-View matrix\nuniform mat4 uNormalMatrix;  // Normal matrix\n\n// Outputs to the fragment shader\nout vec3 vPosition_vs;       // Vertex position in view space\nout vec3 vNormal_vs;         // Normal vector in view space\nout vec2 vTexCoords;         // Texture coordinates\n\nvoid main() {\n    // Transform the vertex position to view space and pass to fragment shader\n    vPosition_vs = vec3(uMVMatrix * vec4(aVertexPosition, 1.0));\n\n    // Transform the normal vector to view space and pass to fragment shader\n    vNormal_vs = vec3(uNormalMatrix * vec4(aVertexNormal, 0.0));\n\n    // Pass texture coordinates directly to the fragment shader\n    vTexCoords = aVertexTexCoords;\n\n    // Compute the final position of the vertex in clip space\n    gl_Position = uMVPMatrix * vec4(aVertexPosition, 1.0);\n}",
    "APP1/shaders/deferred_gbuffer.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPosition;   // Vertex position\nlayout(location = 1) in vec3 aNormal;     // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;  // Texture coordinates (if any)\n\nuniform mat4 uProjMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\nuniform mat4 uMVPMatrix;\nuniform mat4 uNormalMatrix;\n\nuniform vec3 uColor; // Sphere color\n\nout vec3 FragPos;    // Position in world space\nout vec3 Normal;     // Normal in world space\nout vec3 Albedo;     // Albedo color\n\nvoid main() {\n    gl_Position = uMVPMatrix * vec4(aPosition, 1.0);\n    FragPos = vec3(uModelMatrix * vec4(aPosition, 1.0));\n    Normal = mat3(uNormalMatrix) * aNormal;\n    Albedo = uColor; // Assign the sphere's color\n}",
    "APP1/shaders/deferred_lighting.fs.glsl": "#version 330 core\n\nout vec4 FragColor;\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\n#define NR_POINT_LIGHTS 10\n\nuniform int numPointLights;\nuniform PointLight pointLights[NR_POINT_LIGHTS];\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\n\nuniform vec3 cameraPosWorld; // Camera position in world space\n\n// Blinn-Phong parameters\nuniform vec3 uKs;          // Specular reflection coefficient\nuniform float uShininess;  // Shininess exponent\n\nvoid main() {\n    vec2 TexCoords = gl_FragCoord.xy / textureSize(gPosition, 0);\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = normalize(texture(gNormal, TexCoords).rgb);\n    vec3 Albedo = texture(gAlbedoSpec, TexCoords).rgb;\n    float SpecularIntensity = texture(gAlbedoSpec, TexCoords).a;\n\n    vec3 lighting = vec3(0.0); // Initialize lighting\n\n    // Ambient term\n    vec3 ambient = 0.1 * Albedo;\n    lighting += ambient;\n\n    // View direction\n    vec3 viewDir = normalize(cameraPosWorld - FragPos);\n\n    // Iterate over all point lights\n    for(int i = 0; i < numPointLights; i++) {\n        // Light properties\n        vec3 lightPos = pointLights[i].position;\n        vec3 lightColor = pointLights[i].color;\n        float lightIntensity = pointLights[i].intensity;\n\n        // Light direction\n        vec3 lightDir = normalize(lightPos - FragPos);\n\n        // Diffuse shading\n        float diff = max(dot(Normal, lightDir), 0.0);\n        vec3 diffuse = diff * Albedo * lightColor * lightIntensity;\n\n        // Specular shading (Blinn-Phong)\n        vec3 halfwayDir = normalize(lightDir + viewDir);\n        float spec = pow(max(dot(Normal, halfwayDir), 0.0), uShininess);\n        vec3 specular = uKs * spec * lightColor * lightIntensity * SpecularIntensity;\n\n        // Attenuation\n        float distance = length(lightPos - FragPos);\n        float attenuation = 1.0 / (distance * distance);\n        diffuse *= attenuation;\n        specular *= attenuation;\n\n        // Accumulate\n        lighting += diffuse + specular;\n    }\n\n    FragColor = vec4(lighting, 1.0);\n}",
    "APP1/shaders/sphere.fs.glsl": "#version 330 core\n\n// Inputs from the vertex shader\nin vec3 vPosition_vs;   // Position in view space\nin vec3 vNormal_vs;     // Normal in view space\nin vec2 vTexCoords;     // Texture coordinates\n\n// Output color\nout vec4 FragColor;\n\nvoid main() {\n    // Normalize the normal vector\n    vec3 normal = normalize(vNormal_vs);\n    \n    // Use the normalized normal vector as the fragment color (for debugging purposes)\n    FragColor = vec4(normal * 0.5 + 0.5, 1.0); // Shift from [-1, 1] to [0, 1]\n}"
}