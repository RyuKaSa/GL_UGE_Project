{
    "APP1/main.cpp": "#define GLFW_INCLUDE_NONE\n#include <glad/glad.h>\n#include <iostream>\n#include <glimac/Sphere.hpp>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <glimac/Program.hpp>\n#include <SDL2/SDL.h>\n#include <cstddef> // For offsetof\n#include <glimac/FilePath.hpp>\n\n#include \"glimac/SDLWindowManager.hpp\"\n#include \"utils/Init.hpp\"\n#include \"utils/Render.hpp\"\n#include \"utils/Camera.hpp\"\n\nconstexpr int window_width = 800;\nconstexpr int window_height = 800;\nconstexpr float mouseSensitivity = 0.1f;\n\nint main(int argc, char* argv[]) {\n    (void)argc;\n    (void)argv;\n    std::cout << \"Program started\" << std::endl;\n\n    // Initialize SDL video subsystem\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        std::cerr << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n        return -1;\n    }\n\n    // Set OpenGL context version and profile\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MAJOR_VERSION: \" << SDL_GetError() << std::endl;\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MINOR_VERSION: \" << SDL_GetError() << std::endl;\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_PROFILE_MASK: \" << SDL_GetError() << std::endl;\n\n#ifdef __APPLE__\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_FLAGS: \" << SDL_GetError() << std::endl;\n#endif\n\n    glimac::SDLWindowManager windowManager(window_width, window_height, \"Boules\");\n    std::cout << \"SDLWindowManager initialized\" << std::endl;\n\n    // Initialize GLAD\n    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress)) {\n        std::cerr << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n    std::cout << \"GLAD initialized\" << std::endl;\n\n    // Output OpenGL version and renderer\n    const GLubyte *renderer = glGetString(GL_RENDERER);\n    const GLubyte *version = glGetString(GL_VERSION);\n    if (renderer)\n        std::cout << \"Renderer: \" << renderer << std::endl;\n    else\n        std::cout << \"Renderer is NULL\" << std::endl;\n\n    if (version)\n        std::cout << \"OpenGL version supported: \" << version << std::endl;\n    else\n        std::cout << \"OpenGL version is NULL\" << std::endl;\n\n    glimac::Sphere sphere(1, 32, 16);\n    GLuint vbo, vao;\n    utils::createVBOAndVAO(vbo, vao, sphere);\n\n    glimac::FilePath applicationPath(argv[0]);\n    std::string vertexShaderPath = applicationPath.dirPath() + \"APP1/shaders/\" + (argc > 1 ? argv[1] : \"sphere.vs.glsl\");\n    std::string fragmentShaderPath = applicationPath.dirPath() + \"APP1/shaders/\" + (argc > 2 ? argv[2] : \"sphere.fs.glsl\");\n\n    glimac::Program program = glimac::loadProgram(vertexShaderPath, fragmentShaderPath);\n    if (program.getGLId() == 0) {\n        std::cerr << \"Failed to load shaders\" << std::endl;\n        return -1;\n    }\n\n    program.use();\n    GLint uMVPMatrixLocation = glGetUniformLocation(program.getGLId(), \"uMVPMatrix\");\n    GLint uMVMatrixLocation = glGetUniformLocation(program.getGLId(), \"uMVMatrix\");\n    GLint uNormalMatrixLocation = glGetUniformLocation(program.getGLId(), \"uNormalMatrix\");\n    if (uMVPMatrixLocation == -1 || uMVMatrixLocation == -1 || uNormalMatrixLocation == -1) {\n        std::cerr << \"Failed to get uniform locations\" << std::endl;\n        return -1;\n    }\n\n    glEnable(GL_DEPTH_TEST);\n    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n\n    utils::Camera camera({0.0f, 0.0f, 5.0f});\n    SDL_SetRelativeMouseMode(SDL_TRUE);\n\n    bool done = false;\n    std::cout << \"Entering main loop\" << std::endl;\n    while (!done) {\n        float deltaTime = utils::calculateDeltaTime(windowManager);\n\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        done = utils::handleInput(camera, windowManager, deltaTime, mouseSensitivity);\n\n        glm::mat4 ProjMatrix = glm::perspective(\n            glm::radians(70.0f), window_width / (float)window_height, 0.1f, 100.0f);\n        glm::mat4 ViewMatrix = camera.getViewMatrix();\n        glm::mat4 ModelMatrix = glm::mat4(1.0f);\n\n        glm::mat4 MVMatrix = ViewMatrix * ModelMatrix;\n        glm::mat4 MVPMatrix = ProjMatrix * MVMatrix;\n        glm::mat4 NormalMatrix = glm::transpose(glm::inverse(MVMatrix));\n\n        glUniformMatrix4fv(uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(MVMatrix));\n        glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(MVPMatrix));\n        glUniformMatrix4fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(NormalMatrix));\n\n        utils::renderSphere(vao, sphere);\n\n        windowManager.swapBuffers();\n    }\n\n    glDeleteBuffers(1, &vbo);\n    glDeleteVertexArrays(1, &vao);\n    std::cout << \"Program terminated successfully\" << std::endl;\n\n    return 0;\n}",
    "APP1/utils/Init.hpp": "#ifndef INIT_HPP\n#define INIT_HPP\n\n#include <SDL2/SDL.h>\n#include <glad/glad.h>\n#include <glimac/Sphere.hpp>\n#include <iostream>\n\n\nnamespace utils {\n\n    void createVBOAndVAO(GLuint& vbo, GLuint& vao, const glimac::Sphere& sphere);\n\n} // namespace utils\n\n#endif // INIT_HPP",
    "APP1/utils/Render.cpp": "#include \"Render.hpp\"\n\nnamespace utils {\n\n    void renderSphere(GLuint vao, const glimac::Sphere& sphere) {\n        glBindVertexArray(vao);\n        glDrawArrays(GL_TRIANGLES, 0, sphere.getVertexCount());\n        glBindVertexArray(0);\n    }\n\n} // namespace utils",
    "APP1/utils/Camera.cpp": "#include \"Camera.hpp\"\n\nnamespace utils {\n\n    Camera::Camera(const glm::vec3& initialPosition)\n        : cameraPos(initialPosition), cameraFront(0.0f, 0.0f, -1.0f), cameraUp(0.0f, 1.0f, 0.0f),\n          yaw(-90.0f), pitch(0.0f), initialYPos(initialPosition.y) {}\n\n    glm::mat4 Camera::getViewMatrix() const {\n        return glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);\n    }\n\n    void Camera::processKeyboard(const Uint8* state, float deltaTime) {\n        glm::vec3 frontDirection = glm::normalize(glm::vec3(cameraFront.x, 0.0f, cameraFront.z));\n        glm::vec3 rightDirection = glm::normalize(glm::cross(frontDirection, cameraUp));\n        float speed = deltaTime * cameraSpeed;\n\n        if (state[SDL_SCANCODE_W]) cameraPos += speed * frontDirection;\n        if (state[SDL_SCANCODE_S]) cameraPos -= speed * frontDirection;\n        if (state[SDL_SCANCODE_A]) cameraPos -= speed * rightDirection;\n        if (state[SDL_SCANCODE_D]) cameraPos += speed * rightDirection;\n\n        cameraPos.y = initialYPos;\n    }\n\n    void Camera::processMouseMovement(float xOffset, float yOffset, float sensitivity) {\n        yaw += xOffset * sensitivity;\n        pitch -= yOffset * sensitivity;\n\n        if (pitch > 89.0f) pitch = 89.0f;\n        if (pitch < -89.0f) pitch = -89.0f;\n\n        glm::vec3 front;\n        front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));\n        front.y = sin(glm::radians(pitch));\n        front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));\n        cameraFront = glm::normalize(front);\n    }\n\n    bool handleInput(Camera& camera, glimac::SDLWindowManager& windowManager, float deltaTime, float sensitivity) {\n        SDL_Event e;\n        while (windowManager.pollEvent(e)) {\n            if (e.type == SDL_QUIT) return true;\n            if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE) return true;\n            if (e.type == SDL_MOUSEMOTION) {\n                camera.processMouseMovement(e.motion.xrel, e.motion.yrel, sensitivity);\n            }\n        }\n        const Uint8* state = SDL_GetKeyboardState(NULL);\n        camera.processKeyboard(state, deltaTime);\n        return false;\n    }\n\n    float calculateDeltaTime(glimac::SDLWindowManager& windowManager) {\n        static float lastFrame = 0.0f;\n        float currentFrame = windowManager.getTime();\n        float deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n        return deltaTime;\n    }\n\n} // namespace utils",
    "APP1/utils/Render.hpp": "#ifndef RENDER_HPP\n#define RENDER_HPP\n\n#include <glimac/Sphere.hpp>\n#include <glad/glad.h>\n\nnamespace utils {\n\n    void renderSphere(GLuint vao, const glimac::Sphere& sphere);\n\n} // namespace utils\n\n#endif // RENDER_HPP",
    "APP1/utils/Init.cpp": "#include \"Init.hpp\"\n#include <glimac/Sphere.hpp>\n#include <glad/glad.h>\n\nnamespace utils {\n\n    void createVBOAndVAO(GLuint& vbo, GLuint& vao, const glimac::Sphere& sphere) {\n        glGenBuffers(1, &vbo);\n        glBindBuffer(GL_ARRAY_BUFFER, vbo);\n        glBufferData(GL_ARRAY_BUFFER, sphere.getVertexCount() * sizeof(glimac::ShapeVertex), sphere.getDataPointer(), GL_STATIC_DRAW);\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n        glGenVertexArrays(1, &vao);\n        glBindVertexArray(vao);\n        glBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n        glEnableVertexAttribArray(0);\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, position));\n\n        glEnableVertexAttribArray(1);\n        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, normal));\n\n        glEnableVertexAttribArray(2);\n        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, texCoords));\n\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        glBindVertexArray(0);\n    }\n\n} // namespace utils",
    "APP1/utils/Camera.hpp": "#ifndef CAMERA_HPP\n#define CAMERA_HPP\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include \"glimac/SDLWindowManager.hpp\"\n\nnamespace utils {\n\n    constexpr float cameraSpeed = 5.0f;\n\n    class Camera {\n    public:\n        explicit Camera(const glm::vec3& initialPosition);\n        glm::mat4 getViewMatrix() const;\n        void processKeyboard(const Uint8* state, float deltaTime);\n        void processMouseMovement(float xOffset, float yOffset, float sensitivity);\n\n        glm::vec3 getPosition() const { return cameraPos; }\n\n    private:\n        glm::vec3 cameraPos;\n        glm::vec3 cameraFront;\n        glm::vec3 cameraUp;\n        float yaw;\n        float pitch;\n        const float initialYPos;\n    };\n\n    bool handleInput(Camera& camera, glimac::SDLWindowManager& windowManager, float deltaTime, float sensitivity);\n    float calculateDeltaTime(glimac::SDLWindowManager& windowManager);\n\n} // namespace utils\n\n#endif // CAMERA_HPP",
    "APP1/shaders/sphere.vs.glsl": "#version 330 core\n\n// Input attributes from the VBO\nlayout(location = 0) in vec3 aVertexPosition; // Vertex position\nlayout(location = 1) in vec3 aVertexNormal;   // Vertex normal\nlayout(location = 2) in vec2 aVertexTexCoords; // Vertex texture coordinates\n\n// Uniforms for transformation matrices\nuniform mat4 uMVPMatrix;     // Model-View-Projection matrix\nuniform mat4 uMVMatrix;      // Model-View matrix\nuniform mat4 uNormalMatrix;  // Normal matrix\n\n// Outputs to the fragment shader\nout vec3 vPosition_vs;       // Vertex position in view space\nout vec3 vNormal_vs;         // Normal vector in view space\nout vec2 vTexCoords;         // Texture coordinates\n\nvoid main() {\n    // Transform the vertex position to view space and pass to fragment shader\n    vPosition_vs = vec3(uMVMatrix * vec4(aVertexPosition, 1.0));\n\n    // Transform the normal vector to view space and pass to fragment shader\n    vNormal_vs = vec3(uNormalMatrix * vec4(aVertexNormal, 0.0));\n\n    // Pass texture coordinates directly to the fragment shader\n    vTexCoords = aVertexTexCoords;\n\n    // Compute the final position of the vertex in clip space\n    gl_Position = uMVPMatrix * vec4(aVertexPosition, 1.0);\n}",
    "APP1/shaders/sphere.fs.glsl": "#version 330 core\n\n// Inputs from the vertex shader\nin vec3 vPosition_vs;   // Position in view space\nin vec3 vNormal_vs;     // Normal in view space\nin vec2 vTexCoords;     // Texture coordinates\n\n// Output color\nout vec4 FragColor;\n\nvoid main() {\n    // Normalize the normal vector\n    vec3 normal = normalize(vNormal_vs);\n    \n    // Use the normalized normal vector as the fragment color (for debugging purposes)\n    FragColor = vec4(normal * 0.5 + 0.5, 1.0); // Shift from [-1, 1] to [0, 1]\n}"
}