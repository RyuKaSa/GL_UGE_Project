{
    "APP1/main.cpp": "#define GLFW_INCLUDE_NONE\n#include <glad/glad.h>\n#include <iostream>\n#include <glimac/Sphere.hpp>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <glimac/Program.hpp>\n#include <SDL2/SDL.h>\n#include <cstddef> // For offsetof\n#include <glimac/FilePath.hpp>\n#include <vector>\n\n#include \"glimac/SDLWindowManager.hpp\"\n#include \"utils/Init.hpp\"\n#include \"utils/Render.hpp\"\n#include \"utils/Camera.hpp\"\n#include \"utils/Lighting.hpp\"\n\nconstexpr int window_width = 800;\nconstexpr int window_height = 800;\nconstexpr float mouseSensitivity = 0.1f;\n\n#define NR_POINT_LIGHTS 10\n\nvoid setupGBuffer(GLuint &gBuffer, GLuint &gPosition, GLuint &gNormal, GLuint &gAlbedoSpec) {\n    glGenFramebuffers(1, &gBuffer);\n    glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);\n\n    // Position buffer\n    glGenTextures(1, &gPosition);\n    glBindTexture(GL_TEXTURE_2D, gPosition);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, window_width, window_height, 0, GL_RGB, GL_FLOAT, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition, 0);\n\n    // Normal buffer\n    glGenTextures(1, &gNormal);\n    glBindTexture(GL_TEXTURE_2D, gNormal);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, window_width, window_height, 0, GL_RGB, GL_FLOAT, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, gNormal, 0);\n\n    // Albedo + specular buffer\n    glGenTextures(1, &gAlbedoSpec);\n    glBindTexture(GL_TEXTURE_2D, gAlbedoSpec);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, window_width, window_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, gAlbedoSpec, 0);\n\n    // Specify the attachments for the framebuffer\n    GLuint attachments[3] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2 };\n    glDrawBuffers(3, attachments);\n\n    // Depth buffer\n    GLuint rboDepth;\n    glGenRenderbuffers(1, &rboDepth);\n    glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);\n    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, window_width, window_height);\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);\n\n    // Check if framebuffer is complete\n    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)\n        std::cerr << \"Framebuffer not complete!\" << std::endl;\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n}\n\nGLuint createFullScreenQuad() {\n    GLuint quadVAO, quadVBO;\n    float quadVertices[] = {\n        // positions   // texCoords\n        -1.0f,  1.0f,  0.0f,  1.0f,\n        -1.0f, -1.0f,  0.0f,  0.0f,\n         1.0f, -1.0f,  1.0f,  0.0f,\n\n        -1.0f,  1.0f,  0.0f,  1.0f,\n         1.0f, -1.0f,  1.0f,  0.0f,\n         1.0f,  1.0f,  1.0f,  1.0f\n    };\n    glGenVertexArrays(1, &quadVAO);\n    glGenBuffers(1, &quadVBO);\n    glBindVertexArray(quadVAO);\n    glBindBuffer(GL_ARRAY_BUFFER, quadVBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));\n    glBindVertexArray(0);\n    return quadVAO;\n}\n\nint main(int argc, char* argv[]) {\n    (void)argc;\n    (void)argv;\n    std::cout << \"Program started\" << std::endl;\n\n    // Initialize SDL video subsystem\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        std::cerr << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n        return -1;\n    }\n\n    // Set OpenGL context version and profile\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MAJOR_VERSION: \" << SDL_GetError() << std::endl;\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MINOR_VERSION: \" << SDL_GetError() << std::endl;\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_PROFILE_MASK: \" << SDL_GetError() << std::endl;\n\n#ifdef __APPLE__\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_FLAGS: \" << SDL_GetError() << std::endl;\n#endif\n\n    glimac::SDLWindowManager windowManager(window_width, window_height, \"Deferred Rendering\");\n    std::cout << \"SDLWindowManager initialized\" << std::endl;\n\n    // Initialize GLAD\n    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress)) {\n        std::cerr << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n    std::cout << \"GLAD initialized\" << std::endl;\n\n    // Output OpenGL version and renderer\n    const GLubyte *renderer = glGetString(GL_RENDERER);\n    const GLubyte *version = glGetString(GL_VERSION);\n    if (renderer)\n        std::cout << \"Renderer: \" << renderer << std::endl;\n    else\n        std::cout << \"Renderer is NULL\" << std::endl;\n\n    if (version)\n        std::cout << \"OpenGL version supported: \" << version << std::endl;\n    else\n        std::cout << \"OpenGL version is NULL\" << std::endl;\n\n    glimac::Sphere sphere(1, 32, 16);\n    GLuint vbo, vao;\n    utils::createVBOAndVAO(vbo, vao, sphere);\n\n    glimac::FilePath applicationPath(argv[0]);\n    std::string vertexShaderPath = applicationPath.dirPath() + \"APP1/shaders/deferred_gbuffer.vs.glsl\";\n    std::string fragmentShaderPath = applicationPath.dirPath() + \"APP1/shaders/deferred_gbuffer.fs.glsl\";\n    glimac::Program gBufferProgram = glimac::loadProgram(vertexShaderPath, fragmentShaderPath);\n    if (gBufferProgram.getGLId() == 0) {\n        std::cerr << \"Failed to load gbuffer shaders\" << std::endl;\n        return -1;\n    }\n\n    std::string lightingVertexShaderPath = applicationPath.dirPath() + \"APP1/shaders/deferred_lighting.vs.glsl\";\n    std::string lightingFragmentShaderPath = applicationPath.dirPath() + \"APP1/shaders/deferred_lighting.fs.glsl\";\n    glimac::Program lightingProgram = glimac::loadProgram(lightingVertexShaderPath, lightingFragmentShaderPath);\n    if (lightingProgram.getGLId() == 0) {\n        std::cerr << \"Failed to load lighting shaders\" << std::endl;\n        return -1;\n    }\n\n    glm::mat4 ModelMatrix = glm::mat4(1.0f);\n\n    gBufferProgram.use();\n\n    GLint uMVPMatrixLocation = glGetUniformLocation(gBufferProgram.getGLId(), \"uMVPMatrix\");\n    GLint uNormalMatrixLocation = glGetUniformLocation(gBufferProgram.getGLId(), \"uNormalMatrix\");\n    GLint uModelMatrixLocation = glGetUniformLocation(gBufferProgram.getGLId(), \"uModelMatrix\");\n\n    // Debugging Output\n    std::cout << \"Uniform Locations gBuffer:\\n\";\n    std::cout << \"uMVPMatrix: \" << uMVPMatrixLocation << \"\\n\";\n    std::cout << \"uNormalMatrix: \" << uNormalMatrixLocation << \"\\n\";\n    std::cout << \"uModelMatrix: \" << uModelMatrixLocation << \"\\n\";\n\n    if (uMVPMatrixLocation == -1 || uNormalMatrixLocation == -1 || uModelMatrixLocation == -1) {\n        std::cerr << \"One or more uniform locations could not be found. Exiting.\" << std::endl;\n        return -1;\n    }\n\n    // If all uniform locations are found, set any required initial values.\n    if (uModelMatrixLocation != -1) {\n        glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(ModelMatrix));\n    }\n\n    // Setup G-Buffer\n    GLuint gBuffer, gPosition, gNormal, gAlbedoSpec;\n    setupGBuffer(gBuffer, gPosition, gNormal, gAlbedoSpec);\n\n    // Full-screen quad for lighting pass\n    GLuint quadVAO = createFullScreenQuad();\n\n    // Setup point lights\n    std::vector<utils::PointLight> pointLights;\n    utils::PointLight light1;\n    light1.position = glm::vec3(2.0f, 2.0f, 2.0f);\n    light1.color = glm::vec3(1.0f, 0.0f, 0.0f); // Red light\n    light1.intensity = 1.0f;\n    pointLights.push_back(light1);\n\n    utils::PointLight light2;\n    light2.position = glm::vec3(-2.0f, 2.0f, 2.0f);\n    light2.color = glm::vec3(0.0f, 1.0f, 0.0f); // Green light\n    light2.intensity = 1.0f;\n    pointLights.push_back(light2);\n\n    glEnable(GL_DEPTH_TEST);\n    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n\n    utils::Camera camera({0.0f, 0.0f, 5.0f});\n    SDL_SetRelativeMouseMode(SDL_TRUE);\n\n    bool done = false;\n    std::cout << \"Entering main loop\" << std::endl;\n    while (!done) {\n        float deltaTime = utils::calculateDeltaTime(windowManager);\n\n        // Geometry Pass\n        glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        gBufferProgram.use();\n        {\n            glm::mat4 ProjMatrix = glm::perspective(glm::radians(70.0f), window_width / (float)window_height, 0.1f, 100.0f);\n            glm::mat4 ViewMatrix = camera.getViewMatrix();\n            glm::mat4 ModelMatrix = glm::mat4(1.0f);\n\n            glm::mat4 MVPMatrix = ProjMatrix * ViewMatrix * ModelMatrix;\n            glm::mat4 NormalMatrix = glm::transpose(glm::inverse(ViewMatrix * ModelMatrix));\n\n            glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(MVPMatrix));\n            glUniformMatrix4fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(NormalMatrix));\n            glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(ModelMatrix));\n\n            utils::renderSphere(vao, sphere);\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n        // Lighting Pass\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        lightingProgram.use();\n\n        // Set the lighting uniforms\n        GLint uKsLocation = glGetUniformLocation(lightingProgram.getGLId(), \"uKs\");\n        GLint uShininessLocation = glGetUniformLocation(lightingProgram.getGLId(), \"uShininess\");\n        GLint uCameraPosLocation = glGetUniformLocation(lightingProgram.getGLId(), \"cameraPosWorld\");\n\n        if (uKsLocation != -1) {\n            glUniform3f(uKsLocation, 0.5f, 0.5f, 0.5f); // Example value for Ks (specular reflection coefficient)\n        } else {\n            std::cerr << \"Uniform uKs not found!\" << std::endl;\n        }\n\n        if (uShininessLocation != -1) {\n            glUniform1f(uShininessLocation, 32.0f); // Example value for shininess\n        } else {\n            std::cerr << \"Uniform uShininess not found!\" << std::endl;\n        }\n\n        // Passing camera position in world space\n        if (uCameraPosLocation != -1) {\n            glm::vec3 cameraPos = camera.getPosition(); // Ensure this returns world space position\n            glUniform3fv(uCameraPosLocation, 1, glm::value_ptr(cameraPos));\n        } else {\n            std::cerr << \"Uniform cameraPosWorld not found!\" << std::endl;\n        }\n\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, gPosition);\n        glUniform1i(glGetUniformLocation(lightingProgram.getGLId(), \"gPosition\"), 0);\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_2D, gNormal);\n        glUniform1i(glGetUniformLocation(lightingProgram.getGLId(), \"gNormal\"), 1);\n        glActiveTexture(GL_TEXTURE2);\n        glBindTexture(GL_TEXTURE_2D, gAlbedoSpec);\n        glUniform1i(glGetUniformLocation(lightingProgram.getGLId(), \"gAlbedoSpec\"), 2);\n\n        // Set number of point lights\n        glUniform1i(glGetUniformLocation(lightingProgram.getGLId(), \"numPointLights\"), pointLights.size());\n\n        // Set point lights uniforms\n        for (int i = 0; i < pointLights.size(); ++i) {\n            std::string baseName = \"pointLights[\" + std::to_string(i) + \"]\";\n            std::string positionName = baseName + \".position\";\n            std::string colorName = baseName + \".color\";\n            std::string intensityName = baseName + \".intensity\";\n\n            GLint positionLoc = glGetUniformLocation(lightingProgram.getGLId(), positionName.c_str());\n            GLint colorLoc = glGetUniformLocation(lightingProgram.getGLId(), colorName.c_str());\n            GLint intensityLoc = glGetUniformLocation(lightingProgram.getGLId(), intensityName.c_str());\n\n            if (positionLoc != -1 && colorLoc != -1 && intensityLoc != -1) {\n                glUniform3fv(positionLoc, 1, glm::value_ptr(pointLights[i].position));\n                glUniform3fv(colorLoc, 1, glm::value_ptr(pointLights[i].color));\n                glUniform1f(intensityLoc, pointLights[i].intensity);\n            } else {\n                std::cerr << \"Failed to get uniform locations for pointLights[\" << i << \"]\" << std::endl;\n            }\n        }\n\n        // Draw the quad\n        glBindVertexArray(quadVAO);\n        glDrawArrays(GL_TRIANGLES, 0, 6);\n        glBindVertexArray(0);\n\n        // Handle input and swap buffers\n        windowManager.swapBuffers();\n        done = utils::handleInput(camera, windowManager, deltaTime, mouseSensitivity);\n    }\n\n    glDeleteBuffers(1, &vbo);\n    glDeleteVertexArrays(1, &vao);\n    std::cout << \"Program terminated successfully\" << std::endl;\n\n    return 0;\n}",
    "APP1/utils/Init.hpp": "#ifndef INIT_HPP\n#define INIT_HPP\n\n#include <SDL2/SDL.h>\n#include <glad/glad.h>\n#include <glimac/Sphere.hpp>\n#include <iostream>\n\nnamespace utils {\n\n    void createVBOAndVAO(GLuint& vbo, GLuint& vao, const glimac::Sphere& sphere);\n\n} // namespace utils\n\n#endif // INIT_HPP",
    "APP1/utils/Render.cpp": "#include \"Render.hpp\"\n\nnamespace utils {\n\n    void renderSphere(GLuint vao, const glimac::Sphere& sphere) {\n        glBindVertexArray(vao);\n        glDrawArrays(GL_TRIANGLES, 0, sphere.getVertexCount());\n        glBindVertexArray(0);\n    }\n\n} // namespace utils",
    "APP1/utils/Camera.cpp": "#include \"Camera.hpp\"\n\nnamespace utils {\n\n    Camera::Camera(const glm::vec3& initialPosition)\n        : cameraPos(initialPosition), cameraFront(0.0f, 0.0f, -1.0f), cameraUp(0.0f, 1.0f, 0.0f),\n          yaw(-90.0f), pitch(0.0f), initialYPos(initialPosition.y) {}\n\n    glm::mat4 Camera::getViewMatrix() const {\n        return glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);\n    }\n\n    void Camera::processKeyboard(const Uint8* state, float deltaTime) {\n        glm::vec3 frontDirection = glm::normalize(glm::vec3(cameraFront.x, 0.0f, cameraFront.z));\n        glm::vec3 rightDirection = glm::normalize(glm::cross(frontDirection, cameraUp));\n        float speed = deltaTime * cameraSpeed;\n\n        if (state[SDL_SCANCODE_W]) cameraPos += speed * frontDirection;\n        if (state[SDL_SCANCODE_S]) cameraPos -= speed * frontDirection;\n        if (state[SDL_SCANCODE_A]) cameraPos -= speed * rightDirection;\n        if (state[SDL_SCANCODE_D]) cameraPos += speed * rightDirection;\n\n        cameraPos.y = initialYPos;\n    }\n\n    void Camera::processMouseMovement(float xOffset, float yOffset, float sensitivity) {\n        yaw += xOffset * sensitivity;\n        pitch -= yOffset * sensitivity;\n\n        if (pitch > 89.0f) pitch = 89.0f;\n        if (pitch < -89.0f) pitch = -89.0f;\n\n        glm::vec3 front;\n        front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));\n        front.y = sin(glm::radians(pitch));\n        front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));\n        cameraFront = glm::normalize(front);\n    }\n\n    bool handleInput(Camera& camera, glimac::SDLWindowManager& windowManager, float deltaTime, float sensitivity) {\n        SDL_Event e;\n        while (windowManager.pollEvent(e)) {\n            if (e.type == SDL_QUIT) return true;\n            if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE) return true;\n            if (e.type == SDL_MOUSEMOTION) {\n                camera.processMouseMovement(e.motion.xrel, e.motion.yrel, sensitivity);\n            }\n        }\n        const Uint8* state = SDL_GetKeyboardState(NULL);\n        camera.processKeyboard(state, deltaTime);\n        return false;\n    }\n\n    float calculateDeltaTime(glimac::SDLWindowManager& windowManager) {\n        static float lastFrame = 0.0f;\n        float currentFrame = windowManager.getTime();\n        float deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n        return deltaTime;\n    }\n\n} // namespace utils",
    "APP1/utils/Lighting.cpp": "#include \"Lighting.hpp\"\n",
    "APP1/utils/Lighting.hpp": "#ifndef LIGHTING_HPP\n#define LIGHTING_HPP\n\n#include <glm/glm.hpp>\n\nnamespace utils {\n\n    struct PointLight {\n        glm::vec3 position;\n        glm::vec3 color;\n        float intensity;\n    };\n\n} // namespace utils\n\n#endif // LIGHTING_HPP",
    "APP1/utils/Render.hpp": "#ifndef RENDER_HPP\n#define RENDER_HPP\n\n#include <glimac/Sphere.hpp>\n#include <glad/glad.h>\n\nnamespace utils {\n\n    void renderSphere(GLuint vao, const glimac::Sphere& sphere);\n\n} // namespace utils\n\n#endif // RENDER_HPP",
    "APP1/utils/Init.cpp": "#include \"Init.hpp\"\n\nnamespace utils {\n\n    void createVBOAndVAO(GLuint& vbo, GLuint& vao, const glimac::Sphere& sphere) {\n        glGenBuffers(1, &vbo);\n        glBindBuffer(GL_ARRAY_BUFFER, vbo);\n        glBufferData(GL_ARRAY_BUFFER, sphere.getVertexCount() * sizeof(glimac::ShapeVertex), sphere.getDataPointer(), GL_STATIC_DRAW);\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n        glGenVertexArrays(1, &vao);\n        glBindVertexArray(vao);\n        glBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n        glEnableVertexAttribArray(0);\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, position));\n\n        glEnableVertexAttribArray(1);\n        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, normal));\n\n        glEnableVertexAttribArray(2);\n        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(glimac::ShapeVertex), (void*)offsetof(glimac::ShapeVertex, texCoords));\n\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        glBindVertexArray(0);\n    }\n\n} // namespace utils",
    "APP1/utils/Camera.hpp": "#ifndef CAMERA_HPP\n#define CAMERA_HPP\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include \"glimac/SDLWindowManager.hpp\"\n\nnamespace utils {\n\n    constexpr float cameraSpeed = 5.0f;\n\n    class Camera {\n    public:\n        explicit Camera(const glm::vec3& initialPosition);\n        glm::mat4 getViewMatrix() const;\n        void processKeyboard(const Uint8* state, float deltaTime);\n        void processMouseMovement(float xOffset, float yOffset, float sensitivity);\n\n        glm::vec3 getPosition() const { return cameraPos; }\n\n    private:\n        glm::vec3 cameraPos;\n        glm::vec3 cameraFront;\n        glm::vec3 cameraUp;\n        float yaw;\n        float pitch;\n        const float initialYPos;\n    };\n\n    bool handleInput(Camera& camera, glimac::SDLWindowManager& windowManager, float deltaTime, float sensitivity);\n    float calculateDeltaTime(glimac::SDLWindowManager& windowManager);\n\n} // namespace utils\n\n#endif // CAMERA_HPP",
    "APP1/shaders/deferred_gbuffer.fs.glsl": "#version 330 core\n\nin vec3 FragPosWorld;\nin vec3 NormalWorld;\nin vec2 TexCoords;\n\nlayout(location = 0) out vec3 gPosition;\nlayout(location = 1) out vec3 gNormal;\nlayout(location = 2) out vec4 gAlbedoSpec;\n\nvoid main() {\n    gPosition = FragPosWorld;\n    gNormal = normalize(NormalWorld);\n    gAlbedoSpec.rgb = vec3(1.0, 1.0, 1.0); // Albedo\n    gAlbedoSpec.a = 1.0; // Specular intensity\n}",
    "APP1/shaders/deferred_lighting.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec2 aPos; // Changed from vec3 to vec2\n\nvoid main() {\n    gl_Position = vec4(aPos, 0.0, 1.0); // Set Z to 0.0 and W to 1.0\n}",
    "APP1/shaders/sphere.vs.glsl": "#version 330 core\n\n// Input attributes from the VBO\nlayout(location = 0) in vec3 aVertexPosition; // Vertex position\nlayout(location = 1) in vec3 aVertexNormal;   // Vertex normal\nlayout(location = 2) in vec2 aVertexTexCoords; // Vertex texture coordinates\n\n// Uniforms for transformation matrices\nuniform mat4 uMVPMatrix;     // Model-View-Projection matrix\nuniform mat4 uMVMatrix;      // Model-View matrix\nuniform mat4 uNormalMatrix;  // Normal matrix\n\n// Outputs to the fragment shader\nout vec3 vPosition_vs;       // Vertex position in view space\nout vec3 vNormal_vs;         // Normal vector in view space\nout vec2 vTexCoords;         // Texture coordinates\n\nvoid main() {\n    // Transform the vertex position to view space and pass to fragment shader\n    vPosition_vs = vec3(uMVMatrix * vec4(aVertexPosition, 1.0));\n\n    // Transform the normal vector to view space and pass to fragment shader\n    vNormal_vs = vec3(uNormalMatrix * vec4(aVertexNormal, 0.0));\n\n    // Pass texture coordinates directly to the fragment shader\n    vTexCoords = aVertexTexCoords;\n\n    // Compute the final position of the vertex in clip space\n    gl_Position = uMVPMatrix * vec4(aVertexPosition, 1.0);\n}",
    "APP1/shaders/deferred_gbuffer.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPos;\nlayout(location = 1) in vec3 aNormal;\nlayout(location = 2) in vec2 aTexCoords;\n\nuniform mat4 uMVPMatrix;\nuniform mat4 uNormalMatrix;\nuniform mat4 uModelMatrix; // Ensure this is correctly set\n\nout vec3 FragPosWorld;\nout vec3 NormalWorld;\nout vec2 TexCoords;\n\nvoid main() {\n    gl_Position = uMVPMatrix * vec4(aPos, 1.0);\n    FragPosWorld = vec3(uModelMatrix * vec4(aPos, 1.0)); // Position in world space\n    NormalWorld = mat3(uNormalMatrix) * aNormal; // Normal in world space\n    TexCoords = aTexCoords;\n}",
    "APP1/shaders/deferred_lighting.fs.glsl": "#version 330 core\n\nout vec4 FragColor;\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\n#define NR_POINT_LIGHTS 10\n\nuniform int numPointLights;\nuniform PointLight pointLights[NR_POINT_LIGHTS];\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\n\nuniform vec3 cameraPosWorld; // Camera position in world space\n\n// Blinn-Phong parameters\nuniform vec3 uKs;          // Specular reflection coefficient\nuniform float uShininess;  // Shininess exponent\n\nvoid main() {\n    vec2 TexCoords = gl_FragCoord.xy / textureSize(gPosition, 0);\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = normalize(texture(gNormal, TexCoords).rgb);\n    vec3 Albedo = texture(gAlbedoSpec, TexCoords).rgb;\n    float SpecularIntensity = texture(gAlbedoSpec, TexCoords).a;\n\n    vec3 lighting = vec3(0.0); // Initialize lighting\n\n    // Ambient term\n    vec3 ambient = 0.1 * Albedo;\n    lighting += ambient;\n\n    // View direction\n    vec3 viewDir = normalize(cameraPosWorld - FragPos);\n\n    // Iterate over all point lights\n    for(int i = 0; i < numPointLights; i++) {\n        // Light properties\n        vec3 lightPos = pointLights[i].position;\n        vec3 lightColor = pointLights[i].color;\n        float lightIntensity = pointLights[i].intensity;\n\n        // Light direction\n        vec3 lightDir = normalize(lightPos - FragPos);\n\n        // Diffuse shading\n        float diff = max(dot(Normal, lightDir), 0.0);\n        vec3 diffuse = diff * Albedo * lightColor * lightIntensity;\n\n        // Specular shading (Blinn-Phong)\n        vec3 halfwayDir = normalize(lightDir + viewDir);\n        float spec = pow(max(dot(Normal, halfwayDir), 0.0), uShininess);\n        vec3 specular = uKs * spec * lightColor * lightIntensity * SpecularIntensity;\n\n        // Attenuation\n        float distance = length(lightPos - FragPos);\n        float attenuation = 1.0 / (distance * distance);\n        diffuse *= attenuation;\n        specular *= attenuation;\n\n        // Accumulate\n        lighting += diffuse + specular;\n    }\n\n    FragColor = vec4(lighting, 1.0);\n}",
    "APP1/shaders/sphere.fs.glsl": "#version 330 core\n\n// Inputs from the vertex shader\nin vec3 vPosition_vs;   // Position in view space\nin vec3 vNormal_vs;     // Normal in view space\nin vec2 vTexCoords;     // Texture coordinates\n\n// Output color\nout vec4 FragColor;\n\nvoid main() {\n    // Normalize the normal vector\n    vec3 normal = normalize(vNormal_vs);\n    \n    // Use the normalized normal vector as the fragment color (for debugging purposes)\n    FragColor = vec4(normal * 0.5 + 0.5, 1.0); // Shift from [-1, 1] to [0, 1]\n}"
}