{
    "APP3/main.cpp": "#include \"utils/global.hpp\"\n#include \"utils/cube.hpp\"\n#include \"utils/sphere.hpp\"\n#include \"utils/scene_object.hpp\"\n#include \"utils/texture.hpp\"\n#include \"utils/collision.hpp\"\n#include \"utils/utilities.hpp\"\n#include \"utils/resource_loader.hpp\"\n#include \"utils/models.hpp\"\n#include \"utils/initialization.hpp\"\n#include \"utils/shader.hpp\"\n#include \"utils/rendering.hpp\"\n\n#include <src/stb_image.h>\n\n#include <src/tiny_obj_loader.h>\n\n#include <glad/glad.h>\n#include <iostream>\n#include <filesystem>\n#include <glimac/Program.hpp>\n#include <glimac/Image.hpp>\n#include <glimac/SDLWindowManager.hpp>\n#include <SDL2/SDL.h>\n#include <cstddef> // For offsetof\n#include <vector>\n#include <map>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <glm/glm.hpp> // For vector calculations\n\nint main(int argc, char *argv[])\n{\n    (void)argc;\n\n    auto windowManager = utils_init::initOpenGL(window_width, window_height);\n\n    /*********************************\n     * Initialization code\n     *********************************/\n\n    // Sphere setup\n    glimac::Sphere sphere(1, 32, 16);\n    std::vector<SphereVertex> sphereVertices;\n\n    size_t sphereVertexCount = utils_object::createSphereVertices(sphereVertices, sphere);\n    utils_object::computeSphereTangents(sphereVertices);\n\n    GLuint sphereVBO, sphereVAO;\n    utils_object::setupSphereBuffers(sphereVertices, sphereVBO, sphereVAO);\n\n    GLsizei sphereVertexCountGL = static_cast<GLsizei>(sphereVertexCount);\n\n    // Cube setup\n    // Create cube vertices and indices\n    std::vector<Vertex3D> cubeVertices;\n    std::vector<GLuint> cubeIndices;\n    utils_object::createCube(cubeVertices, cubeIndices);\n    utils_object::computeCubeTangents(cubeVertices, cubeIndices);\n\n    // Set up VBO, EBO, and VAO for the cube\n    GLuint cubeVBO, cubeEBO, cubeVAO;\n    utils_object::setupCubeBuffers(cubeVertices, cubeIndices, cubeVBO, cubeEBO, cubeVAO);\n    std::cout << \"Cube VBO, EBO, and VAO set up\" << std::endl;\n\n    glimac::FilePath applicationPath(argv[0]);\n\n    // Load shaders\n    utils_loader::Shader unifiedShader(\n        applicationPath.dirPath() + \"APP1/shaders/unified_shader.vs.glsl\",\n        applicationPath.dirPath() + \"APP1/shaders/pointlight.fs.glsl\"\n    );\n\n    utils_loader::Shader depthShader(\n        applicationPath.dirPath() + \"APP1/shaders/point_shadow_depth.vs.glsl\",\n        applicationPath.dirPath() + \"APP1/shaders/point_shadow_depth.fs.glsl\"\n    );\n\n    // check shaders\n    if (unifiedShader.getID() == 0 || depthShader.getID() == 0) {\n        std::cerr << \"Failed to compile/link shaders. Exiting.\" << std::endl;\n        return -1;\n    }\n\n    unifiedShader.use();\n    std::cout << \"Unified shader program in use\" << std::endl;\n\n    // Load textures\n    GLuint textureID, stoneTextureID, brownTerracottaTextureID, soccerTextureID;\n    GLuint textureID_normalMap, stoneTextureID_normalMap, brownTerracottaTextureID_normalMap, soccerTextureID_normalMap;\n    GLuint chairBaseColorTextureID, chairNormalMapTextureID;\n    utils_loader::loadTextures(textureID, stoneTextureID, brownTerracottaTextureID, soccerTextureID,\n                textureID_normalMap, stoneTextureID_normalMap, brownTerracottaTextureID_normalMap, soccerTextureID_normalMap,\n                chairBaseColorTextureID, chairNormalMapTextureID, \n                applicationPath);\n\n    GLuint depthCubeMap, shadowMapFBO;\n    utils_loader::setupDepthCubeMap(depthCubeMap, shadowMapFBO);\n\n    // Check depth shader uniforms\n    std::cout << \"Checking depth shader uniforms...\" << std::endl;\n\n    GLint uDepth_LightSpaceMatrixLocation = depthShader.getUniformLocation(\"uLightSpaceMatrix\");\n    if (uDepth_LightSpaceMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uLightSpaceMatrix' location in depth shader\" << std::endl;\n\n    GLint uDepth_ModelMatrixLocation = unifiedShader.getUniformLocation(\"uModelMatrix\");\n    if (uDepth_ModelMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uModelMatrix' location in depth shader\" << std::endl;\n\n    // Get uniform location for model matrix in unified shader\n    GLint uModelMatrixLocation = unifiedShader.getUniformLocation(\"uModelMatrix\");\n    if (uModelMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uModelMatrix' location in unified shader\" << std::endl;\n\n    // Get uniform locations\n    unifiedShader.use();\n    std::cout << \"Shader program in use\" << std::endl;\n\n    // Get uniform locations\n    GLint uMVPMatrixLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uMVPMatrix\");\n    GLint uMVMatrixLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uMVMatrix\");\n    GLint uNormalMatrixLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uNormalMatrix\");\n    GLint uTextureLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uTexture\");\n    GLint uUseTextureLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uUseTexture\");\n\n    GLint uKdLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uKd\");\n    GLint uKsLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uKs\");\n    GLint uShininessLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uShininess\");\n    GLint uLightPos_vsLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uLightPos_vs\");\n    GLint uLightIntensityLocation = glGetUniformLocation(unifiedShader.getGLId(), \"uLightIntensity\");\n\n    // Sanity check\n    if (uMVPMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uMVPMatrix' location\" << std::endl;\n    if (uMVMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uMVMatrix' location\" << std::endl;\n    if (uNormalMatrixLocation == -1)\n        std::cerr << \"Failed to get 'uNormalMatrix' location\" << std::endl;\n    if (uTextureLocation == -1)\n        std::cerr << \"Failed to get 'uTexture' location\" << std::endl;\n    if (uUseTextureLocation == -1)\n        std::cerr << \"Failed to get 'uUseTexture' location\" << std::endl;\n    if (uKdLocation == -1)\n        std::cerr << \"Failed to get 'uKd' location\" << std::endl;\n    if (uKsLocation == -1)\n        std::cerr << \"Failed to get 'uKs' location\" << std::endl;\n    if (uShininessLocation == -1)\n        std::cerr << \"Failed to get 'uShininess' location\" << std::endl;\n    // if (uLightDir_vsLocation == -1)\n    //     std::cerr << \"Failed to get 'uLightDir_vs' location\" << std::endl;\n    if (uLightIntensityLocation == -1)\n        std::cerr << \"Failed to get 'uLightIntensity' location\" << std::endl;\n\n    // Enable depth test\n    glEnable(GL_DEPTH_TEST);\n    std::cout << \"Depth test enabled\" << std::endl;\n\n    // Set the clear color to a dark gray\n    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n\n    // Light properties\n    float spiralRadius = 3.0f; // Radius of the spiral\n    float spiralSpeed = 1.0f;   // Speed of the spiral movement\n    float lightHeight = 5.0f;   // Height variation of the light\n\n    // Light space matrix for shadows\n    glm::mat4 lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, 1.0f, 50.0f);\n    glm::mat4 lightView = glm::lookAt(glm::vec3(5.0f, 10.0f, 5.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));\n    glm::mat4 lightSpaceMatrix = lightProjection * lightView;\n\n    // Setup projection matrix for cube map\n    float nearPlane = 1.0f;\n    float farPlane = 25.0f;\n    glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), 1.0f, nearPlane, farPlane);\n\n    // Camera parameters\n    glm::vec3 cameraPos(1.0f, 2.0f, 1.0f);    // Initial position of the camera\n    glm::vec3 cameraFront(0.0f, 0.0f, -1.0f); // Direction the camera is looking at\n    glm::vec3 cameraUp(0.0f, 1.0f, 0.0f);     // Up vector\n\n    float cameraPosY = cameraPos.y; // Store the initial y position\n\n    float yaw = -90.0f; // Yaw angle initialized to -90 degrees to look towards negative Z\n    float pitch = 0.0f; // Pitch angle\n\n    float cameraSpeed = 10.0f; // Adjust accordingly\n    float deltaTime = 0.0f;   // Time between current frame and last frame\n    float lastFrame = 0.0f;   // Time of last frame\n\n    // Enable relative mouse mode to capture mouse movement\n    SDL_SetRelativeMouseMode(SDL_TRUE);\n\n    int frameCount = 0;\n    float fpsTimer = 0.0f;\n    int fps = 0;\n\n    // =======================\n    // Scene objects creation\n\n    // Prepare to add objects to the scene\n    GLsizei cubeIndexCount = static_cast<GLsizei>(cubeIndices.size());\n    // GLsizei sphereVertexCount = sphere.getVertexCount();\n\n    // floor\n    glm::vec3 origin(0.0f, 0.0f, 0.0f);\n    glm::vec3 floorSize(42.0f, 1.0f, 24.0f);\n    utils_scene::createCompositeCube(\"floor\", origin, floorSize, stoneTextureID, stoneTextureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // wall X1\n    glm::vec3 wallPosition1(0.0f, 1.0f, 0.0f);\n    glm::vec3 wallSizeX(42.0f, 3.0f, 1.0f);\n    utils_scene::createCompositeCube(\"wall_X1\", wallPosition1, wallSizeX, textureID, textureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // wall X2\n    glm::vec3 wallPosition2(0.0f, 1.0f, 23.0f);\n    utils_scene::createCompositeCube(\"wall_X2\", wallPosition2, wallSizeX, textureID, textureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // wall Z1\n    glm::vec3 wallPosition3(0.0f, 1.0f, 1.0f);\n    glm::vec3 wallSizeZ1(1.0f, 3.0f, 22.0f);\n    utils_scene::createCompositeCube(\"wall_Z1\", wallPosition3, wallSizeZ1, textureID, textureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // wall Z2\n    glm::vec3 wallPosition4(41.0f, 1.0f, 1.0f);\n    utils_scene::createCompositeCube(\"wall_Z2\",wallPosition4, wallSizeZ1, textureID, textureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // separation wall, Z3\n    glm::vec3 wallPosition5(20.0f, 1.0f, 1.0f);\n    glm::vec3 wallSizeZ2(2.0f, 3.0f, 9.0f);\n    utils_scene::createCompositeCube(\"wall_Z3\",wallPosition5, wallSizeZ2, brownTerracottaTextureID, brownTerracottaTextureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // separation wall, Z4\n    glm::vec3 wallPosition6(20.0f, 1.0f, 14.0f);\n    utils_scene::createCompositeCube(\"wall_Z4\",wallPosition6, wallSizeZ2, brownTerracottaTextureID, brownTerracottaTextureID_normalMap, cubeVAO, cubeIndexCount, true);\n\n    // load a soccer ball as sophisticated object\n    // Add sphere to the scene\n    utils_scene::addSphere(\n        \"soccer_ball\",               // Name\n        glm::vec3(5.0f, 1.5f, 5.0f), // Position\n        0.3f,                        // Radius\n        glm::vec3(1.0f),             // Color (white)\n        true,                        // Use texture\n        soccerTextureID,             // Texture ID\n        soccerTextureID_normalMap,   // Normal map ID\n        sphereVAO,                   // VAO ID\n        sphereVertexCount,           // Vertex count\n        true                         // Is static\n    );\n\n    // Load the Heater .obj model\n    utils_object::ModelData heaterModelData;\n    std::string modelPath = applicationPath.dirPath() + \"assets/models/HeaterOBJ/Heater.obj\";\n    if (!utils_object::loadOBJ(modelPath, applicationPath.dirPath() + \"assets/models/HeaterOBJ/\", heaterModelData)) {\n        std::cerr << \"Failed to load model heater\" << std::endl;\n    } else {\n        std::cout << \"Heater Model Loaded: \" \n                << heaterModelData.vertices.size() / 3 << \" vertices, \" \n                << heaterModelData.indices.size() << \" indices.\" << std::endl;\n    }\n\n    // Set up OpenGL buffers for the model\n    setupModelBuffers(heaterModelData);\n\n    // Compute Bounding Box for the Model\n    AABB heaterModelBoundingBox = computeAABB(heaterModelData.vertices);\n\n    // Apply scale\n    glm::vec3 heaterModelScale(0.6f, 0.6f, 0.6f);\n    heaterModelBoundingBox.min *= heaterModelScale;\n    heaterModelBoundingBox.max *= heaterModelScale;\n\n    // Apply translation (position)\n    glm::vec3 heaterModelPosition(0.6f, 1.1f, 6.0f);\n    heaterModelBoundingBox.min += heaterModelPosition;\n    heaterModelBoundingBox.max += heaterModelPosition;\n\n    // Add Heater Model to Scene Objects\n    utils_scene::addModel(\n        \"heater\",                         // Name\n        heaterModelPosition,               // Position\n        heaterModelScale,                  // Scale\n        false,                       // Use texture\n        0,\n        0,                           // Normal Map ID (if any; set to 0 if none)\n        heaterModelData.vao,               // VAO ID\n        static_cast<GLsizei>(heaterModelData.indices.size()), // Index Count\n        heaterModelBoundingBox,            // Bounding Box\n        glm::vec3(0.0f, 1.0f, 0.0f), // Rotation Axis (Y-axis)\n        0.0f,                        // Rotation Angle\n        true\n    );\n\n    // Load the Rocking Chair model\n    utils_object::ModelData rockingChairModelData;\n    std::string rockingChairPath = applicationPath.dirPath() + \"assets/models/Rocking_Chair/kid_rocking_chair.obj\";\n    std::string rockingChairBasePath = applicationPath.dirPath() + \"assets/models/Rocking_Chair/Textures/\";\n\n    if (!utils_object::loadOBJ(rockingChairPath, rockingChairBasePath, rockingChairModelData)) {\n        std::cerr << \"Failed to load Rocking Chair model.\" << std::endl;\n    } else {\n        std::cout << \"Rocking Chair Model Loaded: \" \n                << rockingChairModelData.vertices.size() / 3 << \" vertices, \" \n                << rockingChairModelData.indices.size() << \" indices.\" << std::endl;\n    }\n\n    // Load Rocking Chair Base Color Texture\n    std::string baseColorPath = rockingChairBasePath + \"/BaseColor.png\";\n    GLuint baseColorTextureID = utils_object::LoadTextureFromFile(baseColorPath.c_str());\n    if (baseColorTextureID == 0) {\n        std::cerr << \"Failed to load BaseColor.png for Rocking Chair.\" << std::endl;\n    } else {\n        std::cout << \"BaseColor.png for Rocking Chair loaded successfully: ID \" << baseColorTextureID << std::endl;\n    }\n\n    // Load Rocking Chair Normal Map\n    std::string normalMapPath = rockingChairBasePath + \"/Normal.png\";\n    GLuint normalMapTextureID = utils_object::LoadTextureFromFile(normalMapPath.c_str());\n    if (normalMapTextureID == 0) {\n        std::cerr << \"Failed to load Normal.png for Rocking Chair.\" << std::endl;\n    } else {\n        std::cout << \"Normal.png for Rocking Chair loaded successfully: ID \" << normalMapTextureID << std::endl;\n    }\n\n    // Set up OpenGL buffers for the Rocking Chair model\n    setupModelBuffers(rockingChairModelData);\n\n    // Compute Bounding Box for the Rocking Chair model\n    AABB rockingChairModelBoundingBox = computeAABB(rockingChairModelData.vertices);\n\n    // Apply scale\n    glm::vec3 rockingChairModelScale(0.8f, 0.8f, 0.8f);\n    rockingChairModelBoundingBox.min *= rockingChairModelScale;\n    rockingChairModelBoundingBox.max *= rockingChairModelScale;\n\n    // Apply translation (position)\n    glm::vec3 rockingChairModelPosition(5.0f, 0.56f, 9.0f);\n    rockingChairModelBoundingBox.min += rockingChairModelPosition;\n    rockingChairModelBoundingBox.max += rockingChairModelPosition;\n\n    // Add Rocking Chair Model to Scene Objects\n    utils_scene::addModel(\n        \"rocking_chair\",                         // Name\n        rockingChairModelPosition,               // Position\n        rockingChairModelScale,                  // Scale\n        true,                                    // Use texture\n        baseColorTextureID,                      // Texture ID (Base Color)\n        normalMapTextureID,                      // Normal Map ID\n        rockingChairModelData.vao,               // VAO ID\n        static_cast<GLsizei>(rockingChairModelData.indices.size()), // Index Count\n        rockingChairModelBoundingBox,            // Bounding Box\n        glm::vec3(0.0f, 0.0f, 0.0f),             // Rotation Axis (Y-axis)\n        0.0f,                                    // Rotation Angle\n        false\n    );\n\n    // =======================\n    // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n\n    // Main loop variables\n    bool done = false;\n    std::cout << \"Entering main loop\" << std::endl;\n\n    while (!done)\n    {\n        // Calculate delta time\n        float currentFrame = windowManager.getTime();\n        deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n        float adjustedSpeed = cameraSpeed * deltaTime;\n\n        // Update FPS counter\n        frameCount++;\n        fpsTimer += deltaTime;\n        if (fpsTimer >= 1.0f)\n        {\n            fps = frameCount;\n            frameCount = 0;\n            fpsTimer -= 1.0f;\n        }\n\n        // Update window title with camera position every frame\n        // std::string newTitle = \"Boules - FPS: \" + std::to_string(fps) + \" - Position: (\" + std::to_string(cameraPos.x) + \", \" + std::to_string(cameraPos.z) + \")\";\n        // std::string newTitle = std::to_string(cameraPos.x) + \", \" + std::to_string(cameraPos.z);\n        std::string newTitle = \"FPS: \" + std::to_string(fps);\n        SDL_SetWindowTitle(windowManager.getWindow(), newTitle.c_str());\n\n        // Update light intensity dynamically within the loop\n        // glm::vec3 lightIntensity = glm::vec3(\n        //     (sin(currentFrame) + 1.0f) / 2.0f,       // Red oscillates between 0 and 1\n        //     (cos(currentFrame) + 1.0f) / 2.0f,       // Green oscillates between 0 and 1\n        //     (sin(currentFrame * 0.5f) + 1.0f) / 2.0f // Blue oscillates more slowly between 0 and 1\n        // );\n        // white light\n        glm::vec3 lightIntensity = glm::vec3(2.0f);\n\n        // even handler \n        utils_game_loop::eventHandler(windowManager, done, isRockingChairPaused, rockingChairStartTime, rockingChairPausedTime, yaw, pitch, cameraFront, currentFrame);\n\n        // Movement direction vectors projected onto the XZ-plane\n        glm::vec3 frontDirection = glm::normalize(glm::vec3(cameraFront.x, 0.0f, cameraFront.z));\n        glm::vec3 rightDirection = glm::normalize(glm::cross(frontDirection, cameraUp));\n\n        // Keyboard input for movement\n        const Uint8 *state = SDL_GetKeyboardState(NULL);\n\n        glm::vec3 proposedCameraPos = cameraPos; // Temporary camera position for collision testing\n\n        // Calculate proposed camera position based on input\n        if (state[SDL_SCANCODE_W])\n        {\n            proposedCameraPos += adjustedSpeed * frontDirection;\n        }\n        if (state[SDL_SCANCODE_S])\n        {\n            proposedCameraPos -= adjustedSpeed * frontDirection;\n        }\n        if (state[SDL_SCANCODE_A])\n        {\n            proposedCameraPos -= rightDirection * adjustedSpeed;\n        }\n        if (state[SDL_SCANCODE_D])\n        {\n            proposedCameraPos += rightDirection * adjustedSpeed;\n        }\n\n        // Check collision against all objects\n        bool collisionDetected = false;\n        for (const auto &object : utils_scene::sceneObjects)\n        {\n            if (checkCollision(proposedCameraPos, cameraRadius, cameraHeight, object.boundingBox))\n            {\n                collisionDetected = true;\n                break; // Stop further checking if a collision is found\n            }\n        }\n\n        // Update camera position only if no collision is detected\n        if (!collisionDetected)\n        {\n            cameraPos = proposedCameraPos;\n        }\n\n        // Keep the camera at the initial y position\n        cameraPos.y = cameraPosY;\n\n        // Define MVP matrices\n        glm::mat4 ProjMatrix = glm::perspective(\n            glm::radians(70.0f),                 // Field of View\n            window_width / (float)window_height, // Aspect ratio\n            0.1f,                                // Near clipping plane\n            100.0f                               // Far clipping plane\n        );\n\n        glm::mat4 ViewMatrix = glm::lookAt(\n            cameraPos,               // Camera position\n            cameraPos + cameraFront, // Look at target\n            cameraUp                 // Up vector\n        );\n\n        // Update light position to move in a circle at a fixed height\n        float spiralRadius = 2.0f;     // Adjust the radius of the circle\n        float spiralSpeed = 0.5f;      // Adjust the speed of the rotation\n        float fixedHeight = 6.0f;      // Set the fixed height of the light\n\n        // glm::vec3 lightPosWorld;\n        // lightPosWorld.x = spiralRadius * cos(currentFrame * spiralSpeed);\n        // lightPosWorld.y = fixedHeight; // Fixed height\n        // lightPosWorld.z = spiralRadius * sin(currentFrame * spiralSpeed);\n\n        // fixed light position\n        // glm::vec3 lightPosWorld = glm::vec3(2.0f, 0.6f, 2.0f);\n\n        // light position on the camera\n        glm::vec3 lightPosWorld = cameraPos + glm::vec3(0.0f, 1.0f, 0.0f); // Slightly elevate the light position above the camera\n\n        // Transform light position to view space\n        glm::vec3 lightPosViewSpace = glm::vec3(ViewMatrix * glm::vec4(lightPosWorld, 1.0f));\n\n        // Recalculate light space matrix\n        glm::mat4 lightProjection = glm::ortho(-20.0f, 20.0f, -20.0f, 20.0f, 1.0f, 50.0f);\n        glm::mat4 lightView = glm::lookAt(lightPosWorld, glm::vec3(0.0f), glm::vec3(0.0f, 1.0f, 0.0f));\n        glm::mat4 lightSpaceMatrix = lightProjection * lightView;\n\n        // Create six view matrices for the cube map faces\n        std::vector<glm::mat4> shadowTransforms;\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(1.0, 0.0, 0.0), glm::vec3(0.0, -1.0, 0.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(-1.0, 0.0, 0.0), glm::vec3(0.0, -1.0, 0.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, 1.0, 0.0), glm::vec3(0.0, 0.0, 1.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, -1.0, 0.0), glm::vec3(0.0, 0.0, -1.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, 0.0, 1.0), glm::vec3(0.0, -1.0, 0.0)));\n        shadowTransforms.push_back(shadowProj * glm::lookAt(lightPosWorld, lightPosWorld + glm::vec3(0.0, 0.0, -1.0), glm::vec3(0.0, -1.0, 0.0)));\n\n        // First Pass: Render scene from light's perspective to generate shadow map\n        glViewport(0, 0, 8192, 8192); // Match shadow map resolution\n        glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);\n        glClear(GL_DEPTH_BUFFER_BIT);\n\n        // Use the depth shader program\n        depthShader.use();\n        glUniform1f(glGetUniformLocation(depthShader.getGLId(), \"farPlane\"), farPlane);\n        glUniform3fv(glGetUniformLocation(depthShader.getGLId(), \"lightPos\"), 1, glm::value_ptr(lightPosWorld));\n\n        // Rocking chair parameters\n        double frequency = 0.30;           // Rocking frequency (cycles per second)\n        double length = 0.08;    // Maximum angle in degrees\n        double radius = 0.3;              // Radius of the rocking base\n\n        // dynamic loop \n        utils_game_loop::dynamic_loop(deltaTime, lastFrame, currentFrame, windowManager, cameraPos, cameraFront, cameraUp, cameraSpeed, done, isRockingChairPaused, rockingChairStartTime, rockingChairPausedTime, yaw, pitch, radius, frequency, radius, length, cameraHeight);\n\n        // First Pass: Render scene to depth cube map\n        for (unsigned int i = 0; i < 6; ++i) {\n            // Bind the framebuffer and attach the current cube map face\n            glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);\n            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, depthCubeMap, 0);\n            glDrawBuffer(GL_NONE);\n            glReadBuffer(GL_NONE);\n\n            // Set viewport and clear depth buffer\n            glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);\n            glClear(GL_DEPTH_BUFFER_BIT);\n\n            // Use the depth shader program\n            depthShader.use();\n            glUniform1f(glGetUniformLocation(depthShader.getGLId(), \"farPlane\"), farPlane);\n            glUniform3fv(glGetUniformLocation(depthShader.getGLId(), \"lightPos\"), 1, glm::value_ptr(lightPosWorld));\n\n            // Set the shadow matrix for the current face\n            glUniformMatrix4fv(glGetUniformLocation(depthShader.getGLId(), \"shadowMatrix\"), 1, GL_FALSE, glm::value_ptr(shadowTransforms[i]));\n\n            // Render scene objects\n            for (const auto &object : utils_scene::sceneObjects) {\n                glm::mat4 modelMatrix = glm::mat4(1.0f);\n                modelMatrix = glm::translate(modelMatrix, object.position);\n                if (object.rotationAngle != 0.0f) {\n                    modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n                }\n                modelMatrix = glm::scale(modelMatrix, object.scale);\n\n                // Set model matrix for depth shader\n                glUniformMatrix4fv(glGetUniformLocation(depthShader.getGLId(), \"model\"), 1, GL_FALSE, glm::value_ptr(modelMatrix));\n\n                glBindVertexArray(object.vaoID);\n                if (object.type == utils_scene::ObjectType::Cube) {\n                    glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                } else if (object.type == utils_scene::ObjectType::Sphere) {\n                    glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n                } else if (object.type == utils_scene::ObjectType::Model) {\n                    glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n                }\n                glBindVertexArray(0);\n            }\n\n            // Optional: Unbind the framebuffer after each face\n            glBindFramebuffer(GL_FRAMEBUFFER, 0);\n        }\n\n        // Second Pass: Render the scene normally with point light\n        glViewport(0, 0, window_width, window_height);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        unifiedShader.use();\n\n        // Set light properties\n        glUniform3fv(uLightPos_vsLocation, 1, glm::value_ptr(lightPosViewSpace));\n        glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(lightIntensity));\n\n        // Set the updated light space matrix\n        glUniformMatrix4fv(glGetUniformLocation(unifiedShader.getGLId(), \"lightSpaceMatrix\"), 1, GL_FALSE, glm::value_ptr(lightSpaceMatrix));\n\n        // Bind the depth cube map to texture unit 1\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubeMap);\n        glUniform1i(glGetUniformLocation(unifiedShader.getGLId(), \"depthMap\"), 1);\n\n        // Set light position in world space\n        glUniform3fv(glGetUniformLocation(unifiedShader.getGLId(), \"lightPosWorld\"), 1, glm::value_ptr(lightPosWorld));\n\n        // Set camera position in world space\n        glUniform3fv(glGetUniformLocation(unifiedShader.getGLId(), \"cameraPosWorld\"), 1, glm::value_ptr(cameraPos));\n\n        // Set far plane\n        glUniform1f(glGetUniformLocation(unifiedShader.getGLId(), \"farPlane\"), farPlane);\n\n        // Render all scene objects\n        for (const auto &object : utils_scene::sceneObjects)\n        {\n            glm::mat4 modelMatrix = glm::mat4(1.0f);\n            modelMatrix = glm::translate(modelMatrix, object.position);\n            if (object.rotationAngle != 0.0f)\n            {\n                modelMatrix = glm::rotate(modelMatrix, glm::radians(object.rotationAngle), object.rotationAxis);\n            }\n            modelMatrix = glm::scale(modelMatrix, object.scale);\n\n            glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n            glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n            glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n            // Set uniforms for shaders\n            glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix)); // For vertex shader\n            glUniformMatrix4fv(uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n            glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n            glUniformMatrix3fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n            // Set material properties\n            glm::vec3 Kd = glm::vec3(0.6f); // Fixed diffuse color (e.g., gray)\n            glm::vec3 Ks = glm::vec3(0.3f); // Fixed specular color\n            float shininess = 32.0f;        // Moderate shininess\n            glUniform3fv(uKdLocation, 1, glm::value_ptr(Kd));\n            glUniform3fv(uKsLocation, 1, glm::value_ptr(Ks));\n            glUniform1f(uShininessLocation, shininess);\n\n            // Handle textures\n            if (object.useTexture && object.textureID != 0)\n            {\n                glActiveTexture(GL_TEXTURE0);\n                glBindTexture(GL_TEXTURE_2D, object.textureID);\n                glUniform1i(uTextureLocation, 0); // Ensure the texture sampler uses the correct unit\n                glUniform1f(uUseTextureLocation, 1.0f);\n            }\n            else\n            {\n                glUniform1f(uUseTextureLocation, 0.0f);\n            }\n\n            if (object.normalMapID != 0)\n            {\n                glActiveTexture(GL_TEXTURE2); // Bind to texture unit 2 (or another unused unit)\n                glBindTexture(GL_TEXTURE_2D, object.normalMapID);\n                glUniform1i(glGetUniformLocation(unifiedShader.getGLId(), \"uNormalMap\"), 2);\n                glUniform1f(glGetUniformLocation(unifiedShader.getGLId(), \"uUseNormalMap\"), 1.0f);\n            }\n            else\n            {\n                glUniform1f(glGetUniformLocation(unifiedShader.getGLId(), \"uUseNormalMap\"), 0.0f); // Disable normal map usage\n            }\n\n            glBindVertexArray(object.vaoID);\n            if (object.type == utils_scene::ObjectType::Cube)\n            {\n                glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n            }\n            else if (object.type == utils_scene::ObjectType::Sphere)\n            {\n                glDrawArrays(GL_TRIANGLES, 0, object.indexCount);\n            }\n            else if (object.type == utils_scene::ObjectType::Model)\n            {\n                glDrawElements(GL_TRIANGLES, object.indexCount, GL_UNSIGNED_INT, 0);\n            }\n\n            // Unbind textures if they are used\n            if (object.useTexture && object.textureID != 0)\n            {\n                glActiveTexture(GL_TEXTURE0);\n                glBindTexture(GL_TEXTURE_2D, 0); // Unbind base texture\n            }\n            if (object.normalMapID != 0)\n            {\n                glActiveTexture(GL_TEXTURE2);\n                glBindTexture(GL_TEXTURE_2D, 0); // Unbind normal map texture\n            }\n        }\n\n        // Render a small sphere to represent the light source\n        {\n            // Create model matrix for the light sphere\n            glm::mat4 modelMatrix = glm::mat4(1.0f);\n            modelMatrix = glm::translate(modelMatrix, lightPosWorld);\n            modelMatrix = glm::scale(modelMatrix, glm::vec3(0.1f));\n\n            // Calculate matrices\n            glm::mat4 mvMatrix = ViewMatrix * modelMatrix;\n            glm::mat4 mvpMatrix = ProjMatrix * mvMatrix;\n            glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(mvMatrix)));\n\n            // Use the unified shader program\n            unifiedShader.use();\n\n            // **Set transformation matrices**\n            glUniformMatrix4fv(uModelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix));\n            glUniformMatrix4fv(uMVMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvMatrix));\n            glUniformMatrix4fv(uMVPMatrixLocation, 1, GL_FALSE, glm::value_ptr(mvpMatrix));\n            glUniformMatrix3fv(uNormalMatrixLocation, 1, GL_FALSE, glm::value_ptr(normalMatrix));\n\n            // **Set camera position in world space (for lighting calculations)**\n            glUniform3fv(glGetUniformLocation(unifiedShader.getGLId(), \"cameraPosWorld\"), 1, glm::value_ptr(cameraPos));\n\n            // **Set light position in world space (even if not needed for the light sphere)**\n            glUniform3fv(glGetUniformLocation(unifiedShader.getGLId(), \"lightPosWorld\"), 1, glm::value_ptr(lightPosWorld));\n\n            // **Set light properties**\n            glUniform3fv(uLightPos_vsLocation, 1, glm::value_ptr(lightPosViewSpace));\n            glUniform3fv(uLightIntensityLocation, 1, glm::value_ptr(lightIntensity));\n\n            // **Set far plane**\n            glUniform1f(glGetUniformLocation(unifiedShader.getGLId(), \"farPlane\"), farPlane);\n\n            // Bind depth cube map\n            glActiveTexture(GL_TEXTURE1);\n            glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubeMap);\n            glUniform1i(glGetUniformLocation(unifiedShader.getGLId(), \"depthMap\"), 1);\n\n            // Set material properties (emissive)\n            glm::vec3 Kd = lightIntensity / 5.0f; // Adjustable\n            glm::vec3 Ks = glm::vec3(0.0f);       // No specular for the light indicator\n            float shininess = 1.0f;\n            glUniform3fv(uKdLocation, 1, glm::value_ptr(Kd));\n            glUniform3fv(uKsLocation, 1, glm::value_ptr(Ks));\n            glUniform1f(uShininessLocation, shininess);\n\n            // Disable textures\n            glUniform1f(uUseTextureLocation, 0.0f);\n            glUniform1f(glGetUniformLocation(unifiedShader.getGLId(), \"uUseNormalMap\"), 0.0f);\n\n            // Draw the sphere\n            glBindVertexArray(sphereVAO);\n            glDrawArrays(GL_TRIANGLES, 0, sphereVertexCountGL);\n            glBindVertexArray(0);\n        }\n\n        // Swap buffers\n        windowManager.swapBuffers();\n    }\n\n    // Clean up resources\n    glDeleteBuffers(1, &sphereVBO);\n    glDeleteVertexArrays(1, &sphereVAO);\n\n    glDeleteBuffers(1, &cubeVBO);\n    glDeleteBuffers(1, &cubeEBO);\n    glDeleteVertexArrays(1, &cubeVAO);\n\n    for (const auto &tex : textures)\n    {\n        glDeleteTextures(1, &tex.second);\n    }\n\n    // Clean up model buffers\n    glDeleteBuffers(1, &heaterModelData.vbo);\n    glDeleteBuffers(1, &heaterModelData.ebo);\n    glDeleteVertexArrays(1, &heaterModelData.vao);\n\n    std::cout << \"Program terminated successfully\" << std::endl;\n\n    return 0;\n}",
    "APP3/utils/models.hpp": "#ifndef MODELS_HPP\n#define MODELS_HPP\n\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include \"global.hpp\"\n#include <src/tiny_obj_loader.h>\n\nnamespace utils_object {\n\nstruct ModelData {\n    std::vector<float> vertices;\n    std::vector<float> normals;\n    std::vector<float> texcoords;\n    std::vector<unsigned int> indices;\n    std::vector<tinyobj::material_t> materials;\n    std::vector<tinyobj::shape_t> shapes;\n    std::map<int, GLuint> materialToTexture; // Map material ID to texture ID\n    GLuint vao, vbo, ebo;\n    std::vector<float> tangents;\n    std::vector<float> bitangents;\n};\n\nvoid GetRockingChairPositionAndRotation(\n    double currentTime,\n    double frequency,\n    double radius,\n    double length,\n    glm::vec3& position,\n    glm::vec3& rotation\n);\n\n// Function to load a texture from file and return its OpenGL texture ID\nGLuint LoadTextureFromFile(const char* path);\n\nvoid computeTangents(ModelData &modelData);\n\n// Function to load an OBJ model using TinyOBJLoader\nbool loadOBJ(const std::string& filePath, const std::string& basePath, ModelData &modelData);\n\n// Function to set up OpenGL buffers (VAO, VBO, EBO) for the model\nvoid setupModelBuffers(ModelData &modelData);\n\n}\n\n#endif // MODELS_HPP",
    "APP3/utils/sphere.hpp": "#ifndef SPHERE_HPP\n#define SPHERE_HPP\n\n#include \"global.hpp\"\n#include <vector>\n#include <glimac/Sphere.hpp>\n\nnamespace utils_object {\n\nsize_t createSphereVertices(std::vector<SphereVertex>& sphereVertices, glimac::Sphere& sphere);\nvoid computeSphereTangents(std::vector<SphereVertex>& vertices);\nvoid setupSphereBuffers(const std::vector<SphereVertex>& sphereVertices, GLuint& sphereVBO, GLuint& sphereVAO);\n\n}\n\n#endif // SPHERE_HPP",
    "APP3/utils/rendering.hpp": "#ifndef RENDERING_HPP\n#define RENDERING_HPP\n\n#include <glm/glm.hpp>\n#include <vector>\n#include \"utils/scene_object.hpp\"\n#include \"utils/utilities.hpp\"\n#include \"utils/scene_object.hpp\"\n#include \"utils/models.hpp\"\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils_game_loop {\n\nvoid dynamic_loop(float &deltaTime, float &lastFrame, float &currentFrame,\n                  glimac::SDLWindowManager &windowManager, glm::vec3 &cameraPos,\n                  glm::vec3 &cameraFront, glm::vec3 &cameraUp, float cameraSpeed,\n                  bool &done, bool &isRockingChairPaused, double &rockingChairStartTime,\n                  double &rockingChairPausedTime, float &yaw, float &pitch, float cameraRadius,\n                  double frequency, double radius, double length,\n                  float cameraHeight);\n\n\n\n} // namespace utils_game_loop\n\n#endif // RENDERING_HPP",
    "APP3/utils/cube.hpp": "#ifndef CUBE_HPP\n#define CUBE_HPP\n\n#include \"global.hpp\"\n#include <vector>\n\nnamespace utils_object {\n\nvoid createCube(std::vector<Vertex3D>& vertices, std::vector<GLuint>& indices);\nvoid computeCubeTangents(std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices);\nvoid setupCubeBuffers(const std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices, GLuint& cubeVBO, GLuint& cubeEBO, GLuint& cubeVAO);\n\n}\n\n#endif // CUBE_HPP",
    "APP3/utils/global.hpp": "#ifndef GLOBAL_HPP\n#define GLOBAL_HPP\n\n#include <glad/glad.h>\n#include <glm/glm.hpp>\n\n// Window dimensions\nextern int window_width;\nextern int window_height;\n\n// Stone floor coordinates\nextern int numCubesX;\nextern int numCubesZ;\nextern float spacingX;\nextern float spacingZ;\n\nextern const GLuint SHADOW_WIDTH;\nextern const GLuint SHADOW_HEIGHT;\n\nextern float cameraRadius; // Radius of the camera sphere for collision detection\nextern float cameraHeight; // Height of the camera cylinder\n\nextern bool isRockingChairPaused;\nextern double rockingChairPausedTime;\nextern double rockingChairStartTime;\n\nextern float sensitivity;\nextern float currentFrame;\n\n// Structure for 3D vertices with position, normal, and texture coordinates\nstruct Vertex3D {\n    glm::vec3 position;  // Vertex position\n    glm::vec3 normal;    // Vertex normal\n    glm::vec2 texCoords; // Texture coordinates\n    glm::vec3 tangent;\n    glm::vec3 bitangent;\n\n    Vertex3D(const glm::vec3& pos, const glm::vec3& norm, const glm::vec2& uv)\n        : position(pos), normal(norm), texCoords(uv), tangent(0.0f), bitangent(0.0f) {}\n};\n\nstruct SphereVertex {\n    glm::vec3 position;\n    glm::vec3 normal;\n    glm::vec2 texCoords;\n    glm::vec3 tangent;\n    glm::vec3 bitangent;\n};\n\n#endif // GLOBAL_HPP",
    "APP3/utils/collision.hpp": "#ifndef COLLISION_HPP\n#define COLLISION_HPP\n\n#include \"utilities.hpp\"\n\nbool checkCollision(const glm::vec3& cylinderBaseCenter, float radius, float height, const AABB& box);\n\n#endif // COLLISION_HPP",
    "APP3/utils/initialization.cpp": "#include \"initialization.hpp\"\n#include <iostream>\n#include <glad/glad.h>\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils_init {\n\nglimac::SDLWindowManager initOpenGL(int window_width, int window_height) {\n    std::cout << \"Program started\" << std::endl;\n\n    // Initialize SDL video subsystem\n    if (SDL_Init(SDL_INIT_VIDEO) != 0)\n    {\n        std::cerr << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n        throw std::runtime_error(\"Failed to initialize SDL\");\n    }\n\n    // Set OpenGL context version and profile\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MAJOR_VERSION: \" << SDL_GetError() << std::endl;\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_MINOR_VERSION: \" << SDL_GetError() << std::endl;\n    if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE) != 0)\n        std::cerr << \"Failed to set SDL_GL_CONTEXT_PROFILE_MASK: \" << SDL_GetError() << std::endl;\n\n    #ifdef __APPLE__\n        if (SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG) != 0)\n            std::cerr << \"Failed to set SDL_GL_CONTEXT_FLAGS: \" << SDL_GetError() << std::endl;\n    #endif\n\n    // Initialize SDLWindowManager\n    glimac::SDLWindowManager windowManager(window_width, window_height, \"Boules\");\n    std::cout << \"SDLWindowManager initialized\" << std::endl;\n\n    // Initialize GLAD\n    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress))\n    {\n        std::cerr << \"Failed to initialize GLAD\" << std::endl;\n        throw std::runtime_error(\"Failed to initialize GLAD\");\n    }\n    std::cout << \"GLAD initialized\" << std::endl;\n\n    // Output OpenGL version and renderer\n    const GLubyte *renderer = glGetString(GL_RENDERER);\n    const GLubyte *version = glGetString(GL_VERSION);\n    if (renderer)\n        std::cout << \"Renderer: \" << renderer << std::endl;\n    else\n        std::cout << \"Renderer is NULL\" << std::endl;\n\n    if (version)\n        std::cout << \"OpenGL version supported: \" << version << std::endl;\n    else\n        std::cout << \"OpenGL version is NULL\" << std::endl;\n\n    // Check if glGenVertexArrays is available\n    if (glGenVertexArrays == nullptr)\n    {\n        std::cerr << \"Error: glGenVertexArrays is NULL\" << std::endl;\n        throw std::runtime_error(\"glGenVertexArrays is NULL\");\n    }\n\n    return windowManager;\n}\n\n} // namespace utils_init",
    "APP3/utils/scene_object.hpp": "#ifndef SCENE_OBJECT_HPP\n#define SCENE_OBJECT_HPP\n\n#include \"utilities.hpp\"\n#include \"global.hpp\"\n#include <vector>\n#include <map>\n#include <string>\n\nnamespace utils_scene {\n\nenum class ObjectType {\n    Cube,\n    Sphere,\n    Model\n};\n\nstruct SceneObject {\n    std::string name;\n    ObjectType type;\n    glm::vec3 position;\n    glm::vec3 initialPosition;\n    glm::vec3 scale;\n    glm::vec3 color;\n    bool useTexture;\n    GLuint textureID;\n    GLuint normalMapID;\n    glm::vec3 rotationAxis;\n    float rotationAngle;\n    AABB boundingBox;\n    GLuint vaoID;\n    GLsizei indexCount;\n    bool isStatic;\n};\n\nextern std::vector<SceneObject> sceneObjects;\n\nvoid addCube(const std::string& name, const glm::vec3& position, const glm::vec3& scale, const glm::vec3& color, bool useTexture, GLuint textureID = 0, GLuint normalMapID = 0, const glm::vec3& rotationAxis = glm::vec3(0.0f), float rotationAngle = 0.0f, GLuint vaoID = 0, GLsizei indexCount = 0, bool isStatic = false);\n\nvoid addSphere(const std::string& name, const glm::vec3& position, float radius, const glm::vec3& color, bool useTexture, GLuint textureID = 0, GLuint normalMapID = 0, GLuint vaoID = 0, GLsizei vertexCount = 0, bool isStatic = false);\n\nvoid createCompositeCube(const std::string& name, const glm::vec3& origin, const glm::vec3& size, GLuint textureID, GLuint normalMapID, GLuint vaoID, GLsizei indexCount, bool isStatic);\n\nvoid addModel(const std::string& name, const glm::vec3& position, const glm::vec3& scale, bool useTexture, GLuint textureID, GLuint normalMapID, GLuint vaoID, GLsizei indexCount, const AABB& boundingBox, const glm::vec3& rotationAxis = glm::vec3(0.0f), float rotationAngle = 0.0f, bool isStatic = false);\n\n} // namespace utils_scene\n\n#endif // SCENE_OBJECT_HPP",
    "APP3/utils/resource_loader.cpp": "#include \"resource_loader.hpp\"\n#include \"texture.hpp\"\n#include <glimac/Image.hpp>\n#include <iostream>\n\nnamespace utils_loader {\n\n// Load textures\nvoid loadTextures(GLuint& textureID, GLuint& stoneTextureID, GLuint& brownTerracottaTextureID, GLuint& soccerTextureID,\n                  GLuint& textureID_normalMap, GLuint& stoneTextureID_normalMap, GLuint& brownTerracottaTextureID_normalMap, GLuint& soccerTextureID_normalMap,\n                  GLuint& chairBaseColorTextureID, GLuint& chairNormalMapTextureID,\n                  const glimac::FilePath& applicationPath) {\n    textureID = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_HD/cobblestone_8bit.png\");\n    stoneTextureID = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_HD/stone_8bit.png\");\n    brownTerracottaTextureID = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_HD/brown_glazed_terracotta_8bit.png\");\n    soccerTextureID = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_sphere/soccer_sph_s_8bit.png\");\n    chairBaseColorTextureID = loadTexture(applicationPath.dirPath() + \"../assets/models/Rocking_Chair/Textures/BaseColor.png\");\n\n    textureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_HD/cobblestone_8bit_normal_map.png\");\n    stoneTextureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_HD/stone_8bit_normal_map.png\");\n    brownTerracottaTextureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_HD/brown_glazed_terracotta_8bit_normal_map.png\");\n    soccerTextureID_normalMap = loadTexture(applicationPath.dirPath() + \"../APP1/assets/textures_sphere/soccer_sph_s_8bit_normal_map.png\");\n    chairNormalMapTextureID = loadTexture(applicationPath.dirPath() + \"../assets/models/Rocking_Chair/Textures/Normal.png\");\n\n    std::cout << \"Textures loaded successfully\" << std::endl;\n\n    // check textures and normals fir the chair : \n    std::cout << \"Chair Base Color Texture ID: \" << chairBaseColorTextureID << std::endl;\n    std::cout << \"Chair Normal Map Texture ID: \" << chairNormalMapTextureID << std::endl;\n}\n\n// Setup depth cube map\nvoid setupDepthCubeMap(GLuint& depthCubeMap, GLuint& shadowMapFBO, int resolution) {\n    glGenTextures(1, &depthCubeMap);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubeMap);\n    for (unsigned int i = 0; i < 6; ++i) {\n        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT32F, resolution, resolution, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);\n    }\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n\n    glGenFramebuffers(1, &shadowMapFBO);\n    glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);\n    glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubeMap, 0);\n    glDrawBuffer(GL_NONE);\n    glReadBuffer(GL_NONE);\n    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {\n        std::cerr << \"Framebuffer not complete!\" << std::endl;\n    }\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n    std::cout << \"Depth cube map setup complete\" << std::endl;\n}\n\n} // namespace utils_loader",
    "APP3/utils/texture.cpp": "#include \"texture.hpp\"\n#include <iostream>\n#include <glimac/Image.hpp>\n#include <glm/glm.hpp>\n\nstd::map<std::string, GLuint> textures;\n\nGLuint loadTexture(const std::string& texturePath) {\n    if (textures.find(texturePath) != textures.end()) {\n        return textures[texturePath];\n    }\n\n    std::unique_ptr<glimac::Image> pImage = glimac::loadImage(texturePath);\n    if (!pImage) {\n        std::cerr << \"Failed to load texture image at \" << texturePath << std::endl;\n        return 0;\n    }\n\n    size_t width = pImage->getWidth();\n    size_t height = pImage->getHeight();\n    glm::vec4* pixels = pImage->getPixels();\n\n    for (size_t row = 0; row < height / 2; ++row) {\n        for (size_t col = 0; col < width; ++col) {\n            size_t topIndex = row * width + col;\n            size_t bottomIndex = (height - 1 - row) * width + col;\n            std::swap(pixels[topIndex], pixels[bottomIndex]);\n        }\n    }\n\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pImage->getWidth(), pImage->getHeight(), 0, GL_RGBA, GL_FLOAT, pImage->getPixels());\n    glGenerateMipmap(GL_TEXTURE_2D);\n\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    textures[texturePath] = textureID;\n    return textureID;\n}",
    "APP3/utils/utilities.cpp": "#include \"utilities.hpp\"\n#include \"global.hpp\"\n\n\n#include <glm/glm.hpp>\n#include <cstdlib>\n\n#include <iostream>\n\nfloat randomFloat() {\n    return static_cast<float>(rand()) / static_cast<float>(RAND_MAX);\n}\n\nglm::vec3 randomColor() {\n    return glm::vec3(0.6f);\n}\n\nAABB computeAABB(const std::vector<float>& vertices) {\n    if (vertices.empty()) {\n        return AABB(glm::vec3(0.0f), glm::vec3(0.0f));\n    }\n    \n    glm::vec3 minVertex(vertices[0], vertices[1], vertices[2]);\n    glm::vec3 maxVertex = minVertex;\n    \n    for (size_t i = 3; i < vertices.size(); i += 3) {\n        glm::vec3 vertex(vertices[i], vertices[i + 1], vertices[i + 2]);\n        minVertex = glm::min(minVertex, vertex);\n        maxVertex = glm::max(maxVertex, vertex);\n    }\n    \n    return AABB(minVertex, maxVertex);\n}\n\nnamespace utils_game_loop {\n\nvoid eventHandler(glimac::SDLWindowManager &windowManager, bool &done, bool &isRockingChairPaused, double &rockingChairStartTime, double &rockingChairPausedTime, float &yaw, float &pitch, glm::vec3 &cameraFront, float &currentFrame) {\n\n    // Event handling\n    SDL_Event e;\n    while (windowManager.pollEvent(e))\n    {\n    if (e.type == SDL_QUIT)\n        {\n            done = true;\n        }\n        if (e.type == SDL_KEYDOWN)\n        {\n            if (e.key.keysym.sym == SDLK_ESCAPE)\n            {\n                done = true;\n            }\n            else if (e.key.keysym.sym == SDLK_t)\n            {\n                isRockingChairPaused = !isRockingChairPaused;\n                if (isRockingChairPaused)\n                {\n                    // Record the time when paused\n                    rockingChairPausedTime = currentFrame;\n                }\n                else\n                {\n                    // Adjust the start time when unpausing\n                    double pauseDuration = currentFrame - rockingChairPausedTime;\n                    rockingChairStartTime += pauseDuration;\n                }\n            }\n        }\n\n        // Mouse movement\n        if (e.type == SDL_MOUSEMOTION)\n        {\n            float xpos = e.motion.xrel;\n            float ypos = e.motion.yrel;\n\n            xpos *= sensitivity;\n            ypos *= sensitivity;\n\n            yaw += xpos;\n            pitch -= ypos; // Invert y-axis if necessary\n\n            // Constrain pitch\n            if (pitch > 89.0f)\n                pitch = 89.0f;\n            if (pitch < -89.0f)\n                pitch = -89.0f;\n\n            // Update camera front vector\n            glm::vec3 front;\n            front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));\n            front.y = sin(glm::radians(pitch));\n            front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));\n            cameraFront = glm::normalize(front);\n        }\n    }\n}\n\n} // namespace utils_game_loop",
    "APP3/utils/shader.cpp": "#include \"shader.hpp\"\n#include <iostream>\n#include <glimac/FilePath.hpp>\n\nnamespace utils_loader {\n\nShader::Shader(const std::string& vertexPath, const std::string& fragmentPath) {\n    glimac::FilePath vPath(vertexPath.c_str());\n    glimac::FilePath fPath(fragmentPath.c_str());\n\n    // Debugging: Print paths\n    std::cout << \"Loading vertex shader: \" << vPath.dirPath() << std::endl;\n    std::cout << \"Loading fragment shader: \" << fPath.dirPath() << std::endl;\n\n    // Load shader program\n    m_program = glimac::loadProgram(vPath, fPath);\n    if (m_program.getGLId() == 0) {\n        std::cerr << \"Failed to load shader program: \" << vertexPath << \" and \" << fragmentPath << std::endl;\n    }\n}\n\nvoid Shader::use() const {\n    m_program.use();\n}\n\nGLuint Shader::getID() const {\n    return m_program.getGLId();\n}\n\nGLint Shader::getUniformLocation(const std::string& name) const {\n    return glGetUniformLocation(m_program.getGLId(), name.c_str());\n}\n\nGLuint Shader::getGLId() const { // New method implementation\n    return m_program.getGLId();\n}\n\n} // namespace utils_loader",
    "APP3/utils/initialization.hpp": "#ifndef INITIALIZATION_HPP\n#define INITIALIZATION_HPP\n\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace utils_init {\n\nglimac::SDLWindowManager initOpenGL(int window_width, int window_height);\n\n}\n\n#endif // INITIALIZATION_HPP",
    "APP3/utils/resource_loader.hpp": "#ifndef RESOURCE_LOADER_HPP\n#define RESOURCE_LOADER_HPP\n\n#include \"global.hpp\"\n#include <glimac/Program.hpp>\n#include <glimac/FilePath.hpp>\n\nnamespace utils_loader {\n\n// Function to load textures\nvoid loadTextures(GLuint& textureID, GLuint& stoneTextureID, GLuint& brownTerracottaTextureID, GLuint& soccerTextureID,\n                  GLuint& textureID_normalMap, GLuint& stoneTextureID_normalMap, GLuint& brownTerracottaTextureID_normalMap, GLuint& soccerTextureID_normalMap,\n                  GLuint& chairBaseColorTextureID, GLuint& chairNormalMapTextureID,\n                  const glimac::FilePath& applicationPath);\n\n// Function to set up a depth cube map\nvoid setupDepthCubeMap(GLuint& depthCubeMap, GLuint& shadowMapFBO, int resolution = 4096);\n\n} // namespace utils_loader\n\n#endif // RESOURCE_LOADER_HPP",
    "APP3/utils/scene_object.cpp": "#include \"scene_object.hpp\"\n\nnamespace utils_scene {\n\nstd::vector<SceneObject> sceneObjects;\n\nvoid addCube(\n    const std::string& name,\n    const glm::vec3& position,\n    const glm::vec3& scale,\n    const glm::vec3& color,\n    bool useTexture,\n    GLuint textureID,\n    GLuint normalMapID,\n    const glm::vec3& rotationAxis,\n    float rotationAngle,\n    GLuint vaoID,\n    GLsizei indexCount,\n    bool isStatic\n) {\n    SceneObject cube;\n    cube.name = name;\n    cube.type = ObjectType::Cube;\n    cube.position = position;\n    cube.initialPosition = position;\n    cube.scale = scale;\n    cube.color = color;\n    cube.useTexture = useTexture;\n    cube.textureID = textureID;\n    cube.normalMapID = normalMapID;\n    cube.rotationAxis = rotationAxis;\n    cube.rotationAngle = rotationAngle;\n    cube.vaoID = vaoID;\n    cube.indexCount = indexCount;\n    cube.isStatic = isStatic;\n\n    glm::vec3 halfSize = scale * 0.5f;\n    cube.boundingBox.min = position - halfSize;\n    cube.boundingBox.max = position + halfSize;\n\n    sceneObjects.push_back(cube);\n}\n\nvoid addSphere(\n    const std::string& name,\n    const glm::vec3& position,\n    float radius,\n    const glm::vec3& color,\n    bool useTexture,\n    GLuint textureID,\n    GLuint normalMapID,\n    GLuint vaoID,\n    GLsizei vertexCount,\n    bool isStatic\n) {\n    SceneObject sphereObject;\n    sphereObject.name = name;\n    sphereObject.type = ObjectType::Sphere;\n    sphereObject.position = position;\n    sphereObject.initialPosition = position;\n    sphereObject.scale = glm::vec3(radius);\n    sphereObject.color = color;\n    sphereObject.useTexture = useTexture;\n    sphereObject.textureID = textureID;\n    sphereObject.normalMapID = normalMapID;\n    sphereObject.vaoID = vaoID;\n    sphereObject.indexCount = vertexCount;\n    sphereObject.isStatic = isStatic;\n\n    sphereObject.boundingBox.min = position - glm::vec3(radius);\n    sphereObject.boundingBox.max = position + glm::vec3(radius);\n\n    sceneObjects.push_back(sphereObject);\n}\n\nvoid createCompositeCube(\n    const std::string& baseName,\n    const glm::vec3& origin,\n    const glm::vec3& size,\n    GLuint textureID,\n    GLuint normalMapID,\n    GLuint vaoID,\n    GLsizei indexCount,\n    bool isStatic\n) {\n    int numCubesX = static_cast<int>(size.x);\n    int numCubesY = static_cast<int>(size.y);\n    int numCubesZ = static_cast<int>(size.z);\n\n    for (int x = 0; x < numCubesX; ++x) {\n        for (int y = 0; y < numCubesY; ++y) {\n            for (int z = 0; z < numCubesZ; ++z) {\n                glm::vec3 position = origin + glm::vec3(x, y, z);\n                std::string name = baseName + \"_\" + std::to_string(x) + \"_\" + std::to_string(y) + \"_\" + std::to_string(z);\n                addCube(\n                    name,                       // Name\n                    position,                   // Position\n                    glm::vec3(1.0f),            // Scale (individual cubes are 1x1x1 units)\n                    glm::vec3(1.0f),            // Color (white, not used if texture is applied)\n                    true,                       // Use texture\n                    textureID,                  // Texture ID\n                    normalMapID,                // Normal map ID\n                    glm::vec3(0.0f),            // Rotation axis\n                    0.0f,                       // Rotation angle\n                    vaoID,                      // VAO ID\n                    indexCount,                 // Index count\n                    isStatic                    // Is static\n                );\n            }\n        }\n    }\n}\n\nvoid addModel(\n    const std::string& name,\n    const glm::vec3& position,\n    const glm::vec3& scale,\n    bool useTexture,\n    GLuint textureID,\n    GLuint normalMapID,\n    GLuint vaoID,\n    GLsizei indexCount,\n    const AABB& boundingBox,\n    const glm::vec3& rotationAxis,\n    float rotationAngle,\n    bool isStatic\n) {\n    SceneObject obj;\n    obj.name = name;\n    obj.type = ObjectType::Model;\n    obj.position = position;\n    obj.initialPosition = position;\n    obj.scale = scale;\n    obj.color = glm::vec3(1.0f); // Default color white\n    obj.useTexture = useTexture;\n    obj.textureID = textureID;\n    obj.normalMapID = normalMapID;\n    obj.rotationAxis = rotationAxis;\n    obj.rotationAngle = rotationAngle;\n    obj.boundingBox = boundingBox;\n    obj.vaoID = vaoID;\n    obj.indexCount = indexCount;\n    obj.isStatic = isStatic;\n\n    sceneObjects.push_back(obj);\n}\n\n} // namespace utils_scene",
    "APP3/utils/texture.hpp": "#ifndef TEXTURE_HPP\n#define TEXTURE_HPP\n\n#include <string>\n#include <map>\n#include <glad/glad.h>\n\nextern std::map<std::string, GLuint> textures;\n\nGLuint loadTexture(const std::string& texturePath);\n\n#endif // TEXTURE_HPP",
    "APP3/utils/utilities.hpp": "#ifndef UTILITIES_HPP\n#define UTILITIES_HPP\n\n#include <glm/glm.hpp>\n#include <vector>\n#include <SDL2/SDL.h>\n#include <glimac/SDLWindowManager.hpp>\n\nnamespace glimac {\n    class SDLWindowManager;\n}\n\nstruct AABB {\n    glm::vec3 min;\n    glm::vec3 max;\n    AABB() : min(glm::vec3(0.0f)), max(glm::vec3(0.0f)) {}\n    AABB(const glm::vec3& min_, const glm::vec3& max_) : min(min_), max(max_) {}\n};\n\nfloat randomFloat();\nglm::vec3 randomColor();\nAABB computeAABB(const std::vector<float>& vertices);\n\nnamespace utils_game_loop {\n    void eventHandler(glimac::SDLWindowManager &windowManager, bool &done, bool &isRockingChairPaused, double &rockingChairStartTime, double &rockingChairPausedTime, float &yaw, float &pitch, glm::vec3 &cameraFront, float &currentFrame);\n}\n\n#endif // UTILITIES_HPP",
    "APP3/utils/shader.hpp": "#ifndef SHADER_HPP\n#define SHADER_HPP\n\n#include <glimac/Program.hpp>\n#include <string>\n\nnamespace utils_loader {\n\nclass Shader {\npublic:\n    Shader(const std::string& vertexPath, const std::string& fragmentPath);\n    void use() const;\n    GLuint getID() const;\n    GLint getUniformLocation(const std::string& name) const;\n    GLuint getGLId() const;\n\nprivate:\n    glimac::Program m_program;\n};\n\n} // namespace utils_loader\n\n#endif // SHADER_HPP",
    "APP3/utils/models.cpp": "#include \"models.hpp\"\n#include <src/tiny_obj_loader.h>\n#include <src/stb_image.h>\n#include <iostream>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/constants.hpp> \n#include <cmath> \n\nnamespace utils_object {\n\nvoid GetRockingChairPositionAndRotation(\n    double currentTime,\n    double frequency,\n    double radius,\n    double length,\n    glm::vec3& position,\n    glm::vec3& rotation)\n{\n    // Calculate angular frequency and time-dependent angle for rolling motion\n    double omega = 2.0 * glm::pi<double>() * frequency; // Angular frequency\n    double displacement = length * 0.5 * sin(omega * currentTime); // Point P's back and forth motion, clamped to [-length/2, length/2]\n\n    // Compute the angle of rotation based on the displacement of point P\n    double theta = displacement / radius; // Rotation angle in radians, derived from s = r * theta\n\n    // Set position (displacement along the X-axis, assuming rolling along X-axis)\n    position = glm::vec3(0.0, 0.0, -displacement); // Adjust axes as necessary for your specific setup\n\n    // Set rotation around the Z-axis to simulate rolling (assuming circle rolls along X-axis)\n    rotation = glm::vec3(0.0, 0.0, -1.0 * static_cast<float>(glm::degrees(theta))); // Convert theta to degrees for rotation\n}\n\nGLuint LoadTextureFromFile(const char* path) {\n    int width, height, nrComponents;\n    unsigned char *data = stbi_load(path, &width, &height, &nrComponents, 0);\n    if (data) {\n        GLenum format = GL_RGB;\n        if (nrComponents == 1)\n            format = GL_RED;\n        else if (nrComponents == 3)\n            format = GL_RGB;\n        else if (nrComponents == 4)\n            format = GL_RGBA;\n\n        GLuint textureID;\n        glGenTextures(1, &textureID);\n        glBindTexture(GL_TEXTURE_2D, textureID);\n        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);\n        glGenerateMipmap(GL_TEXTURE_2D);\n\n        // Set texture parameters (wrapping, filtering)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\t\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\t\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n        stbi_image_free(data);\n\n        return textureID;\n    } else {\n        std::cerr << \"Texture failed to load at path: \" << path << std::endl;\n        stbi_image_free(data);\n        return 0;\n    }\n}\n\nvoid computeTangents(ModelData &model) {\n    size_t vertexCount = model.vertices.size() / 3;\n    size_t indexCount = model.indices.size();\n\n    // Initialize tangents and bitangents\n    model.tangents.assign(vertexCount * 3, 0.0f);\n    model.bitangents.assign(vertexCount * 3, 0.0f);\n\n    // Iterate over each triangle\n    for (size_t i = 0; i < indexCount; i += 3) {\n        unsigned int index0 = model.indices[i];\n        unsigned int index1 = model.indices[i + 1];\n        unsigned int index2 = model.indices[i + 2];\n\n        // Positions\n        glm::vec3 pos0(model.vertices[index0 * 3 + 0], model.vertices[index0 * 3 + 1], model.vertices[index0 * 3 + 2]);\n        glm::vec3 pos1(model.vertices[index1 * 3 + 0], model.vertices[index1 * 3 + 1], model.vertices[index1 * 3 + 2]);\n        glm::vec3 pos2(model.vertices[index2 * 3 + 0], model.vertices[index2 * 3 + 1], model.vertices[index2 * 3 + 2]);\n\n        // Texture coordinates\n        glm::vec2 uv0(model.texcoords[index0 * 2 + 0], model.texcoords[index0 * 2 + 1]);\n        glm::vec2 uv1(model.texcoords[index1 * 2 + 0], model.texcoords[index1 * 2 + 1]);\n        glm::vec2 uv2(model.texcoords[index2 * 2 + 0], model.texcoords[index2 * 2 + 1]);\n\n        // Edges of the triangle\n        glm::vec3 edge1 = pos1 - pos0;\n        glm::vec3 edge2 = pos2 - pos0;\n\n        glm::vec2 deltaUV1 = uv1 - uv0;\n        glm::vec2 deltaUV2 = uv2 - uv0;\n\n        float f = 1.0f;\n        float denominator = (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n        if (denominator != 0.0f) {\n            f = 1.0f / denominator;\n        }\n\n        glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\n        glm::vec3 bitangent = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);\n\n        // Accumulate the tangents and bitangents\n        for (int j = 0; j < 3; ++j) {\n            unsigned int idx = model.indices[i + j];\n            model.tangents[idx * 3 + 0] += tangent.x;\n            model.tangents[idx * 3 + 1] += tangent.y;\n            model.tangents[idx * 3 + 2] += tangent.z;\n\n            model.bitangents[idx * 3 + 0] += bitangent.x;\n            model.bitangents[idx * 3 + 1] += bitangent.y;\n            model.bitangents[idx * 3 + 2] += bitangent.z;\n        }\n    }\n\n    // Normalize the tangents and bitangents\n    for (size_t i = 0; i < vertexCount; ++i) {\n        glm::vec3 tangent(model.tangents[i * 3 + 0], model.tangents[i * 3 + 1], model.tangents[i * 3 + 2]);\n        tangent = glm::normalize(tangent);\n        model.tangents[i * 3 + 0] = tangent.x;\n        model.tangents[i * 3 + 1] = tangent.y;\n        model.tangents[i * 3 + 2] = tangent.z;\n\n        glm::vec3 bitangent(model.bitangents[i * 3 + 0], model.bitangents[i * 3 + 1], model.bitangents[i * 3 + 2]);\n        bitangent = glm::normalize(bitangent);\n        model.bitangents[i * 3 + 0] = bitangent.x;\n        model.bitangents[i * 3 + 1] = bitangent.y;\n        model.bitangents[i * 3 + 2] = bitangent.z;\n    }\n}\n\nvoid centerModel(ModelData& modelData) {\n    // Compute the centroid of the model\n    glm::vec3 centroid(0.0f);\n    size_t vertexCount = modelData.vertices.size() / 3;\n\n    for (size_t i = 0; i < vertexCount; ++i) {\n        centroid.x += modelData.vertices[3 * i + 0];\n        centroid.y += modelData.vertices[3 * i + 1];\n        centroid.z += modelData.vertices[3 * i + 2];\n    }\n    centroid /= static_cast<float>(vertexCount);\n\n    // Find the minimum Z (height) value among all vertices\n    float minZ = std::numeric_limits<float>::max();\n    for (size_t i = 0; i < vertexCount; ++i) {\n        minZ = std::min(minZ, modelData.vertices[3 * i + 2]);\n    }\n\n    // Calculate the height adjustment needed to move the centroid to the minimum Z height\n    float heightAdjustment = centroid.z - minZ;\n\n    // Translate vertices to move the centroid to (centroid.x, centroid.y, minZ)\n    for (size_t i = 0; i < vertexCount; ++i) {\n        modelData.vertices[3 * i + 0] -= centroid.x; // Center X\n        modelData.vertices[3 * i + 1] -= centroid.y; // Center Y\n        modelData.vertices[3 * i + 2] -= heightAdjustment; // Move Z to minZ\n    }\n}\n\nbool loadOBJ(const std::string& filePath, const std::string& basePath, ModelData &modelData) {\n    tinyobj::attrib_t attrib;\n    std::vector<tinyobj::shape_t> shapes;\n    std::vector<tinyobj::material_t> materials;\n    std::string warn, err;\n\n    // Load OBJ file\n    bool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, filePath.c_str(), basePath.c_str());\n\n    if (!warn.empty()) {\n        std::cerr << \"TinyOBJLoader Warning: \" << warn << std::endl;\n    }\n\n    if (!err.empty()) {\n        std::cerr << \"TinyOBJLoader Error: \" << err << std::endl;\n        return false;\n    }\n\n    if (!ret) {\n        std::cerr << \"Failed to load/parse OBJ file: \" << filePath << std::endl;\n        return false;\n    }\n\n    // Initialize vectors\n    modelData.vertices.clear();\n    modelData.normals.clear();\n    modelData.texcoords.clear();\n    modelData.indices.clear();\n    modelData.tangents.clear();\n    modelData.bitangents.clear();\n\n    // Map to store unique vertices\n    struct IndexHash {\n        size_t operator()(const tinyobj::index_t& idx) const {\n            return std::hash<int>()(idx.vertex_index) ^\n                   std::hash<int>()(idx.normal_index) ^\n                   std::hash<int>()(idx.texcoord_index);\n        }\n    };\n\n    struct IndexEqual {\n        bool operator()(const tinyobj::index_t& lhs, const tinyobj::index_t& rhs) const {\n            return lhs.vertex_index == rhs.vertex_index &&\n                   lhs.normal_index == rhs.normal_index &&\n                   lhs.texcoord_index == rhs.texcoord_index;\n        }\n    };\n\n    std::unordered_map<tinyobj::index_t, unsigned int, IndexHash, IndexEqual> uniqueVertices;\n\n    // Loop over shapes\n    for (size_t s = 0; s < shapes.size(); ++s) {\n        const tinyobj::mesh_t& mesh = shapes[s].mesh;\n\n        size_t indexOffset = 0;\n        for (size_t f = 0; f < mesh.num_face_vertices.size(); ++f) {\n            int fv = mesh.num_face_vertices[f];\n\n            // For each vertex in the face\n            for (size_t v = 0; v < static_cast<size_t>(fv); ++v) {\n                tinyobj::index_t idx = mesh.indices[indexOffset + v];\n\n                // Process vertex using attrib arrays\n                // Positions\n                glm::vec3 position(\n                    attrib.vertices[3 * idx.vertex_index + 0],\n                    attrib.vertices[3 * idx.vertex_index + 1],\n                    attrib.vertices[3 * idx.vertex_index + 2]\n                );\n\n                // Normals\n                glm::vec3 normal(0.0f, 0.0f, 0.0f);\n                if (idx.normal_index >= 0) {\n                    normal = glm::vec3(\n                        attrib.normals[3 * idx.normal_index + 0],\n                        attrib.normals[3 * idx.normal_index + 1],\n                        attrib.normals[3 * idx.normal_index + 2]\n                    );\n                }\n\n                // Texture coordinates\n                glm::vec2 texcoord(0.0f, 0.0f);\n                if (idx.texcoord_index >= 0) {\n                    texcoord = glm::vec2(\n                        attrib.texcoords[2 * idx.texcoord_index + 0],\n                        attrib.texcoords[2 * idx.texcoord_index + 1]\n                    );\n                }\n\n                // Avoid duplicate vertices\n                if (uniqueVertices.count(idx) == 0) {\n                    uniqueVertices[idx] = static_cast<unsigned int>(modelData.vertices.size() / 3);\n\n                    // Add vertex data\n                    modelData.vertices.push_back(position.x);\n                    modelData.vertices.push_back(position.y);\n                    modelData.vertices.push_back(position.z);\n\n                    modelData.normals.push_back(normal.x);\n                    modelData.normals.push_back(normal.y);\n                    modelData.normals.push_back(normal.z);\n\n                    modelData.texcoords.push_back(texcoord.x);\n                    modelData.texcoords.push_back(texcoord.y);\n\n                    // Initialize tangents and bitangents\n                    modelData.tangents.push_back(0.0f);\n                    modelData.tangents.push_back(0.0f);\n                    modelData.tangents.push_back(0.0f);\n\n                    modelData.bitangents.push_back(0.0f);\n                    modelData.bitangents.push_back(0.0f);\n                    modelData.bitangents.push_back(0.0f);\n                }\n\n                modelData.indices.push_back(uniqueVertices[idx]);\n            }\n            indexOffset += fv;\n        }\n    }\n\n    // If normals are empty or zero, compute them\n    if (modelData.normals.empty() || modelData.normals[0] == 0.0f) {\n        // Compute normals\n        size_t numFaces = modelData.indices.size() / 3;\n        for (size_t i = 0; i < numFaces; ++i) {\n            unsigned int idx0 = modelData.indices[3 * i + 0];\n            unsigned int idx1 = modelData.indices[3 * i + 1];\n            unsigned int idx2 = modelData.indices[3 * i + 2];\n\n            glm::vec3 v0(modelData.vertices[3 * idx0 + 0], modelData.vertices[3 * idx0 + 1], modelData.vertices[3 * idx0 + 2]);\n            glm::vec3 v1(modelData.vertices[3 * idx1 + 0], modelData.vertices[3 * idx1 + 1], modelData.vertices[3 * idx1 + 2]);\n            glm::vec3 v2(modelData.vertices[3 * idx2 + 0], modelData.vertices[3 * idx2 + 1], modelData.vertices[3 * idx2 + 2]);\n\n            glm::vec3 normal = glm::normalize(glm::cross(v1 - v0, v2 - v0));\n\n            for (int j = 0; j < 3; ++j) {\n                modelData.normals[3 * modelData.indices[3 * i + j] + 0] += normal.x;\n                modelData.normals[3 * modelData.indices[3 * i + j] + 1] += normal.y;\n                modelData.normals[3 * modelData.indices[3 * i + j] + 2] += normal.z;\n            }\n        }\n\n        // Normalize the normals\n        size_t numVertices = modelData.vertices.size() / 3;\n        for (size_t i = 0; i < numVertices; ++i) {\n            glm::vec3 normal(\n                modelData.normals[3 * i + 0],\n                modelData.normals[3 * i + 1],\n                modelData.normals[3 * i + 2]\n            );\n            normal = glm::normalize(normal);\n            modelData.normals[3 * i + 0] = normal.x;\n            modelData.normals[3 * i + 1] = normal.y;\n            modelData.normals[3 * i + 2] = normal.z;\n        }\n    }\n\n    // Load textures for materials\n    for (size_t i = 0; i < materials.size(); ++i) {\n        tinyobj::material_t& mat = materials[i];\n        if (!mat.diffuse_texname.empty()) {\n            std::string texturePath = basePath + mat.diffuse_texname;\n            GLuint textureID = LoadTextureFromFile(texturePath.c_str());\n            modelData.materialToTexture[i] = textureID;\n        } else {\n            modelData.materialToTexture[i] = 0; // No texture\n        }\n    }\n\n    // Store materials and shapes\n    modelData.materials = materials;\n    modelData.shapes = shapes;\n\n    // Compute tangents and bitangents\n    computeTangents(modelData);\n\n    // centerModel(modelData);\n\n    return true;\n}\n\nvoid setupModelBuffers(ModelData &modelData) {\n    glGenVertexArrays(1, &modelData.vao);\n    glGenBuffers(1, &modelData.vbo);\n    glGenBuffers(1, &modelData.ebo);\n\n    glBindVertexArray(modelData.vao);\n\n    // Interleave data: Position (3) + Normal (3) + Texcoord (2) + Tangent (3) + Bitangent (3)\n    std::vector<float> interleavedData;\n    size_t numVertices = modelData.vertices.size() / 3; // Assuming positions are x,y,z\n\n    for (size_t i = 0; i < numVertices; ++i) {\n        // Positions (x, y, z)\n        interleavedData.push_back(modelData.vertices[3 * i]);\n        interleavedData.push_back(modelData.vertices[3 * i + 1]);\n        interleavedData.push_back(modelData.vertices[3 * i + 2]);\n\n        // Normals (nx, ny, nz)\n        interleavedData.push_back(modelData.normals[3 * i]);\n        interleavedData.push_back(modelData.normals[3 * i + 1]);\n        interleavedData.push_back(modelData.normals[3 * i + 2]);\n\n        // Texture Coordinates (u, v)\n        interleavedData.push_back(modelData.texcoords[2 * i]);\n        interleavedData.push_back(modelData.texcoords[2 * i + 1]);\n\n        // Tangents (tx, ty, tz)\n        interleavedData.push_back(modelData.tangents[3 * i]);\n        interleavedData.push_back(modelData.tangents[3 * i + 1]);\n        interleavedData.push_back(modelData.tangents[3 * i + 2]);\n\n        // Bitangents (bx, by, bz)\n        interleavedData.push_back(modelData.bitangents[3 * i]);\n        interleavedData.push_back(modelData.bitangents[3 * i + 1]);\n        interleavedData.push_back(modelData.bitangents[3 * i + 2]);\n    }\n\n    // Upload interleaved data to VBO\n    glBindBuffer(GL_ARRAY_BUFFER, modelData.vbo);\n    glBufferData(GL_ARRAY_BUFFER, interleavedData.size() * sizeof(float), interleavedData.data(), GL_STATIC_DRAW);\n\n    // Upload index data to EBO\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, modelData.ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, modelData.indices.size() * sizeof(unsigned int), modelData.indices.data(), GL_STATIC_DRAW);\n\n    // Set up vertex attributes\n    GLsizei stride = (3 + 3 + 2 + 3 + 3) * sizeof(float); // Position, Normal, Texcoord, Tangent, Bitangent\n    size_t offset = 0;\n\n    // Position attribute (location = 0)\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    // Normal attribute (location = 1)\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    // Texture Coordinate attribute (location = 2)\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 2 * sizeof(float);\n\n    // Tangent attribute (location = 3)\n    glEnableVertexAttribArray(3);\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    // Bitangent attribute (location = 4)\n    glEnableVertexAttribArray(4);\n    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, stride, (void*)offset);\n    offset += 3 * sizeof(float);\n\n    glBindVertexArray(0);\n}\n\n} // namespace utils_scene",
    "APP3/utils/sphere.cpp": "#include \"sphere.hpp\"\n#include <glm/glm.hpp>\n\nnamespace utils_object {\n\nsize_t createSphereVertices(std::vector<SphereVertex>& sphereVertices, glimac::Sphere& sphere) {\n    size_t sphereVertexCount = sphere.getVertexCount();\n    const glimac::ShapeVertex* sphereData = sphere.getDataPointer();\n    sphereVertices.resize(sphereVertexCount);\n\n    for (size_t i = 0; i < sphereVertexCount; ++i) {\n        sphereVertices[i].position = sphereData[i].position;\n        sphereVertices[i].normal = sphereData[i].normal;\n        sphereVertices[i].texCoords = sphereData[i].texCoords;\n        sphereVertices[i].tangent = glm::vec3(0.0f);\n        sphereVertices[i].bitangent = glm::vec3(0.0f);\n    }\n\n    return sphereVertexCount; // Return the vertex count\n}\n\nvoid computeSphereTangents(std::vector<SphereVertex>& vertices) {\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::vec3(0.0f);\n        vertex.bitangent = glm::vec3(0.0f);\n    }\n\n    for (size_t i = 0; i < vertices.size(); i += 3) {\n        SphereVertex& v0 = vertices[i];\n        SphereVertex& v1 = vertices[i + 1];\n        SphereVertex& v2 = vertices[i + 2];\n\n        glm::vec3 edge1 = v1.position - v0.position;\n        glm::vec3 edge2 = v2.position - v0.position;\n\n        glm::vec2 deltaUV1 = v1.texCoords - v0.texCoords;\n        glm::vec2 deltaUV2 = v2.texCoords - v0.texCoords;\n\n        float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n\n        glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\n        glm::vec3 bitangent = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);\n\n        v0.tangent += tangent;\n        v1.tangent += tangent;\n        v2.tangent += tangent;\n\n        v0.bitangent += bitangent;\n        v1.bitangent += bitangent;\n        v2.bitangent += bitangent;\n    }\n\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::normalize(vertex.tangent);\n        vertex.bitangent = glm::normalize(vertex.bitangent);\n    }\n}\n\nvoid setupSphereBuffers(const std::vector<SphereVertex>& sphereVertices, GLuint& sphereVBO, GLuint& sphereVAO) {\n    glGenBuffers(1, &sphereVBO);\n    glGenVertexArrays(1, &sphereVAO);\n\n    glBindVertexArray(sphereVAO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, sphereVBO);\n    glBufferData(GL_ARRAY_BUFFER, sphereVertices.size() * sizeof(SphereVertex), sphereVertices.data(), GL_STATIC_DRAW);\n\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, position));\n\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, normal));\n\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, texCoords));\n\n    glEnableVertexAttribArray(3);\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, tangent));\n\n    glEnableVertexAttribArray(4);\n    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(SphereVertex), (void*)offsetof(SphereVertex, bitangent));\n\n    glBindVertexArray(0);\n}\n\n} // namespace utils_object",
    "APP3/utils/rendering.cpp": "#include \"rendering.hpp\"\n\nnamespace utils_game_loop {\n\n\nvoid dynamic_loop(float &deltaTime, float &lastFrame, float &currentFrame,\n                  glimac::SDLWindowManager &windowManager, glm::vec3 &cameraPos,\n                  glm::vec3 &cameraFront, glm::vec3 &cameraUp, float cameraSpeed,\n                  bool &done, bool &isRockingChairPaused, double &rockingChairStartTime,\n                  double &rockingChairPausedTime, float &yaw, float &pitch, float cameraRadius,\n                  double frequency, double radius, double length,\n                  float cameraHeight) {\n\n    // Update dynamic only objects before rendering\n    for (auto& object : utils_scene::sceneObjects) {\n        if (!object.isStatic) {\n            // we place here all objects that we want to move\n            if (object.name == \"rocking_chair\") {\n                double adjustedTime = currentFrame - rockingChairStartTime;\n                if (isRockingChairPaused) {\n                    adjustedTime = rockingChairPausedTime - rockingChairStartTime;\n                }\n\n                glm::vec3 offsetPosition;\n                glm::vec3 rotation;\n                float rotationAngleRadians;\n                utils_object::GetRockingChairPositionAndRotation(\n                    adjustedTime,\n                    frequency,\n                    radius,\n                    length,\n                    offsetPosition,\n                    rotation\n                );\n\n                // Update position and rotation\n                object.position = object.initialPosition + offsetPosition;\n\n                object.rotationAngle = rotation.z; // Rotation around Z-axis\n                object.rotationAxis = glm::vec3(1.0f, 0.0f, 0.0f); // Rotation around X-axis\n            }\n            // if (object.name == \"\") {\n                \n            // }\n        }\n    }\n}\n\n} // namespace utils_game_loop",
    "APP3/utils/cube.cpp": "#include \"cube.hpp\"\n#include <glad/glad.h>\n#include <cstddef> // For offsetof\n\nnamespace utils_object {\n\nvoid createCube(std::vector<Vertex3D>& vertices, std::vector<GLuint>& indices) {\n    vertices = {\n        Vertex3D(glm::vec3(-0.5f, -0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 1), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(-1, 0, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, 0.5f), glm::vec3(-1, 0, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, 0.5f), glm::vec3(-1, 0, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, -0.5f), glm::vec3(-1, 0, 0), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, -0.5f), glm::vec3(1, 0, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, 0.5f), glm::vec3(1, 0, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(1, 0, 0), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, -0.5f), glm::vec3(1, 0, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, -0.5f), glm::vec3(0, 1, 0), glm::vec2(0.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, 0.5f, 0.5f), glm::vec3(0, 1, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 1, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, 0.5f, -0.5f), glm::vec3(0, 1, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(0, -1, 0), glm::vec2(1.0f, 1.0f)),\n        Vertex3D(glm::vec3(-0.5f, -0.5f, 0.5f), glm::vec3(0, -1, 0), glm::vec2(1.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, 0.5f), glm::vec3(0, -1, 0), glm::vec2(0.0f, 0.0f)),\n        Vertex3D(glm::vec3(0.5f, -0.5f, -0.5f), glm::vec3(0, -1, 0), glm::vec2(0.0f, 1.0f))\n    };\n\n    indices = {\n        0, 1, 2, 2, 3, 0,\n        4, 5, 6, 6, 7, 4,\n        8, 9, 10, 10, 11, 8,\n        12, 13, 14, 14, 15, 12,\n        16, 17, 18, 18, 19, 16,\n        20, 21, 22, 22, 23, 20\n    };\n}\n\nvoid computeCubeTangents(std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices) {\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::vec3(0.0f);\n        vertex.bitangent = glm::vec3(0.0f);\n    }\n\n    for (size_t i = 0; i < indices.size(); i += 3) {\n        GLuint i0 = indices[i];\n        GLuint i1 = indices[i + 1];\n        GLuint i2 = indices[i + 2];\n\n        Vertex3D& v0 = vertices[i0];\n        Vertex3D& v1 = vertices[i1];\n        Vertex3D& v2 = vertices[i2];\n\n        glm::vec3 edge1 = v1.position - v0.position;\n        glm::vec3 edge2 = v2.position - v0.position;\n\n        glm::vec2 deltaUV1 = v1.texCoords - v0.texCoords;\n        glm::vec2 deltaUV2 = v2.texCoords - v0.texCoords;\n\n        float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n\n        glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\n        glm::vec3 bitangent = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);\n\n        v0.tangent += tangent;\n        v1.tangent += tangent;\n        v2.tangent += tangent;\n\n        v0.bitangent += bitangent;\n        v1.bitangent += bitangent;\n        v2.bitangent += bitangent;\n    }\n\n    for (auto& vertex : vertices) {\n        vertex.tangent = glm::normalize(vertex.tangent);\n        vertex.bitangent = glm::normalize(vertex.bitangent);\n    }\n}\n\nvoid setupCubeBuffers(const std::vector<Vertex3D>& vertices, const std::vector<GLuint>& indices, GLuint& cubeVBO, GLuint& cubeEBO, GLuint& cubeVAO) {\n    glGenBuffers(1, &cubeVBO);\n    glGenBuffers(1, &cubeEBO);\n    glGenVertexArrays(1, &cubeVAO);\n\n    glBindVertexArray(cubeVAO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex3D), vertices.data(), GL_STATIC_DRAW);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, cubeEBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), indices.data(), GL_STATIC_DRAW);\n\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, position));\n\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, normal));\n\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, texCoords));\n\n    glEnableVertexAttribArray(3);\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, tangent));\n\n    glEnableVertexAttribArray(4);\n    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex3D), (void*)offsetof(Vertex3D, bitangent));\n\n    glBindVertexArray(0);\n}\n\n} // namespace utils_object",
    "APP3/utils/global.cpp": "#include \"global.hpp\"\n\n// Window dimensions\nint window_width = 1600;\nint window_height = 1000;\n\n// Stone floor coordinates\nint numCubesX = 15;    // Number of cubes along the x-axis\nint numCubesZ = 15;    // Number of cubes along the z-axis\nfloat spacingX = 1.0f; // Distance between each cube along the x-axis\nfloat spacingZ = 1.0f; // Distance between each cube along the z-axis\n\nconst GLuint SHADOW_WIDTH = 4096, SHADOW_HEIGHT = 4096;\n\nfloat cameraRadius = 0.15f; // Radius of the camera sphere for collision detection\nfloat cameraHeight = 2.0f;  // Height of the camera cylinder\n\nbool isRockingChairPaused = false;\ndouble rockingChairPausedTime = 0.0;\ndouble rockingChairStartTime = 0.0;\n\nfloat sensitivity = 0.1f;\nfloat currentFrame = 0.0f;",
    "APP3/utils/collision.cpp": "#include \"collision.hpp\"\n\nbool checkCollision(const glm::vec3& cylinderBaseCenter, float radius, float height, const AABB& box) {\n    float horizontalDistanceSquared = 0.0f;\n\n    for (int i = 0; i < 3; i += 2) {\n        if (cylinderBaseCenter[i] < box.min[i]) {\n            horizontalDistanceSquared += (box.min[i] - cylinderBaseCenter[i]) * (box.min[i] - cylinderBaseCenter[i]);\n        } else if (cylinderBaseCenter[i] > box.max[i]) {\n            horizontalDistanceSquared += (cylinderBaseCenter[i] - box.max[i]) * (cylinderBaseCenter[i] - box.max[i]);\n        }\n    }\n\n    if (horizontalDistanceSquared > (radius * radius)) {\n        return false;\n    }\n\n    float cylinderTop = cylinderBaseCenter.y + height / 2.0f;\n    float cylinderBottom = cylinderBaseCenter.y - height / 2.0f;\n    if (cylinderTop < box.min.y || cylinderBottom > box.max.y) {\n        return false;\n    }\n\n    return true;\n}",
    "APP3/shaders/shadow_mapping_depth.fs.glsl": "#version 330 core\n\nvoid main()\n{\n    // No output necessary; depth is automatically written to the depth buffer\n}",
    "APP3/shaders/unified_shader.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPosition;     // Vertex position\nlayout(location = 1) in vec3 aNormal;       // Vertex normal\nlayout(location = 2) in vec2 aTexCoords;    // Texture coordinates\nlayout(location = 3) in vec3 aTangent;      // Tangent vector\nlayout(location = 4) in vec3 aBitangent;    // Bitangent vector\n\n// Uniforms\nuniform mat4 uMVPMatrix;\nuniform mat4 uMVMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat4 lightSpaceMatrix;\nuniform mat4 uModelMatrix;\n\nout vec3 vNormal;\nout vec3 vFragPos;\nout vec2 vTexCoords;\nout vec4 vFragPosLightSpace;\nout mat3 TBN; // Tangent-Bitangent-Normal matrix\nout vec3 vFragPosWorld;\n\nvoid main()\n{\n    vNormal = normalize(uNormalMatrix * aNormal);\n    vFragPos = vec3(uMVMatrix * vec4(aPosition, 1.0));\n    vTexCoords = aTexCoords;\n    \n    // Calculate world space fragment position\n    vFragPosWorld = vec3(uModelMatrix * vec4(aPosition, 1.0));\n\n    // Transform TBN vectors into view space\n    vec3 T = normalize(uNormalMatrix * aTangent);\n    vec3 B = normalize(uNormalMatrix * aBitangent);\n    vec3 N = normalize(uNormalMatrix * aNormal);\n    TBN = mat3(T, B, N);\n\n    // Transform fragment position to light space\n    vFragPosLightSpace = lightSpaceMatrix * uModelMatrix * vec4(aPosition, 1.0);\n\n    gl_Position = uMVPMatrix * vec4(aPosition, 1.0);\n}",
    "APP3/shaders/point_shadow_depth.vs.glsl": "#version 330 core\nlayout(location = 0) in vec3 aPosition;\nuniform mat4 model;\nuniform mat4 shadowMatrix;\nout vec4 FragPos;\n\nvoid main() {\n    FragPos = model * vec4(aPosition, 1.0);\n    gl_Position = shadowMatrix * FragPos;\n}",
    "APP3/shaders/directionallight.fs.glsl": "#version 330 core\n\nin vec3 vNormal;\nin vec3 vFragPos;\nin vec2 vTexCoords;\nin vec4 vFragPosLightSpace;\nin mat3 TBN;\n\nout vec4 FragColor;\n\n// Material properties\nuniform vec3 uKd;         // Diffuse reflection coefficient\nuniform vec3 uKs;         // Specular reflection coefficient\nuniform float uShininess; // Shininess exponent\n\n// Light properties\nuniform vec3 uLightDir_vs;    // Light direction in view space\nuniform vec3 uLightIntensity; // Light intensity (color)\n\n// Texture sampler\nuniform sampler2D uTexture;\nuniform float uUseTexture; // Use 0.0 for false, 1.0 for true\n\n// Shadow map\nuniform sampler2D shadowMap;\n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap; // Use 0.0 for false, 1.0 for true\n\n// Function to calculate Blinn-Phong lighting\nvec3 blinnPhong(vec3 Kd, vec3 N) {\n    vec3 L = normalize(-uLightDir_vs);\n    vec3 V = normalize(-vFragPos);\n    vec3 H = normalize(L + V);\n\n    // Apply dynamic light color to diffuse component\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diffuse = Kd * uLightIntensity * NdotL;\n\n    // Apply dynamic light color to specular component\n    float NdotH = max(dot(N, H), 0.0);\n    vec3 specular = uKs * uLightIntensity * pow(NdotH, uShininess);\n\n    // Final color\n    return diffuse + specular;\n}\n\n// Function to calculate shadow factor with Percentage-Closer Filtering (PCF)\nfloat calculateShadowPCF(vec4 fragPosLightSpace) {\n    // Perform perspective divide to get normalized device coordinates\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n    // Transform to [0,1] range for texture coordinates\n    projCoords = projCoords * 0.5 + 0.5;\n\n    // Check if fragment is outside the light's orthographic frustum\n    if (projCoords.z > 1.0)\n        return 1.0;\n\n    // Add a small bias to prevent shadow acne\n    float bias = max(0.005 * (1.0 - dot(vNormal, normalize(-uLightDir_vs))), 0.0005);\n\n    // PCF parameters\n    float shadow = 0.0;\n    float texelSize = 1.0 / 8192.0; // Assuming a shadow map resolution of 8192x8192\n\n    // PCF loop for a 3x3 sample grid\n    for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n            shadow += (projCoords.z - bias > pcfDepth) ? 0.0 : 1.0;\n        }\n    }\n    shadow /= 9.0; // Average the shadow factor\n\n    return shadow;\n}\n\nvoid main() {\n    // Determine material color (either from texture or uniform)\n    vec3 Kd = (uUseTexture > 0.5) ? texture(uTexture, vTexCoords).rgb : uKd;\n\n    // Initialize normal vector\n    vec3 N = normalize(vNormal);\n\n    // Sample normal from normal map if enabled\n    if (uUseNormalMap > 0.5) {\n        vec3 normalMap = texture(uNormalMap, vTexCoords).rgb;\n        normalMap = normalMap * 2.0 - 1.0; // Transform from [0,1] to [-1,1]\n        N = normalize(TBN * normalMap);     // Transform normal from tangent to view space\n    }\n\n    // Calculate the Blinn-Phong lighting model result using the modified normal\n    vec3 color = blinnPhong(Kd, N);\n\n    // Define an ambient light component based on material color\n    vec3 ambientLight = vec3(0.1);\n    vec3 ambient = ambientLight * Kd;\n\n    // Calculate shadow factor using PCF\n    float shadow = calculateShadowPCF(vFragPosLightSpace);\n\n    // Combine Blinn-Phong color, ambient, and shadow factor\n    color = ambient + (color * shadow);\n\n    FragColor = vec4(color, 1.0);\n}",
    "APP3/shaders/shadow_mapping_depth.vs.glsl": "#version 330 core\n\nlayout(location = 0) in vec3 aPosition;\n\nuniform mat4 uLightSpaceMatrix;\nuniform mat4 uModelMatrix;\n\nvoid main()\n{\n    gl_Position = uLightSpaceMatrix * uModelMatrix * vec4(aPosition, 1.0);\n}",
    "APP3/shaders/pointlight.fs.glsl": "#version 330 core\n\nin vec3 vNormal;\nin vec3 vFragPos;\nin vec3 vFragPosWorld;\nin vec2 vTexCoords;\nin mat3 TBN;\n\nout vec4 FragColor;\n\n// Material properties\nuniform vec3 uKd;         // Diffuse reflection coefficient\nuniform vec3 uKs;         // Specular reflection coefficient\nuniform float uShininess; // Shininess exponent\n\n// Light properties\nuniform vec3 uLightPos_vs; // Light position in view space\nuniform vec3 lightPosWorld;    // Light position in world space\nuniform vec3 uLightIntensity;  // Light intensity (color)\nuniform float farPlane;\n\n// Camera position\nuniform vec3 cameraPosWorld;\n\n// Texture sampler\nuniform sampler2D uTexture;\nuniform float uUseTexture; // Use 0.0 for false, 1.0 for true\n\n// Normal map\nuniform sampler2D uNormalMap;\nuniform float uUseNormalMap; // Use 0.0 for false, 1.0 for true\n\n// Depth cube map\nuniform samplerCube depthMap;\n\nconst vec3 gridSamplingDisk[20] = vec3[](\n    vec3( 1,  0,  0), vec3(-1,  0,  0), vec3( 0,  1,  0), vec3( 0, -1,  0), \n    vec3( 0,  0,  1), vec3( 0,  0, -1), vec3( 1,  1,  0), vec3(-1,  1,  0), \n    vec3( 1, -1,  0), vec3(-1, -1,  0), vec3( 1,  0,  1), vec3(-1,  0,  1), \n    vec3( 1,  0, -1), vec3(-1,  0, -1), vec3( 0,  1,  1), vec3( 0, -1,  1), \n    vec3( 0,  1, -1), vec3( 0, -1, -1), vec3( 1,  1,  1), vec3(-1, -1, -1)\n);\n\nfloat ShadowCalculation(vec3 fragPosWorld) {\n    vec3 fragToLight = fragPosWorld - lightPosWorld;\n    float currentDepth = length(fragToLight);\n    float shadow = 0.0;\n    float bias = 0.20;\n    int samples = 20;\n    float viewDistance = length(cameraPosWorld - fragPosWorld);\n    float diskRadius = (1.0 + (viewDistance / farPlane)) / 25.0;\n\n    for(int i = 0; i < samples; ++i)\n    {\n        // Sample shadow map with a slight offset\n        float closestDepth = texture(depthMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;\n        closestDepth *= farPlane; // Undo mapping [0,1]\n        if(currentDepth - bias > closestDepth)\n            shadow += 1.0;\n    }\n    shadow /= float(samples);\n\n    return shadow;\n}\n\nvec3 blinnPhong(vec3 Kd, vec3 N) {\n    vec3 L = normalize(uLightPos_vs - vFragPos); // Light direction in view space\n    vec3 V = normalize(-vFragPos); // View direction in view space (camera at origin)\n    vec3 H = normalize(L + V); // Halfway vector\n\n    // Distance to the light\n    float distanceToLight = length(uLightPos_vs - vFragPos);\n\n    // Attenuation factors\n    float constant = 1.0;\n    float linear = 0.09;\n    float quadratic = 0.032;\n    float attenuation = 1.0 / (constant + linear * distanceToLight + quadratic * (distanceToLight * distanceToLight));\n\n    // Apply dynamic light color to diffuse component\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diffuse = Kd * uLightIntensity * NdotL * attenuation;\n\n    // Apply dynamic light color to specular component\n    float NdotH = max(dot(N, H), 0.0);\n    vec3 specular = uKs * uLightIntensity * pow(NdotH, uShininess) * attenuation;\n\n    // Final color\n    return diffuse + specular;\n}\n\nvoid main() {\n    // Determine material color (either from texture or uniform)\n    vec3 Kd = (uUseTexture > 0.5) ? texture(uTexture, vTexCoords).rgb : uKd;\n\n    // Initialize normal vector\n    vec3 N = normalize(vNormal);\n\n    // Sample normal from normal map if enabled\n    if (uUseNormalMap > 0.5) {\n        vec3 normalMap = texture(uNormalMap, vTexCoords).rgb;\n        normalMap = normalMap * 2.0 - 1.0; // Transform from [0,1] to [-1,1]\n        N = normalize(TBN * normalMap);     // Transform normal from tangent to view space\n    }\n\n    // Calculate the Blinn-Phong lighting model result using the modified normal\n    vec3 color = blinnPhong(Kd, N);\n\n    // Define an ambient light component based on material color\n    vec3 ambientLight = vec3(0.1);\n    vec3 ambient = ambientLight * Kd;\n\n    // Calculate shadow using the ShadowCalculation function\n    float shadow = ShadowCalculation(vFragPosWorld);\n\n    // Combine Blinn-Phong color, ambient, and shadow factor\n    color = ambient + (1.0 - shadow) * color ;\n\n    FragColor = vec4(color, 1.0);\n}",
    "APP3/shaders/point_shadow_depth.fs.glsl": "#version 330 core\nin vec4 FragPos;\nuniform vec3 lightPos;\nuniform float farPlane;\n\nvoid main() {\n    float lightDistance = length(FragPos.xyz - lightPos);\n    lightDistance = lightDistance / farPlane;\n    gl_FragDepth = lightDistance;\n}"
}